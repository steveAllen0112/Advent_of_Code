:Namespace Win
⎕IO ⎕ML ⎕WX←1 3 1

 BitInt←{,⊖4 8⍴11 ⎕DR↑(⎕DR ⍵)323 ⎕DR ⍵}

 BuildBinStruct←{∊⍺{⍺∊1 2 4 8:⍺ TxtInt ⍵ ⋄ ⍵{⍵↑⍺,⍵⍴↑⎕AV}|⍺}¨⍵}

 BuildTxtStruct←{∊⍺{⍺∊1 2 4 8:⍺ TxtInt ⍵ ⋄ ⍺=0:'' ⋄ ⍵{0<⍵:⍺,⍵⍴↑⎕AV ⋄ ((⍵-1)↓⍺),↑⎕AV}(|⍺)-×/⍴⍵}¨⍵}

∇ Exit;Exit;Init;InitRCodes;InitMessages;InitCodePages;InitSysInfos;Bitwise;BuildBinStruct;BuildTxtStruct;SplitBinStruct;SplitTxtStruct;BitInt;IntBit;HexInt;IntHex;TxtInt;IntTxt;HexTxt;TxtHex
     ⍝ Exits the initialisation WIN16/WIN32 Application Program Interface.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 :Hold '#.Win.Init'
     ⎕EX ⎕NL⍳4
 :EndHold
∇

 HexInt←{'0123456789ABCDEF'[1+(¯1⌽⍳1+⍴⍴⍵)⍉16 16 16 16 16 16 16 16⊤⍵]}

 HexTxt←{'0123456789ABCDEF'[⍵{1+,[(-2⌊⍴⍵)↑⍵](¯1⌽⍵)⍉16 16⊤83 ⎕DR ⍺}⍳1+1⌈⍴⍴⍵]}

∇ Init
 :Hold '#.Win.Init'
     :If ~×⎕NC'GetVersion'
     ⍝ Initializes WIN32 Application Program Interface.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ Do not change this function or its pathname.
     ⍝ If there is any serious need modifying it,
     ⍝ please consult me for syncronization.
     ⍝ mailto:Hager@Dortmund.net
         :If 0=#.⎕NC'Lowercase'
             #.Lowercase←((65↑⎕AV),'abcdefghijklmnopqrstuvwxyzY·∆abcdefghijklmnopqrstuvwxyz{€}⊣⌷¨àäåÆ⍨éñöØüßàáâäåæçèéêëíîïñ[/⌿\⍀<≤=≥>≠∨∧-+÷×?∊⍴~↑↓⍳○*⌈⌊∇∘(⊂⊃∩∪⊥⊤|;,⍱⍲⍒⍋⍉⌽⊖⍟⌹!⍕⍎⍫⍪≡≢óôöø"#&’┘┐┌└┼─├┤┴┬│@ùúû^ü‘∣¶:∊⍳¡⋄←→⍝)] §⎕⍞⍣')∘{1<≡⍵:⍺∘∇¨⍵ ⋄ ⍺[⎕AV⍳⍵]}
             #.Uppercase←((17↑⎕AV),'ABCDEFGHIJKLMNOPQRSTUVWXYZ¯.⍬0123456789¤¥$£¢∆ABCDEFGHIJKLMNOPQRSTUVWXYZY·∆ABCDEFGHIJKLMNOPQRSTUVWXYZ{€}⊣⌷¨ÀÄÅÆ⍨ÉÑÖØÜßÀAAÄÅæçEÉEEIIIÑ[/⌿\⍀<≤=≥>≠∨∧-+÷×?∊⍴~↑↓⍳○*⌈⌊∇∘(⊂⊃∩∪⊥⊤|;,⍱⍲⍒⍋⍉⌽⊖⍟⌹!⍕⍎⍫⍪≡≢OOÖø"#&’┘┐┌└┼─├┤┴┬│@UUU^Ü‘∣¶:∊⍳¡⋄←→⍝)] §⎕⍞⍣')∘{1<≡⍵:⍺∘∇¨⍵ ⋄ ⍺[⎕AV⍳⍵]}
             #.⎕FX'Buffer←RText;GetSystemDefaultLangID;GetErrorMessage;FormatMessageA;LoadLibraryA;FreeLibrary;OemToCharBuffA;LANG_NEUTRAL;LANG_GERMAN;FORMAT_MESSAGE_IGNORE_INSERTS;FORMAT_MESSAGE_FROM_HMODULE;FORMAT_MESSAGE_FROM_SYSTEM;SubLangID;LangID;Module;Flags;hModule;MessageId;LanguageId;Size;VOID' 'LANG_NEUTRAL←0' 'LANG_GERMAN←7' 'FORMAT_MESSAGE_IGNORE_INSERTS←512' 'FORMAT_MESSAGE_FROM_HMODULE←2048' 'FORMAT_MESSAGE_FROM_SYSTEM←4096' '⎕NA''U2 KERNEL32|GetSystemDefaultLangID''' '⎕NA''I KERNEL32|FormatMessageA I I I I >T[] I I''' ':If 0>MessageId←↑#.RCode' ':AndIf ¯16777216≤MessageId' 'MessageId←-MessageId' ':EndIf' 'SubLangID LangID←64 1024⊤LanguageId←GetSystemDefaultLangID' ':If LangID≠LANG_GERMAN' 'LanguageId←LANG_NEUTRAL' ':EndIf' 'Size←1024' ':Trap 0' '⎕NA''I EASYFILE|GetErrorMessage I >T[] I''' 'Buffer←↑↑/GetErrorMessage MessageId Size Size' ':Else' 'Flags←FORMAT_MESSAGE_FROM_SYSTEM+FORMAT_MESSAGE_IGNORE_INSERTS' 'Buffer←↑↑/FormatMessageA Flags 0 MessageId LanguageId Size Size 0' ':EndTrap' ':If 0∊⍴Buffer' '⎕NA''I KERNEL32|LoadLibraryA <0T''' '⎕NA''I KERNEL32|FreeLibrary I''' '⎕NA''USER32|OemToCharBuffA <T[] >T[] I''' 'Flags←FORMAT_MESSAGE_FROM_HMODULE+FORMAT_MESSAGE_IGNORE_INSERTS' ':For Module :In ''ADVAPI32'' ''WSOCK32'' ''WININET'' ''WINSCARD'' ''NETMSG'' ''NETEVENT'' ''DVPCSCmsgres''' ':If 0≠hModule←LoadLibraryA⊂Module' ':If Module≡''WSOCK32''' 'MessageId←(10060 10013 10023 10010 10011 10012 10026 10014 10015 10044 10036 10031 10030 10016 10029 10028 10122 10039 10046 10040 10038 10037 10127 10034 10035 10003 10047 10033 10135 10000 10042 10043 10017 10018 10019 10020 10021 10025 10001 10002 10148 10041 10005 10006 10007 10114,MessageId)[10013 10014 10024 10035 10036 10037 10038 10039 10040 10041 10042 10043 10044 10046 10047 10048 10049 10050 10051 10052 10053 10054 10055 10056 10057 10058 10059 10060 10061 10063 10064 10065 10066 10067 10068 10069 10070 10071 10091 10092 10093 10112 11001 11002 11003 11004⍳MessageId]' ':EndIf' 'Buffer←↑↑/FormatMessageA Flags hModule MessageId LanguageId Size Size 0' 'VOID←FreeLibrary hModule' ':If ×↑⍴Buffer' ':Leave' ':EndIf' ':EndIf' ':EndFor' ':If 1∊''←⍒⊣á⌹⍀⌿''∊Buffer' 'Size←↑⍴Buffer' 'Buffer←OemToCharBuffA Buffer Size Size' ':EndIf' ':EndIf' 'Buffer/⍨←~⎕AV[4 3]⍷Buffer ⋄ ((Buffer=⎕AV[3])/Buffer)←'' '' ⋄ Buffer↓⍨←-'' ''=¯1↑Buffer'
     ⍝ Generated by: Line←'#.⎕FX',∊'''',¨((,⊂'''' '''''')#.Replace {(¯1+(' '≠⍵)⍳1)↓⍵}¨#.⎕NR'RText'),¨⊂''' '
         :EndIf
         #.RCode←0
         ⎕EX'Proc._WsDir'
         FALSE←NULL←ZERO←IGNORE←0
         TRUE←1
         INVALID_HANDLE_VALUE←INVALID_FILE_SIZE←INFINITE←¯1
         MAX_PATH←260
         MAX_COMPUTERNAME_LENGTH←15
         MAXUIDLEN←64
         MINCHAR←¯128        ⍝ 0xFFFFFF80
         MAXCHAR←127         ⍝ 0x0000007F
         MINSHORT←¯32768     ⍝ 0xFFFF8000
         MAXSHORT←32767      ⍝ 0x00007FFF
         MINLONG←¯2147483648 ⍝ 0x80000000
         MAXLONG←2147483647  ⍝ 0x7FFFFFFF
         MAXBYTE←255         ⍝ 0x000000FF
         MAXWORD←65535       ⍝ 0x0000FFFF
         MAXDWORD←¯1         ⍝ 0xFFFFFFFF
     
         InitRCodes
         InitMessages
         InitCodePages
         InitSysInfos
     
         OF_READ←0      ⍝ Opens the file for reading only.
         OF_WRITE←1     ⍝ Opens the file for writing only.
         OF_READWRITE←2 ⍝ Opens the file for reading and writing.
         FILE_BEGIN←0   ⍝ Moves the file pointer lOffset bytes from the beginning of the file.
         FILE_CURRENT←1 ⍝ Moves the file pointer lOffset bytes from its current position.
         FILE_END←2     ⍝ Moves the file pointer lOffset bytes from the end of the file.
     
         FORMAT_MESSAGE_ALLOCATE_BUFFER←256
         FORMAT_MESSAGE_IGNORE_INSERTS←512
         FORMAT_MESSAGE_FROM_STRING←1024
         FORMAT_MESSAGE_FROM_HMODULE←2048
         FORMAT_MESSAGE_FROM_SYSTEM←4096
         FORMAT_MESSAGE_ARGUMENT_ARRAY←8192
         FORMAT_MESSAGE_MAX_WIDTH_MASK←255
         'FormatMessageI'⎕NA'I KERNEL32|FormatMessageA U I I I >T[] I I'
         'FormatMessageT'⎕NA'I KERNEL32|FormatMessageA U <0T I I >T[] I I'
         'GetCommandLine'⎕NA'I KERNEL32|GetCommandLineA'
         ⎕NA'I KERNEL32|GetEnvironmentStrings'
         'FreeEnvironmentStrings'⎕NA'I KERNEL32|FreeEnvironmentStringsA I'
         'GetEnvironmentVariable'⎕NA'I KERNEL32|GetEnvironmentVariableA <0T >0T I'
         'SetEnvironmentVariable'⎕NA'I KERNEL32|SetEnvironmentVariableA <0T <0T'
         'ExpandEnvironmentStrings'⎕NA'I KERNEL32|ExpandEnvironmentStringsA <0T >0T I'
         'GetTempPath'⎕NA'I KERNEL32|GetTempPathA I >T[]'
         'GetTempFileName'⎕NA'I KERNEL32|GetTempFileNameA <0T <0T I >0T'
         'LoadLibrary'⎕NA'I KERNEL32|LoadLibraryA <0T'
         'GetModuleHandle'⎕NA'I KERNEL32|GetModuleHandleA <0T'
         'GetModuleFileName'⎕NA'I KERNEL32|GetModuleFileNameA I >T[] I'
         ⎕NA'I KERNEL32|GetProcAddress I <0T'
         ⎕NA'I KERNEL32|FreeLibrary I'
         ⎕NA'I KERNEL32|VirtualQuery I >I[7] I'
         ⎕NA'I KERNEL32|GlobalAlloc I I'
         ⎕NA'I KERNEL32|GlobalReAlloc I I I'
         ⎕NA'I KERNEL32|GlobalFree I'
         ⎕NA'I KERNEL32|GlobalLock I'
         ⎕NA'I KERNEL32|GlobalUnlock I'
         ⎕NA'I KERNEL32|GlobalHandle I'
         ⎕NA'I KERNEL32|GlobalSize I'
     
         GMEM_FIXED←0     ⍝ Allocates fixed memory
         GMEM_MOVEABLE←2  ⍝ Allocates movable memory
         GMEM_ZEROINIT←64 ⍝ Initializes memory contents to zero
         GMEM_MODIFY←128  ⍝ Controls the reallocation of the memory object
         PAGE_NOACCESS←1
         PAGE_READONLY←2
         PAGE_READWRITE←4
         PAGE_WRITECOPY←8
         PAGE_EXECUTE←16
         PAGE_EXECUTE_READ←32
         PAGE_EXECUTE_READWRITE←64
         PAGE_EXECUTE_WRITECOPY←128
         PAGE_GUARD←256
         PAGE_NOCACHE←512
         PAGE_WRITECOMBINE←1024
         MEM_COMMIT←4096
         MEM_RESERVE←8192
         MEM_DECOMMIT←16384
         MEM_RELEASE←32768
         MEM_FREE←65536
         MEM_PRIVATE←131072
         MEM_MAPPED←262144
         MEM_RESET←524288
         MEM_TOP_DOWN←1048576
         MEM_WRITE_WATCH←2097152
         MEM_PHYSICAL←4194304
         SEC_FILE←8388608
         SEC_IMAGE←16777216
         SEC_RESERVE←67108864
         SEC_COMMIT←134217728
         SEC_NOCACHE←268435456
         MEM_4MB_PAGES←¯2147483648
     
         'lstrlen'⎕NA'I KERNEL32|lstrlenA <0T'
         'lstrlenPtr'⎕NA'I KERNEL32|lstrlenA I'
         'lstrcpy'⎕NA'I KERNEL32|lstrcpyA >0T <0T'
         'lstrcpyPtr'⎕NA'I KERNEL32|lstrcpyA >0T I'
         'lstrcpyn'⎕NA'I KERNEL32|lstrcpynA >T[] <T[] U'
         'lstrcpynPtr'⎕NA'I KERNEL32|lstrcpynA >T[] I U'
         'RtlMoveMemoryR'⎕NA'KERNEL32|RtlMoveMemory >T[] I U'
         'RtlMoveMemoryRI'⎕NA'KERNEL32|RtlMoveMemory >I[] I U'
         'RtlMoveMemoryW'⎕NA'KERNEL32|RtlMoveMemory I <I1[] U'
         'RtlMoveMemoryWI'⎕NA'KERNEL32|RtlMoveMemory I <I[] U'
     
         ⎕NA'I KERNEL32|IsValidCodePage U'
         ⎕NA'I KERNEL32|MultiByteToWideChar U  I <I1[] I >T[] I'
         ⎕NA'I KERNEL32|WideCharToMultiByte U  I <I1[] I >T[] I I I'
         'WideCharToMultiByteD'⎕NA'I KERNEL32|WideCharToMultiByte U  I <I1[] I >T[] I <I1[] I'
         'CharToOemBuff'⎕NA'I USER32|CharToOemBuffA <T[] >T[] I'
         'CharToOemCBuff'⎕NA'I USER32|CharToOemBuffA <T[] >C[] I'
         'OemToCharBuff'⎕NA'I USER32|OemToCharBuffA <T[] >T[] I'
         'OemCToCharBuff'⎕NA'I USER32|OemToCharBuffA <C[] >T[] I'
     
         MB_PRECOMPOSED←1          ⍝ use precomposed chars
         MB_COMPOSITE←2            ⍝ use composite chars
         MB_USEGLYPHCHARS←4        ⍝ use glyph chars, not ctrl chars
         MB_ERR_INVALID_CHARS←8    ⍝ error for invalid chars
         WC_COMPOSITECHECK←512     ⍝ convert composite to precomposed
         WC_DISCARDNS←16           ⍝ discard non-spacing chars
         WC_SEPCHARS←32            ⍝ generate separate chars
         WC_DEFAULTCHAR←64         ⍝ replace w/ default char
         WC_NO_BEST_FIT_CHARS←1024 ⍝ do not use best fit chars
     
         'GetPrivateProfileStringS'⎕NA'I KERNEL32|GetPrivateProfileStringA I I <0T >T[] I <0T'
         'GetPrivateProfileStringK'⎕NA'I KERNEL32|GetPrivateProfileStringA <0T I <0T >T[] I <0T'
         'GetPrivateProfileStringV'⎕NA'I KERNEL32|GetPrivateProfileStringA <0T <0T <0T >T[] I <0T'
         'WritePrivateProfileStringF'⎕NA'I KERNEL32|WritePrivateProfileStringA I I I <0T'
         'WritePrivateProfileStringS'⎕NA'I KERNEL32|WritePrivateProfileStringA <0T I I <0T'
         'WritePrivateProfileStringK'⎕NA'I KERNEL32|WritePrivateProfileStringA <0T <0T I <0T'
         'WritePrivateProfileStringV'⎕NA'I KERNEL32|WritePrivateProfileStringA <0T <0T <0T <0T'
     
         WHITE_BRUSH←0
         LTGRAY_BRUSH←1
         GRAY_BRUSH←2
         DKGRAY_BRUSH←3
         BLACK_BRUSH←4
         NULL_BRUSH←5
         WHITE_PEN←6
         BLACK_PEN←7
         NULL_PEN←8
         OEM_FIXED_FONT←10
         ANSI_FIXED_FONT←11
         ANSI_VAR_FONT←12
         SYSTEM_FONT←13
         DEVICE_DEFAULT_FONT←14
         DEFAULT_PALETTE←15
         SYSTEM_FIXED_FONT←16
         DEFAULT_GUI_FONT←17
         DC_BRUSH←18
         DC_PEN←19
         OBJ_PEN←1
         OBJ_BRUSH←2
         OBJ_DC←3
         OBJ_METADC←4
         OBJ_PAL←5
         OBJ_FONT←6
         OBJ_BITMAP←7
         OBJ_REGION←8
         OBJ_METAFILE←9
         OBJ_MEMDC←10
         OBJ_EXTPEN←11
         OBJ_ENHMETADC←12
         OBJ_ENHMETAFILE←13
         OBJ_COLORSPACE←14
         'CreateFontIndirectI4'⎕NA'I GDI32|CreateFontIndirectA <I[15]'
         ⎕NA'I GDI32|GetStockObject I'
         ⎕NA'I GDI32|GetObjectType I'
         'GetObject'⎕NA'I GDI32|GetObjectA I I >T[]'
         ⎕NA'I GDI32|DeleteObject I'
         'GetTextExtentPoint32'⎕NA'I GDI32|GetTextExtentPoint32A I <T[] I >I[2]'
         ⎕NA'I USER32|GetDC I'
         ⎕NA'I USER32|GetWindowDC I'
         ⎕NA'I USER32|ReleaseDC I I'
         'CreateDC'⎕NA'I GDI32|CreateDCA <0T <0T I <I1[]'
         'ResetDC'⎕NA'I GDI32|ResetDCA I <I1[]'
         ⎕NA'I GDI32|DeleteDC I'
         VK_SHIFT←16
         VK_CONTROL←17
         VK_MENU←18
         VK_PAUSE←19
         VK_CAPITAL←20
         VK_INSERT←45
         VK_DELETE←46
         VK_LWIN←91
         VK_RWIN←92
         VK_APPS←93
         VK_NUMLOCK←144
         VK_SCROLL←145
         VK_LSHIFT←160
         VK_RSHIFT←161
         VK_LCONTROL←162
         VK_RCONTROL←163
         VK_LMENU←164
         VK_RMENU←165
         ⎕NA'I USER32|GetKeyboardState >I1[256]'
         KEYEVENTF_EXTENDEDKEY←1
         KEYEVENTF_KEYUP←2
         ⎕NA'USER32|keybd_event I I I I'
         CF_TEXT←1              ⍝ ANSI text (line,CR,LF),..,NUL     ← hMem ⍝ Predefined Clipboard Formats
         CF_BITMAP←2            ⍝ Handle to a bitmap (HBITMAP)
         CF_METAFILEPICT←3      ⍝ Handle to a metafile picture format METAFILEPICT
         CF_SYLK←4              ⍝ Symbolic Link (SYLK) format
         CF_DIF←5               ⍝ Software Arts' Data Interchange Format
         CF_TIFF←6              ⍝ Tagged-image file format
         CF_OEMTEXT←7           ⍝ Text format in OEM character set (line,CR,LF),..,NUL
         CF_DIB←8               ⍝ Memory object containing BITMAPINFO⍪bitmap bits
         CF_PALETTE←9           ⍝ Handle to a color palette (SelectPalette RealizePalette)
         CF_PENDATA←10          ⍝ Data for pen extension
         CF_RIFF←11             ⍝ More complex audio data
         CF_WAVE←12             ⍝ Audio data in standard wave formats
         CF_UNICODETEXT←13      ⍝ Unicode text format (line,CR,LF),..,NUL-char
         CF_ENHMETAFILE←14      ⍝ Handle to an enhanced metafile (HENHMETAFILE)
         CF_HDROP←15            ⍝ Handle to type HDROP that identifies a file list (DragQueryFile)
         CF_LOCALE←16           ⍝ Handle to locale identifier (input language) of text in clipboard
         CF_DIBV5←17            ⍝ Memory object containing BITMAPV5HEADER⍪bitmap color space information⍪bitmap bits
         CF_OWNERDISPLAY←128    ⍝ Owner-display format, hMem is NULL
         CF_DSPTEXT←129         ⍝ Text display format associated with a private format
         CF_DSPBITMAP←130       ⍝ Bitmap display format associated with a private format
         CF_DSPMETAFILEPICT←131 ⍝ Metafile-picture display format associated with a private format
         CF_DSPENHMETAFILE←142  ⍝ Enhanced metafile display format associated with a private format
         CF_PRIVATEFIRST←512    ⍝ "Private" formats don't get GlobalFree'd
         CF_PRIVATELAST←767
         CF_GDIOBJFIRST←768     ⍝ "GDIOBJ" formats do get DeleteObject'd
         CF_GDIOBJLAST←1023
         ⎕NA'I USER32|OpenClipboard I'
         ⎕NA'I USER32|CloseClipboard'
         ⎕NA'I USER32|GetClipboardOwner'
         ⎕NA'I USER32|SetClipboardViewer I'
         ⎕NA'I USER32|GetClipboardViewer'
         ⎕NA'I USER32|ChangeClipboardChain I I'
         ⎕NA'I USER32|SetClipboardData I I'
         ⎕NA'I USER32|GetClipboardData I'
         'RegisterClipboardFormat'⎕NA'I USER32|RegisterClipboardFormatA <0T'
         ⎕NA'I USER32|CountClipboardFormats'
         ⎕NA'I USER32|EnumClipboardFormats I'
         'GetClipboardFormatName'⎕NA'I USER32|GetClipboardFormatNameA I >T[] I'
         ⎕NA'I USER32|EmptyClipboard'
         ⎕NA'I USER32|IsClipboardFormatAvailable I'
         ⎕NA'I USER32|GetPriorityClipboardFormat <I I'
         ⎕NA'I USER32|GetOpenClipboardWindow'
         'DragQueryFile'⎕NA'I SHELL32|DragQueryFileA I I >T[] I'
         ⎕NA'I USER32|GetWindowThreadProcessId I =I'
         :Trap 0
             'GetWindowModuleFileName'⎕NA'I USER32|GetWindowModuleFileNameA I >T[] I'
         :Else
             GetWindowModuleFileName←{0 ''}
         :EndTrap
         'GetClassName'⎕NA'I USER32|GetClassNameA I >T[] I'
         'FindWindow'⎕NA'I USER32|FindWindowA <0T <0T'
         'FindWindowIT'⎕NA'I USER32|FindWindowA I <0T'
         'FindWindowTI'⎕NA'I USER32|FindWindowA <0T I'
         'FindWindowII'⎕NA'I USER32|FindWindowA I I'
         ⎕NA'I USER32|GetParent I'
         ⎕NA'I USER32|SetParent I I'
         ⎕NA'I USER32|GetDesktopWindow'
         ⎕NA'I USER32|GetWindow I I'
         ⎕NA'I USER32|GetForegroundWindow'
         ⎕NA'I USER32|SetForegroundWindow I'
         'GetWindowText'⎕NA'I USER32|GetWindowTextA I >T[] I'
         'SetWindowText'⎕NA'I USER32|SetWindowTextA I <I1[]'
         ⎕NA'I USER32|GetWindowTextW I >T[] I'
         ⎕NA'I USER32|SetWindowTextW I <I1[]'
         GW_HWNDFIRST←0    ⍝ window of the same type that is highest in the Z order
         GW_HWNDLAST←1     ⍝ window of the same type that is lowest in the Z order
         GW_HWNDNEXT←2     ⍝ window below the specified window in the Z order or NULL
         GW_HWNDPREV←3     ⍝ window above the specified window in the Z order or NULL
         GW_OWNER←4        ⍝ window's owner window
         GW_CHILD←5        ⍝ child window at the top of the Z order
         GW_ENABLEDPOPUP←6 ⍝ enabled popup window owned by the specified window NT5 only
         DWL_USER←8        ⍝ extra information that is private to the application, such as handles or pointers
         DWL_DLGPROC←4     ⍝ address of the dialog box procedure
         DWL_MSGRESULT←0   ⍝ return value of a message processed in the dialog box procedure (TRUE/FALSE)
         GWL_WNDPROC←¯4    ⍝ address of the window procedure
         GWL_HINSTANCE←¯6  ⍝ handle to the application instance
         GWL_HWNDPARENT←¯8 ⍝ handle to the parent window, if any
         GWL_ID←¯12        ⍝ identifier of the window
         GWL_STYLE←¯16     ⍝ window styles
         GWL_EXSTYLE←¯20   ⍝ extended window styles
         GWL_USERDATA←¯21  ⍝ 32-bit value associated with the window
         'GetWindowLong'⎕NA'I USER32|GetWindowLongA I I'
         'SetWindowLong'⎕NA'I USER32|SetWindowLongA I I I'
         ⎕NA'I USER32|GetWindowLongW I I'
         ⎕NA'I USER32|SetWindowLongW I I I'
         ⎕NA'I USER32|IsWindowUnicode I'
         'EnumProps'⎕NA'I USER32|EnumPropsA I I'
     
         ⎕NA'I USER32|ShowCursor I'
         ⎕NA'I USER32|SetCursorPos I I'
         ⎕NA'I USER32|GetCursorPos >{I I}'
         ⎕NA'I USER32|GetCursor'
         ⎕NA'I USER32|SetCursor I'
         'LoadCursor'⎕NA'I USER32|LoadCursorA I <0T'
         'LoadCursorI'⎕NA'I USER32|LoadCursorA I I'
         'LoadCursorFromFile'⎕NA'I USER32|LoadCursorFromFileA <0T'
         :If 0≤GetVersion
             'LoadCursorFromFileI'⎕NA'I USER32|LoadCursorFromFileW I' ⍝ WinNT
         :Else
             'LoadCursorFromFileI'⎕NA'I USER32|LoadCursorFromFileA I' ⍝ Win95 (Bug in NT)
         :EndIf
         ⎕NA'I USER32|CopyIcon I'
         ⎕NA'I USER32|DestroyCursor I'
         OBM_CLOSE←32754
         OBM_UPARROW←32753
         OBM_DNARROW←32752
         OBM_RGARROW←32751
         OBM_LFARROW←32750
         OBM_REDUCE←32749
         OBM_ZOOM←32748
         OBM_RESTORE←32747
         OBM_REDUCED←32746
         OBM_ZOOMD←32745
         OBM_RESTORED←32744
         OBM_UPARROWD←32743
         OBM_DNARROWD←32742
         OBM_RGARROWD←32741
         OBM_LFARROWD←32740
         OBM_MNARROW←32739
         OBM_COMBO←32738
         OBM_UPARROWI←32737
         OBM_DNARROWI←32736
         OBM_RGARROWI←32735
         OBM_LFARROWI←32734
         OBM_OLD_CLOSE←32767
         OBM_SIZE←32766
         OBM_OLD_UPARROW←32765
         OBM_OLD_DNARROW←32764
         OBM_OLD_RGARROW←32763
         OBM_OLD_LFARROW←32762
         OBM_BTSIZE←32761
         OBM_CHECK←32760
         OBM_CHECKBOXES←32759
         OBM_BTNCORNERS←32758
         OBM_OLD_REDUCE←32757
         OBM_OLD_ZOOM←32756
         OBM_OLD_RESTORE←32755
         OCR_NORMAL←32512
         OCR_IBEAM←32513
         OCR_WAIT←32514
         OCR_CROSS←32515
         OCR_UP←32516
         OCR_SIZE←32640
         OCR_ICON←32641
         OCR_SIZENWSE←32642
         OCR_SIZENESW←32643
         OCR_SIZEWE←32644
         OCR_SIZENS←32645
         OCR_SIZEALL←32646
         OCR_ICOCUR←32647
         OCR_NO←32648
         OCR_APPSTARTING←32650
         ⎕NA'I USER32|SetSystemCursor I I'
     
         MB_OK←0
         MB_OKCANCEL←1
         MB_ABORTRETRYIGNORE←2
         MB_YESNOCANCEL←3
         MB_YESNO←4
         MB_RETRYCANCEL←5
         MB_ICONHAND←16
         MB_ICONQUESTION←32
         MB_ICONEXCLAMATION←48
         MB_ICONASTERISK←64
         MB_USERICON←128
         MB_ICONWARNING←MB_ICONEXCLAMATION
         MB_ICONERROR←MB_ICONHAND
         MB_ICONINFORMATION←MB_ICONASTERISK
         MB_ICONSTOP←MB_ICONHAND
         MB_DEFBUTTON1←0
         MB_DEFBUTTON2←256
         MB_DEFBUTTON3←512
         MB_DEFBUTTON4←768
         MB_APPLMODAL←0
         MB_SYSTEMMODAL←4096
         MB_TASKMODAL←8192
         MB_HELP←16384
         MB_NOFOCUS←32768
         MB_SETFOREGROUND←65536
         MB_DEFAULT_DESKTOP_ONLY←131072
         MB_TOPMOST←262144
         MB_RIGHT←524288
         MB_RTLREADING←1048576
         MB_SERVICE_NOTIFICATION←2097152
         MB_TYPEMASK←15
         MB_ICONMASK←240
         MB_DEFMASK←3840
         MB_MODEMASK←12288
         MB_MISCMASK←49152
         IDOK←1
         IDCANCEL←2
         IDABORT←3
         IDRETRY←4
         IDIGNORE←5
         IDYES←6
         IDNO←7
         IDCLOSE←8
         IDHELP←9
         'MessageBox'⎕NA'I USER32|MessageBoxA& I <0T <0T I'
         ⎕NA'I USER32|MessageBeep& I'
         DI_APPBANDING←1
         DI_ROPS_READ_DESTINATION←2
         'StartDoc'⎕NA'I GDI32|StartDocA I I'
         ⎕NA'I GDI32|StartPage I'
         ⎕NA'I GDI32|EndPage I'
         ⎕NA'I GDI32|EndDoc I'
         PRINTER_ENUM_DEFAULT←1
         PRINTER_ENUM_LOCAL←2
         PRINTER_ENUM_CONNECTIONS←4
         PRINTER_ENUM_NAME←8
         PRINTER_ENUM_REMOTE←16
         PRINTER_ENUM_SHARED←32
         PRINTER_ENUM_NETWORK←64
         'EnumPrinters'⎕NA'I WINSPOOL.DRV|EnumPrintersA I <0T I I I >I >I'
         'EnumPrintersI'⎕NA'I WINSPOOL.DRV|EnumPrintersA I I I I I >I >I'
         'OpenPrinter'⎕NA'I WINSPOOL.DRV|OpenPrinterA <0T >I <I[3]'
         'OpenPrinterI'⎕NA'I WINSPOOL.DRV|OpenPrinterA <0T >I I'
         ⎕NA'I WINSPOOL.DRV|PrinterProperties I I'
         'StartDocPrinter'⎕NA'I WINSPOOL.DRV|StartDocPrinterA I I I'
         ⎕NA'I WINSPOOL.DRV|StartPagePrinter I'
         ⎕NA'I WINSPOOL.DRV|EndPagePrinter I'
         ⎕NA'I WINSPOOL.DRV|EndDocPrinter I'
         ⎕NA'I WINSPOOL.DRV|ClosePrinter I'
         ⎕NA'I WINSPOOL.DRV|ReadPrinter I >T[] I >I'
         ⎕NA'I WINSPOOL.DRV|WritePrinter I <I1[] I >I'
         DEVMODE←¯32 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 2 2 ¯32 2 4 4 4 4 4 4 4 4 4 4 4 4 4
         DM_ORIENTATION←1 ⍝ Field selection bits
         DM_PAPERSIZE←2
         DM_PAPERLENGTH←4
         DM_PAPERWIDTH←8
         DM_SCALE←16
         DM_POSITION←32
         DM_NUP←64
         DM_COPIES←256
         DM_DEFAULTSOURCE←512
         DM_PRINTQUALITY←1024
         DM_COLOR←2048
         DM_DUPLEX←4096
         DM_YRESOLUTION←8192
         DM_TTOPTION←16384
         DM_COLLATE←32768
         DM_FORMNAME←65536
         DM_LOGPIXELS←131072
         DM_BITSPERPEL←262144
         DM_PELSWIDTH←524288
         DM_PELSHEIGHT←1048576
         DM_DISPLAYFLAGS←2097152
         DM_DISPLAYFREQUENCY←4194304
         DM_ICMMETHOD←8388608
         DM_ICMINTENT←16777216
         DM_MEDIATYPE←33554432
         DM_DITHERTYPE←67108864
         DM_PANNINGWIDTH←134217728
         DM_PANNINGHEIGHT←268435456
         DMORIENT_PORTRAIT←1 ⍝ Orientation selections
         DMORIENT_LANDSCAPE←2
         DMPAPER_LETTER←1               ⍝ Letter 8Ø×11" ⍝ Paper selections
         DMPAPER_LETTERSMALL←2          ⍝ Letter Small 8Ø×11"
         DMPAPER_TABLOID←3              ⍝ Tabloid 11×17"
         DMPAPER_LEDGER←4               ⍝ Ledger 17×11"
         DMPAPER_LEGAL←5                ⍝ Legal 8Ø×14"
         DMPAPER_A3←8                   ⍝ A3 297×420 mm
         DMPAPER_A4←9                   ⍝ A4 210×297 mm
         DMPAPER_A4SMALL←10             ⍝ A4 Small 210×297 mm
         DMPAPER_A5←11                  ⍝ A5 148×210 mm
         DMPAPER_B4←12                  ⍝ B4 (JIS) 250×354 mm
         DMPAPER_B5←13                  ⍝ B5 (JIS) 182×257 mm
         DMPAPER_ENV_C5←28              ⍝ Envelope C5 162×229 mm
         DMPAPER_ENV_C3←29              ⍝ Envelope C3 324×458 mm
         DMPAPER_ENV_C4←30              ⍝ Envelope C4 229×324 mm
         DMPAPER_ENV_C6←31              ⍝ Envelope C6 114×162 mm
         DMPAPER_ENV_C65←32             ⍝ Envelope C65 114×229 mm
         DMPAPER_ENV_B4←33              ⍝ Envelope B4 250×353 mm
         DMPAPER_ENV_B5←34              ⍝ Envelope B5 176×250 mm
         DMPAPER_ENV_B6←35              ⍝ Envelope B6 176×125 mm
         DMPAPER_ENV_ITALY←36           ⍝ Envelope 110×230 mm
         DMPAPER_FANFOLD_STD_GERMAN←40  ⍝ German Std Fanfold 8Ø×12"
         DMPAPER_FANFOLD_LGL_GERMAN←41  ⍝ German Legal Fanfold 8Ø×13"
         DMPAPER_ISO_B4←42              ⍝ B4 (ISO) 250×353 mm
         DMPAPER_9X11←44                ⍝ 9×11"
         DMPAPER_10X11←45               ⍝ 10×11"
         DMPAPER_15X11←46               ⍝ 15×11"
         DMPAPER_A4_EXTRA←53            ⍝ A4 Extra 9.27×12.69"
         DMPAPER_LETTER_TRANSVERSE←54   ⍝ Letter Transverse 8Ø×11"
         DMPAPER_A4_TRANSVERSE←55       ⍝ A4 Transverse 210×297 mm
         DMPAPER_LETTER_EXTRA_TRANSVERSE←56 ⍝ Letter Extra Transverse 9Ø×12"
         DMPAPER_A_PLUS←57              ⍝ SuperA/SuperA/A4 227×356 mm
         DMPAPER_B_PLUS←58              ⍝ SuperB/SuperB/A3 305×487 mm
         DMPAPER_A4_PLUS←60             ⍝ A4 Plus 210×330 mm
         DMPAPER_A5_TRANSVERSE←61       ⍝ A5 Transverse 148×210 mm
         DMPAPER_B5_TRANSVERSE←62       ⍝ B5 (JIS) Transverse 182×257 mm
         DMPAPER_A3_EXTRA←63            ⍝ A3 Extra 322×445 mm
         DMPAPER_A5_EXTRA←64            ⍝ A5 Extra 174×235 mm
         DMPAPER_B5_EXTRA←65            ⍝ B5 (ISO) Extra 201×276 mm
         DMPAPER_A2←66                  ⍝ A2 420×594 mm
         DMPAPER_A3_TRANSVERSE←67       ⍝ A3 Transverse 297×420 mm
         DMPAPER_A3_EXTRA_TRANSVERSE←68 ⍝ A3 Extra Transverse 322×445 mm
         DMPAPER_USER←256
         DMBIN_UPPER←1 ⍝ Bin selections
         DMBIN_ONLYONE←1
         DMBIN_LOWER←2
         DMBIN_MIDDLE←3
         DMBIN_MANUAL←4
         DMBIN_ENVELOPE←5
         DMBIN_ENVMANUAL←6
         DMBIN_AUTO←7
         DMBIN_TRACTOR←8
         DMBIN_SMALLFMT←9
         DMBIN_LARGEFMT←10
         DMBIN_LARGECAPACITY←11
         DMBIN_CASSETTE←14
         DMBIN_FORMSOURCE←15
         DMBIN_USER←256
         DMRES_DRAFT←¯1 ⍝ Print qualities
         DMRES_LOW←¯2
         DMRES_MEDIUM←¯3
         DMRES_HIGH←¯4
         DMCOLOR_MONOCHROME←1 ⍝ Color enable/disable for color printers
         DMCOLOR_COLOR←2
         DMDUP_SIMPLEX←1 ⍝ Duplex enable
         DMDUP_VERTICAL←2
         DMDUP_HORIZONTAL←3
         DMCOLLATE_FALSE←0 ⍝ Collation selections
         DMCOLLATE_TRUE←1
         DMNUP_SYSTEM←1 ⍝ Nup, multiple logical page per physical page options
         DMNUP_ONEUP←2
         DMMEDIA_STANDARD←1 ⍝ Media types
         DMMEDIA_TRANSPARENCY←2
         DMMEDIA_GLOSSY←3
         DMMEDIA_USER←256
         PRINTER_CONTROL_PAUSE←1
         PRINTER_CONTROL_RESUME←2
         PRINTER_CONTROL_PURGE←3
         PRINTER_CONTROL_SET_STATUS←4
         PRINTER_STATUS_PAUSED←1
         PRINTER_STATUS_ERROR←2
         PRINTER_STATUS_PENDING_DELETION←4
         PRINTER_STATUS_PAPER_JAM←8
         PRINTER_STATUS_PAPER_OUT←16
         PRINTER_STATUS_MANUAL_FEED←32
         PRINTER_STATUS_PAPER_PROBLEM←64
         PRINTER_STATUS_OFFLINE←128
         PRINTER_STATUS_IO_ACTIVE←256
         PRINTER_STATUS_BUSY←512
         PRINTER_STATUS_PRINTING←1024
         PRINTER_STATUS_OUTPUT_BIN_FULL←2048
         PRINTER_STATUS_NOT_AVAILABLE←4096
         PRINTER_STATUS_WAITING←8192
         PRINTER_STATUS_PROCESSING←16384
         PRINTER_STATUS_INITIALIZING←32768
         PRINTER_STATUS_WARMING_UP←65536
         PRINTER_STATUS_TONER_LOW←131072
         PRINTER_STATUS_NO_TONER←262144
         PRINTER_STATUS_PAGE_PUNT←524288
         PRINTER_STATUS_USER_INTERVENTION←1048576
         PRINTER_STATUS_OUT_OF_MEMORY←2097152
         PRINTER_STATUS_DOOR_OPEN←4194304
         PRINTER_STATUS_SERVER_UNKNOWN←8388608
         PRINTER_STATUS_POWER_SAVE←16777216
         'GetPrinter'⎕NA'I WINSPOOL.DRV|GetPrinterA I I >T[] I >I'
         'GetPrinterI'⎕NA'I WINSPOOL.DRV|GetPrinterA I I I I >I'
         'SetPrinterI'⎕NA'I WINSPOOL.DRV|SetPrinterA I I I I'
         JOB_CONTROL_PAUSE←1
         JOB_CONTROL_RESUME←2
         JOB_CONTROL_CANCEL←3
         JOB_CONTROL_RESTART←4
         JOB_CONTROL_DELETE←5
         JOB_CONTROL_SENT_TO_PRINTER←6
         JOB_CONTROL_LAST_PAGE_EJECTED←7
         JOB_STATUS_PAUSED←1
         JOB_STATUS_ERROR←2
         JOB_STATUS_DELETING←4
         JOB_STATUS_SPOOLING←8
         JOB_STATUS_PRINTING←16
         JOB_STATUS_OFFLINE←32
         JOB_STATUS_PAPEROUT←64
         JOB_STATUS_PRINTED←128
         JOB_STATUS_DELETED←256
         JOB_STATUS_BLOCKED_DEVQ←512
         JOB_STATUS_USER_INTERVENTION←1024
         JOB_STATUS_RESTART←2048
         JOB_STATUS_COMPLETE←4096
         'GetJob'⎕NA'I WINSPOOL.DRV|GetJobA I I I >T[] I >I'
         'GetJobI'⎕NA'I WINSPOOL.DRV|GetJobA I I I I I >I'
         'SetJobI'⎕NA'I WINSPOOL.DRV|SetJobA I I I I I'
         'EnumJobsI'⎕NA'I WINSPOOL.DRV|EnumJobsA I I I I I I >I >I'
         DM_OUT_DEFAULT←1
         DM_OUT_BUFFER←2
         DM_IN_PROMPT←4
         DM_IN_BUFFER←8
         'DocumentPropertiesS'⎕NA'I WINSPOOL.DRV|DocumentPropertiesA I I <0T I I I'
         'DocumentProperties'⎕NA'I WINSPOOL.DRV|DocumentPropertiesA& I I <0T =I1[] <I1[] I'
         ⎕NA'I WINSPOOL.DRV|PrinterProperties& I I'
         PD_ALLPAGES←0
         PD_SELECTION←1
         PD_PAGENUMS←2
         PD_NOSELECTION←4
         PD_NOPAGENUMS←8
         PD_COLLATE←16
         PD_PRINTTOFILE←32
         PD_PRINTSETUP←64
         PD_NOWARNING←128
         PD_RETURNDC←256
         PD_RETURNIC←512
         PD_RETURNDEFAULT←1024
         PD_SHOWHELP←2048
         PD_ENABLEPRINTHOOK←4096
         PD_ENABLESETUPHOOK←8192
         PD_ENABLEPRINTTEMPLATE←16384
         PD_ENABLESETUPTEMPLATE←32768
         PD_ENABLEPRINTTEMPLATEHANDLE←65536
         PD_ENABLESETUPTEMPLATEHANDLE←131072
         PD_USEDEVMODECOPIESANDCOLLATE←262144
         PD_DISABLEPRINTTOFILE←524288
         PD_HIDEPRINTTOFILE←1048576
         PD_NONETWORKBUTTON←2097152
         DN_DEFAULTPRN←1
         'PrintDlg'⎕NA'I COMDLG32|PrintDlgA& ={I I I I I I U2 U2 U2 U2 U2 I I I I I I I I}'
         PSD_DEFAULTMINMARGINS←0                  ⍝ default (printer's)
         PSD_INWININIINTLMEASURE←0                ⍝ 1st of 4 possible
         PSD_MINMARGINS←1                         ⍝ use caller's
         PSD_MARGINS←2                            ⍝ use caller's
         PSD_INTHOUSANDTHSOFINCHES←4              ⍝ 2nd of 4 possible
         PSD_INHUNDREDTHSOFMILLIMETERS←8          ⍝ 3rd of 4 possible
         PSD_DISABLEMARGINS←16
         PSD_DISABLEPRINTER←32
         PSD_NOWARNING←128                        ⍝ must be same as PD_*
         PSD_DISABLEORIENTATION←256
         PSD_RETURNDEFAULT←1024                   ⍝ must be same as PD_*
         PSD_DISABLEPAPER←512
         PSD_SHOWHELP←2048                        ⍝ must be same as PD_*
     ⍝        PSD_ENABLEPAGESETUPHOOK←8192             ⍝ must be same as PD_*
     ⍝        PSD_ENABLEPAGESETUPTEMPLATE←32768        ⍝ must be same as PD_*
     ⍝        PSD_ENABLEPAGESETUPTEMPLATEHANDLE←131072 ⍝ must be same as PD_*
     ⍝        PSD_ENABLEPAGEPAINTHOOK←262144
         PSD_DISABLEPAGEPAINTING←524288
         PSD_NONETWORKBUTTON←2097152              ⍝ must be same as PD_*
         'PageSetupDlg'⎕NA'I COMDLG32|PageSetupDlgA& ={I I I I I {I I} {I I I I} {I I I I} I I I I I I}'
         EWX_LOGOFF←0
         EWX_SHUTDOWN←1
         EWX_REBOOT←2
         EWX_FORCE←4
         EWX_POWEROFF←8
         ⎕NA'I USER32|ExitWindowsEx I I'
         :Trap 0 ⍝ WinNT/OSR2 only
             'GetDiskFreeSpaceEx'⎕NA'I KERNEL32|GetDiskFreeSpaceExA <0T >U[2] >U[2] >U[2]'
         :Else
             GetDiskFreeSpaceEx←{0 0 0 0}
         :EndTrap
         'GetDiskFreeSpace'⎕NA'I KERNEL32|GetDiskFreeSpaceA <0T >U >U >U >U'
         'GetVolumeInformation'⎕NA'I KERNEL32|GetVolumeInformationA <0T >0T I >I >I >I >0T I'
         'CreateDirectory'⎕NA'I KERNEL32|CreateDirectoryA <0T <{I I I}'
         'RemoveDirectory'⎕NA'I KERNEL32|RemoveDirectoryA <0T'
         'FindFirstFile'⎕NA'I KERNEL32|FindFirstFileA <0T >{I {U U} {U U} {U U} {U U} I I T[260] T[14]}'
         'FindNextFile'⎕NA'I KERNEL32|FindNextFileA I >{I {U U} {U U} {U U} {U U} I I T[260] T[14]}'
         ⎕NA'I KERNEL32|FindClose I'
         ⎕NA'U KERNEL32|GetTickCount'
         ⎕NA'KERNEL32|GetSystemTime >{U2 U2 U2 U2 U2 U2 U2 U2}'
         ⎕NA'I KERNEL32|FileTimeToLocalFileTime <{U U} >{U U}'
         ⎕NA'I KERNEL32|FileTimeToSystemTime <{U U} >{U2 U2 U2 U2 U2 U2 U2 U2}'
         ⎕NA'I KERNEL32|SystemTimeToFileTime <{U2 U2 U2 U2 U2 U2 U2 U2} >{U U}'
         ⎕NA'I KERNEL32|LocalFileTimeToFileTime <{U U} >{U U}'
         'GetFileAttributes'⎕NA'I KERNEL32|GetFileAttributesA <0T'
         'SetFileAttributes'⎕NA'I KERNEL32|SetFileAttributesA <0T I'
         SCS_32BIT_BINARY←0 ⍝ Win32-based application
         SCS_DOS_BINARY←1   ⍝ MS-DOS-based application
         SCS_WOW_BINARY←2   ⍝ Win16-based application
         SCS_PIF_BINARY←3   ⍝ PIF file that executes an MS-DOS-based application
         SCS_POSIX_BINARY←4 ⍝ POSIX-based application
         SCS_OS216_BINARY←5 ⍝ OS/2-based application
         'GetBinaryType'⎕NA'I KERNEL32|GetBinaryTypeA <0T >I'
         'DeleteFile'⎕NA'I KERNEL32|DeleteFileA <0T'
         'CopyFile'⎕NA'I KERNEL32|CopyFileA <0T <0T I'
         'MoveFile'⎕NA'I KERNEL32|MoveFileA <0T <0T'
         MOVEFILE_REPLACE_EXISTING←1
         MOVEFILE_COPY_ALLOWED←2
         MOVEFILE_DELAY_UNTIL_REBOOT←4
         MOVEFILE_WRITE_THROUGH←8
         'MoveFileEx'⎕NA'I KERNEL32|MoveFileExA <0T <0T I'
         'MoveFileExI'⎕NA'I KERNEL32|MoveFileExA <0T I I'
         SECURITY_ATTRIBUTES←12 NULL FALSE
         DUPLICATE_CLOSE_SOURCE←1
         DUPLICATE_SAME_ACCESS←2
         'CreateFile'⎕NA'I KERNEL32|CreateFileA <0T I I <{I I I} I I I'
         ⎕NA'I KERNEL32|CreatePipe >I >I <{I I I} I'
         ⎕NA'U KERNEL32|GetFileInformationByHandle I >{I {U U} {U U} {U U} I {U U} I {U U}}'
         'GetFileTime'⎕NA'I KERNEL32|GetFileTime I >{U U} >{U U} >{U U}'
         'SetFileTimeW'⎕NA'I KERNEL32|SetFileTime I I I <{U U}'
         'SetFileTimeA'⎕NA'I KERNEL32|SetFileTime I I <{U U} I'
         'SetFileTimeAW'⎕NA'I KERNEL32|SetFileTime I I <{U U} <{U U}'
         'SetFileTimeC'⎕NA'I KERNEL32|SetFileTime I <{U U} I I'
         'SetFileTimeCW'⎕NA'I KERNEL32|SetFileTime I <{U U} I <{U U}'
         'SetFileTimeCA'⎕NA'I KERNEL32|SetFileTime I <{U U} <{U U} I'
         'SetFileTimeCAW'⎕NA'I KERNEL32|SetFileTime I <{U U} <{U U} <{U U}'
         ⎕NA'I KERNEL32|GetFileSize I >U[1]'
         ⎕NA'I KERNEL32|SetEndOfFile I'
         ⎕NA'I KERNEL32|CloseHandle I'
         ⎕NA'I KERNEL32|DuplicateHandle I I I >I I I I'
         ⎕NA'I KERNEL32|SetFilePointer I U =U I'
         ⎕NA'I KERNEL32|PeekNamedPipe I >T[] I  >I >I >I'
         'PeekNamedPipeAvail'⎕NA'I KERNEL32|PeekNamedPipe I I I I >I I'
         'DeviceIoControlRT'⎕NA'I KERNEL32|DeviceIoControl I I I I =T[] I >I I'
         'DeviceIoControlRI'⎕NA'I KERNEL32|DeviceIoControl I I I I =I[] I >I I'
         'DeviceIoControlWT'⎕NA'I KERNEL32|DeviceIoControl I I <I1[] I I I >I I'
         'DeviceIoControlWI'⎕NA'I KERNEL32|DeviceIoControl I I <I[] I I I >I I'
         'DeviceIoControlRWT'⎕NA'I KERNEL32|DeviceIoControl I I <I1[] I =T[] I >I I'
         'DeviceIoControlRWI'⎕NA'I KERNEL32|DeviceIoControl I I <I[] I =I[] I >I I'
         'ReadFileT'⎕NA'I KERNEL32|ReadFile I >T[] I >I I'
         'ReadFileC'⎕NA'I KERNEL32|ReadFile I >C[] I >I I'
         'ReadFileI1'⎕NA'I KERNEL32|ReadFile I >I1[] I >I I'
         'ReadFileI2'⎕NA'I KERNEL32|ReadFile I >I2[] I >I I'
         'ReadFileI4'⎕NA'I KERNEL32|ReadFile I >I[] I >I I'
         'ReadFileF8'⎕NA'I KERNEL32|ReadFile I >F8[] I >I I'
         'ReadFileM'⎕NA'I KERNEL32|ReadFile I I I >I I'
         'WriteFileC'⎕NA'I KERNEL32|WriteFile I <C[] I >I I'
         'WriteFileI1'⎕NA'I KERNEL32|WriteFile I <I1[] I >I I'
         'WriteFileI2'⎕NA'I KERNEL32|WriteFile I <I2[] I >I I'
         'WriteFileI4'⎕NA'I KERNEL32|WriteFile I <I[] I >I I'
         'WriteFileF8'⎕NA'I KERNEL32|WriteFile I <F8[] I >I I'
         'WriteFileM'⎕NA'I KERNEL32|WriteFile I I I >I I'
         OVERLAPPED←0 0 0 0 0
         'ReadFileOverlappedT'⎕NA'I KERNEL32|ReadFile I >T[] I >I <{U U U U I}'
         'ReadFileOverlappedI1'⎕NA'I KERNEL32|ReadFile I >I1[] I >I <{U U U U I}'
         'ReadFileOverlappedI2'⎕NA'I KERNEL32|ReadFile I >I2[] I >I <{U U U U I}'
         'ReadFileOverlappedI4'⎕NA'I KERNEL32|ReadFile I >I[] I >I <{U U U U I}'
         'ReadFileOverlappedF8'⎕NA'I KERNEL32|ReadFile I >F8[] I >I <{U U U U I}'
         'WriteFileOverlappedI1'⎕NA'I KERNEL32|WriteFile I <I1[] I >I <{U U U U I}'
         'WriteFileOverlappedI2'⎕NA'I KERNEL32|WriteFile I <I2[] I >I <{U U U U I}'
         'WriteFileOverlappedI4'⎕NA'I KERNEL32|WriteFile I <I[] I >I <{U U U U I}'
         'WriteFileOverlappedF8'⎕NA'I KERNEL32|WriteFile I <F8[] I >I <{U U U U I}'
         'CreateFileMapping'⎕NA'I KERNEL32|CreateFileMappingA I <{I I I} I U U <0T'
         'OpenFileMapping'⎕NA'I KERNEL32|OpenFileMappingA I I <0T'
         ⎕NA'I KERNEL32|MapViewOfFile I I U U U'
         ⎕NA'I KERNEL32|UnmapViewOfFile I'
         DELETE←65536                 ⍝ dwDesiredAccess Values:
         READ_CONTROL←131072
         WRITE_DAC←262144
         WRITE_OWNER←524288
         SYNCHRONIZE←1048576
         STANDARD_RIGHTS_REQUIRED←983040
         STANDARD_RIGHTS_READ←READ_CONTROL
         STANDARD_RIGHTS_WRITE←READ_CONTROL
         STANDARD_RIGHTS_EXECUTE←READ_CONTROL
         STANDARD_RIGHTS_ALL←2031616
         SPECIFIC_RIGHTS_ALL←65535
         ACCESS_SYSTEM_SECURITY←16777216
         MAXIMUM_ALLOWED←33554432
         GENERIC_QUERY_ATTRIB_ONLY←0  ⍝ Specifies device query access to the object.
         GENERIC_ALL←268435456
         GENERIC_EXECUTE←536870912
         GENERIC_WRITE←1073741824     ⍝ Specifies write access to the object.
         GENERIC_READ←¯2147483648     ⍝ Specifies read access to the object.
         FILE_READ_DATA←1
         FILE_LIST_DIRECTORY←1
         FILE_WRITE_DATA←2
         FILE_ADD_FILE←2
         FILE_APPEND_DATA←4
         FILE_ADD_SUBDIRECTORY←4
         FILE_CREATE_PIPE_INSTANCE←4
         FILE_READ_EA←8
         FILE_WRITE_EA←16
         FILE_EXECUTE←32
         FILE_TRAVERSE←32
         FILE_DELETE_CHILD←64
         FILE_READ_ATTRIBUTES←128
         FILE_WRITE_ATTRIBUTES←256
         FILE_ALL_ACCESS←2032127
         FILE_GENERIC_READ←1179785
         FILE_GENERIC_WRITE←1179926
         FILE_GENERIC_EXECUTE←1179808
         FILE_MAP_COPY←1
         FILE_MAP_WRITE←2
         FILE_MAP_READ←4
         FILE_MAP_ALL_ACCESS←983071
         SERVER_ACCESS_ADMINISTER←1
         SERVER_ACCESS_ENUMERATE←2
         SERVER_ALL_ACCESS←983043     ⍝ STANDARD_RIGHTS_REQUIRED∨SERVER_ACCESS_ADMINISTER∨SERVER_ACCESS_ENUMERATE
         SERVER_READ←131074           ⍝ STANDARD_RIGHTS_READ∨SERVER_ACCESS_ENUMERATE
         SERVER_WRITE←131075          ⍝ STANDARD_RIGHTS_WRITE∨SERVER_ACCESS_ADMINISTER∨SERVER_ACCESS_ENUMERATE
         SERVER_EXECUTE←131074        ⍝ STANDARD_RIGHTS_EXECUTE∨SERVER_ACCESS_ENUMERATE
         PRINTER_ACCESS_ADMINISTER←4
         PRINTER_ACCESS_USE←8
         PRINTER_ALL_ACCESS←983052    ⍝ STANDARD_RIGHTS_REQUIRED∨PRINTER_ACCESS_ADMINISTER∨PRINTER_ACCESS_USE
         PRINTER_READ←131080          ⍝ STANDARD_RIGHTS_READ∨PRINTER_ACCESS_USE
         PRINTER_WRITE←131080         ⍝ STANDARD_RIGHTS_WRITEPRINTER_ACCESS_USE
         PRINTER_EXECUTE←131080       ⍝ STANDARD_RIGHTS_EXECUTE∨PRINTER_ACCESS_USE
         JOB_ACCESS_ADMINISTER←16
         JOB_ALL_ACCESS←983056        ⍝ STANDARD_RIGHTS_REQUIRED∨JOB_ACCESS_ADMINISTER
         JOB_READ←131088              ⍝ STANDARD_RIGHTS_READ∨JOB_ACCESS_ADMINISTER
         JOB_WRITE←131088             ⍝ STANDARD_RIGHTS_WRITE∨JOB_ACCESS_ADMINISTER
         JOB_EXECUTE←131088           ⍝ STANDARD_RIGHTS_EXECUTE∨JOB_ACCESS_ADMINISTER
         KEY_QUERY_VALUE←1
         KEY_SET_VALUE←2
         KEY_CREATE_SUB_KEY←4
         KEY_ENUMERATE_SUB_KEYS←8
         KEY_NOTIFY←16
         KEY_CREATE_LINK←32
         KEY_READ←131097       ⍝ STANDARD_RIGHTS_READ∨KEY_QUERY_VALUE∨KEY_ENUMERATE_SUB_KEYS∨KEY_NOTIFY∧~SYNCHRONIZE
         KEY_WRITE←131078      ⍝ STANDARD_RIGHTS_WRITE∨KEY_SET_VALUE∨KEY_CREATE_SUB_KEY∧~SYNCHRONIZE
         KEY_EXECUTE←131097    ⍝ KEY_READ∧~SYNCHRONIZE
         KEY_ALL_ACCESS←983103 ⍝ STANDARD_RIGHTS_ALL∨KEY_QUERY_VALUE∨KEY_SET_VALUE∨KEY_CREATE_SUB_KEY∨KEY_ENUMERATE_SUB_KEYS∨KEY_NOTIFY∨KEY_CREATE_LINK∧~SYNCHRONIZE
         EVENT_MODIFY_STATE←2
         EVENT_ALL_ACCESS←2031619
         MUTANT_QUERY_STATE←1
         MUTANT_ALL_ACCESS←2031617
         MUTEX_MODIFY_STATE←1
         MUTEX_ALL_ACCESS←65537
         SEMAPHORE_MODIFY_STATE←2
         SEMAPHORE_ALL_ACCESS←2031619
         TIMER_QUERY_STATE←1 ⍝ Timer Specific Access Rights
         TIMER_MODIFY_STATE←2
         TIMER_ALL_ACCESS←2031619
                                  ⍝ dwShareMode Values:
         FILE_SHARE_NONE←0   ⍝ Object cannot be shared.
         FILE_SHARE_READ←1   ⍝ Subsequent read access must be requested.
         FILE_SHARE_WRITE←2  ⍝ Subsequent write access must be requested.
         FILE_SHARE_DELETE←4 ⍝ NT only: Delete access must be requested.
                                  ⍝ dwCreationDistribution Values:
         CREATE_NEW←1        ⍝ Creates a new file, fails if exists.
         CREATE_ALWAYS←2     ⍝ Creates a new file, overwrites if exists.
         OPEN_EXISTING←3     ⍝ Opens the file, fails if not exist.
         OPEN_ALWAYS←4       ⍝ Opens the file, if not exist creates new.
         TRUNCATE_EXISTING←5 ⍝ Opens&truncates the file, fails if not exist.
                                                      ⍝ dwFlagsAndAttributes Values:
         FILE_ATTRIBUTE_READONLY←1               ⍝ File is Úead only, no write or delete
         FILE_ATTRIBUTE_HIDDEN←2                 ⍝ File is Ìidden in directory listing
         FILE_ATTRIBUTE_SYSTEM←4                 ⍝ File is used by the operating Ûystem
         FILE_ATTRIBUTE_DIRECTORY←16             ⍝ Çirectory
         FILE_ATTRIBUTE_ARCHIVE←32               ⍝ File should be Árchived for backup
         FILE_ATTRIBUTE_DEVICE←64                ⍝ Deãice
         FILE_ATTRIBUTE_NORMAL←128               ⍝ File has Óo other attributes set
         FILE_ATTRIBUTE_TEMPORARY←256            ⍝ System aÝtempts to keep all data in memory
         FILE_ATTRIBUTE_SPARSE_FILE←512          ⍝ File is a sÕarse(=gering) file
         FILE_ATTRIBUTE_REPARSE_POINT←1024       ⍝ File has an assocÍated reparse point
         FILE_ATTRIBUTE_COMPRESSED←2048          ⍝ File or directory is Ãompressed.
         FILE_ATTRIBUTE_OFFLINE←4096             ⍝ The data is nÔt immediately available.
         FILE_ATTRIBUTE_NOT_CONTENT_INDEXED←8192 ⍝ File will not be indeðed by content indexing service
         FILE_ATTRIBUTE_ENCRYPTED←16384          ⍝ File or directory is Èncrypted
         FILE_FLAG_POSIX_SEMANTICS←16777216      ⍝ Allow multiple files differing only in case.
         FILE_FLAG_BACKUP_SEMANTICS←33554432     ⍝ NT only: Overrides file security checks.
         FILE_FLAG_DELETE_ON_CLOSE←67108864      ⍝ Delete immediately after all handles closed.
         FILE_FLAG_SEQUENTIAL_SCAN←134217728     ⍝ Optimized caching if accessed sequentially.
         FILE_FLAG_RANDOM_ACCESS←268435456       ⍝ Optimized caching if accessed randomly.
         FILE_FLAG_NO_BUFFERING←536870912        ⍝ Open the file with no buffering or caching.
         FILE_FLAG_OVERLAPPED←1073741824         ⍝ Must perform overlapped read and write.
         FILE_FLAG_WRITE_THROUGH←¯2147483648     ⍝ Write direct to disk, no lazily flush.
         FILE_NOTIFY_CHANGE_FILE_NAME←1
         FILE_NOTIFY_CHANGE_DIR_NAME←2
         FILE_NOTIFY_CHANGE_ATTRIBUTES←4
         FILE_NOTIFY_CHANGE_SIZE←8
         FILE_NOTIFY_CHANGE_LAST_WRITE←16
         FILE_NOTIFY_CHANGE_LAST_ACCESS←32
         FILE_NOTIFY_CHANGE_CREATION←64
         FILE_NOTIFY_CHANGE_SECURITY←256
         FILE_ACTION_ADDED←1
         FILE_ACTION_REMOVED←2
         FILE_ACTION_MODIFIED←3
         FILE_ACTION_RENAMED_OLD_NAME←4
         FILE_ACTION_RENAMED_NEW_NAME←5
         MAILSLOT_NO_MESSAGE←¯1
         MAILSLOT_WAIT_FOREVER←¯1
         FILE_CASE_SENSITIVE_SEARCH←1
         FILE_CASE_PRESERVED_NAMES←2
         FILE_UNICODE_ON_DISK←4
         FILE_PERSISTENT_ACLS←8
         FILE_FILE_COMPRESSION←16
         FILE_VOLUME_IS_COMPRESSED←32768
         FS_CASE_IS_PRESERVED←FILE_CASE_PRESERVED_NAMES
         FS_CASE_SENSITIVE←FILE_CASE_SENSITIVE_SEARCH
         FS_UNICODE_STORED_ON_DISK←FILE_UNICODE_ON_DISK
         FS_PERSISTENT_ACLS←FILE_PERSISTENT_ACLS
         FS_VOL_IS_COMPRESSED←FILE_VOLUME_IS_COMPRESSED
         FS_FILE_COMPRESSION←FILE_FILE_COMPRESSION
     
         FILE_DEVICE_BEEP←1               ⍝ DeviceType Parameter Values
         FILE_DEVICE_CD_ROM←2
         FILE_DEVICE_CD_ROM_FILE_SYSTEM←3
         FILE_DEVICE_CONTROLLER←4
         FILE_DEVICE_DATALINK←5
         FILE_DEVICE_DFS←6
         FILE_DEVICE_DISK←7
         FILE_DEVICE_DISK_FILE_SYSTEM←8
         FILE_DEVICE_FILE_SYSTEM←9
         FILE_DEVICE_INPORT_PORT←10
         FILE_DEVICE_KEYBOARD←11
         FILE_DEVICE_MAILSLOT←12
         FILE_DEVICE_MIDI_IN←13
         FILE_DEVICE_MIDI_OUT←14
         FILE_DEVICE_MOUSE←15
         FILE_DEVICE_MULTI_UNC_PROVIDER←16
         FILE_DEVICE_NAMED_PIPE←17
         FILE_DEVICE_NETWORK←18
         FILE_DEVICE_NETWORK_BROWSER←19
         FILE_DEVICE_NETWORK_FILE_SYSTEM←20
         FILE_DEVICE_NULL←21
         FILE_DEVICE_PARALLEL_PORT←22
         FILE_DEVICE_PHYSICAL_NETCARD←23
         FILE_DEVICE_PRINTER←24
         FILE_DEVICE_SCANNER←25
         FILE_DEVICE_SERIAL_MOUSE_PORT←26
         FILE_DEVICE_SERIAL_PORT←27
         FILE_DEVICE_SCREEN←28
         FILE_DEVICE_SOUND←29
         FILE_DEVICE_STREAMS←30
         FILE_DEVICE_TAPE←31
         FILE_DEVICE_TAPE_FILE_SYSTEM←32
         FILE_DEVICE_TRANSPORT←33
         FILE_DEVICE_UNKNOWN←34
         FILE_DEVICE_VIDEO←35
         FILE_DEVICE_VIRTUAL_DISK←36
         FILE_DEVICE_WAVE_IN←37
         FILE_DEVICE_WAVE_OUT←38
         FILE_DEVICE_8042_PORT←39
         FILE_DEVICE_NETWORK_REDIRECTOR←40
         FILE_DEVICE_BATTERY←41
         FILE_DEVICE_BUS_EXTENDER←42
         FILE_DEVICE_MODEM←43
         FILE_DEVICE_VDM←44
         FILE_DEVICE_MASS_STORAGE←45
     
         IOCTL_DISK_BASE←FILE_DEVICE_DISK
         IOCTL_STORAGE_BASE←FILE_DEVICE_MASS_STORAGE
     
         METHOD_BUFFERED←0   ⍝ Method Parameter Values
         METHOD_IN_DIRECT←1
         METHOD_OUT_DIRECT←2
         METHOD_NEITHER←3
     
         FILE_ANY_ACCESS←0   ⍝ Access Parameter Values
         FILE_READ_ACCESS←1  ⍝ file & pipe
         FILE_WRITE_ACCESS←2 ⍝ file & pipe
                                                     ⍝ CTL_CODE←{DeviceType Function Method Access←⍵ ⋄ {⌊⍵-4294967296×2147483648≤⍵}0 4 4096 4⊥DeviceType Access Function Method}
         IOCTL_DISK_GET_DRIVE_GEOMETRY←458752   ⍝ CTL_CODE IOCTL_DISK_BASE  0 METHOD_BUFFERED FILE_ANY_ACCESS
         IOCTL_DISK_GET_PARTITION_INFO←475140   ⍝ CTL_CODE IOCTL_DISK_BASE  1 METHOD_BUFFERED FILE_READ_ACCESS
         IOCTL_DISK_SET_PARTITION_INFO←507912   ⍝ CTL_CODE IOCTL_DISK_BASE  2 METHOD_BUFFERED(FILE_READ_ACCESS+FILE_WRITE_ACCESS)
         IOCTL_DISK_GET_DRIVE_LAYOUT←475148     ⍝ CTL_CODE IOCTL_DISK_BASE  3 METHOD_BUFFERED FILE_READ_ACCESS
         IOCTL_DISK_SET_DRIVE_LAYOUT←507920     ⍝ CTL_CODE IOCTL_DISK_BASE  4 METHOD_BUFFERED(FILE_READ_ACCESS+FILE_WRITE_ACCESS)
         IOCTL_DISK_VERIFY←458772               ⍝ CTL_CODE IOCTL_DISK_BASE  5 METHOD_BUFFERED FILE_ANY_ACCESS
         IOCTL_DISK_FORMAT_TRACKS←507928        ⍝ CTL_CODE IOCTL_DISK_BASE  6 METHOD_BUFFERED(FILE_READ_ACCESS+FILE_WRITE_ACCESS)
         IOCTL_DISK_REASSIGN_BLOCKS←507932      ⍝ CTL_CODE IOCTL_DISK_BASE  7 METHOD_BUFFERED(FILE_READ_ACCESS+FILE_WRITE_ACCESS)
         IOCTL_DISK_PERFORMANCE←458784          ⍝ CTL_CODE IOCTL_DISK_BASE  8 METHOD_BUFFERED FILE_ANY_ACCESS
         IOCTL_DISK_IS_WRITABLE←458788          ⍝ CTL_CODE IOCTL_DISK_BASE  9 METHOD_BUFFERED FILE_ANY_ACCESS
         IOCTL_DISK_LOGGING←458792              ⍝ CTL_CODE IOCTL_DISK_BASE 10 METHOD_BUFFERED FILE_ANY_ACCESS
         IOCTL_DISK_FORMAT_TRACKS_EX←507948     ⍝ CTL_CODE IOCTL_DISK_BASE 11 METHOD_BUFFERED(FILE_READ_ACCESS+FILE_WRITE_ACCESS)
         IOCTL_DISK_HISTOGRAM_STRUCTURE←458800  ⍝ CTL_CODE IOCTL_DISK_BASE 12 METHOD_BUFFERED FILE_ANY_ACCESS
         IOCTL_DISK_HISTOGRAM_DATA←458804       ⍝ CTL_CODE IOCTL_DISK_BASE 13 METHOD_BUFFERED FILE_ANY_ACCESS
         IOCTL_DISK_HISTOGRAM_RESET←458808      ⍝ CTL_CODE IOCTL_DISK_BASE 14 METHOD_BUFFERED FILE_ANY_ACCESS
         IOCTL_DISK_REQUEST_STRUCTURE←458812    ⍝ CTL_CODE IOCTL_DISK_BASE 15 METHOD_BUFFERED FILE_ANY_ACCESS
         IOCTL_DISK_REQUEST_DATA←458816         ⍝ CTL_CODE IOCTL_DISK_BASE 16 METHOD_BUFFERED FILE_ANY_ACCESS
         IOCTL_DISK_CONTROLLER_NUMBER←458820    ⍝ CTL_CODE IOCTL_DISK_BASE 17 METHOD_BUFFERED FILE_ANY_ACCESS
         SMART_GET_VERSION←475264               ⍝ CTL_CODE IOCTL_DISK_BASE 32 METHOD_BUFFERED FILE_READ_ACCESS
         SMART_SEND_DRIVE_COMMAND←508036        ⍝ CTL_CODE IOCTL_DISK_BASE 33 METHOD_BUFFERED(FILE_READ_ACCESS+FILE_WRITE_ACCESS)
         SMART_RCV_DRIVE_DATA←508040            ⍝ CTL_CODE IOCTL_DISK_BASE 34 METHOD_BUFFERED(FILE_READ_ACCESS+FILE_WRITE_ACCESS)
         IOCTL_STORAGE_CHECK_VERIFY←2967552     ⍝ CTL_CODE IOCTL_STORAGE_BASE 512 METHOD_BUFFERED FILE_READ_ACCESS
         IOCTL_STORAGE_MEDIA_REMOVAL←2967556    ⍝ CTL_CODE IOCTL_STORAGE_BASE 513 METHOD_BUFFERED FILE_READ_ACCESS
         IOCTL_STORAGE_EJECT_MEDIA←2967560      ⍝ CTL_CODE IOCTL_STORAGE_BASE 514 METHOD_BUFFERED FILE_READ_ACCESS
         IOCTL_STORAGE_LOAD_MEDIA←2967564       ⍝ CTL_CODE IOCTL_STORAGE_BASE 515 METHOD_BUFFERED FILE_READ_ACCESS
         IOCTL_STORAGE_RESERVE←2967568          ⍝ CTL_CODE IOCTL_STORAGE_BASE 516 METHOD_BUFFERED FILE_READ_ACCESS
         IOCTL_STORAGE_RELEASE←2967572          ⍝ CTL_CODE IOCTL_STORAGE_BASE 517 METHOD_BUFFERED FILE_READ_ACCESS
         IOCTL_STORAGE_FIND_NEW_DEVICES←2967576 ⍝ CTL_CODE IOCTL_STORAGE_BASE 518 METHOD_BUFFERED FILE_READ_ACCESS
         IOCTL_STORAGE_GET_MEDIA_TYPES←2952192  ⍝ CTL_CODE IOCTL_STORAGE_BASE 768 METHOD_BUFFERED FILE_ANY_ACCESS
         FSCTL_LOCK_VOLUME←589848               ⍝ CTL_CODE FILE_DEVICE_FILE_SYSTEM  6 METHOD_BUFFERED FILE_ANY_ACCESS
         FSCTL_UNLOCK_VOLUME←589852             ⍝ CTL_CODE FILE_DEVICE_FILE_SYSTEM  7 METHOD_BUFFERED FILE_ANY_ACCESS
         FSCTL_DISMOUNT_VOLUME←589856           ⍝ CTL_CODE FILE_DEVICE_FILE_SYSTEM  8 METHOD_BUFFERED FILE_ANY_ACCESS
         FSCTL_MOUNT_DBLS_VOLUME←589876         ⍝ CTL_CODE FILE_DEVICE_FILE_SYSTEM 13 METHOD_BUFFERED FILE_ANY_ACCESS
         FSCTL_GET_COMPRESSION←589884           ⍝ CTL_CODE FILE_DEVICE_FILE_SYSTEM 15 METHOD_BUFFERED FILE_ANY_ACCESS
         FSCTL_SET_COMPRESSION←639040           ⍝ CTL_CODE FILE_DEVICE_FILE_SYSTEM 16 METHOD_BUFFERED(FILE_READ_DATA+FILE_WRITE_DATA)
         FSCTL_READ_COMPRESSION←606279          ⍝ CTL_CODE FILE_DEVICE_FILE_SYSTEM 17 METHOD_NEITHER FILE_READ_DATA
         FSCTL_WRITE_COMPRESSION←622667         ⍝ CTL_CODE FILE_DEVICE_FILE_SYSTEM 18 METHOD_NEITHER FILE_WRITE_DATA
         VWIN32_DIOC_DOS_IOCTL←1     ⍝ Win95: Performs the specified MS-DOS device I/O control function (Interrupt 21h Function 4400h through 4411h).
         VWIN32_DIOC_DOS_INT25←2     ⍝ Win95: Performs the Absolute Disk Read command (Interrupt 25h)
         VWIN32_DIOC_DOS_INT26←3     ⍝ Win95: Performs the Absolute Disk Write command (Interrupt 26h)
         VWIN32_DIOC_DOS_INT13←4     ⍝ Win95: Performs Interrupt 13h commands
         VWIN32_DIOC_DOS_DRIVEINFO←6 ⍝ Win95: Performs Interrupt 21h Function 730X comands. This value is supported in Windows 95 OEM Service Release 2 and later.
         Unknown←0                   ⍝ Format is unknown
         F5_1Pt2_512←1               ⍝ 5.25", 1.2MB,  512 bytes/sector
         F3_1Pt44_512←2              ⍝ 3.5", 1.44MB,  512 bytes/sector
         F3_2Pt88_512←3              ⍝ 3.5", 2.88MB,  512 bytes/sector
         F3_20Pt8_512←4              ⍝ 3.5", 20.8MB,  512 bytes/sector
         F3_720_512←5                ⍝ 3.5",  720KB,  512 bytes/sector
         F5_360_512←6                ⍝ 5.25", 360KB,  512 bytes/sector
         F5_320_512←7                ⍝ 5.25", 320KB,  512 bytes/sector
         F5_320_1024←8               ⍝ 5.25", 320KB, 1024 bytes/sector
         F5_180_512←9                ⍝ 5.25", 180KB,  512 bytes/sector
         F5_160_512←10               ⍝ 5.25", 160KB,  512 bytes/sector
         RemovableMedia←11           ⍝ Removable media other than floppy
         FixedMedia←12               ⍝ Fixed hard disk media
         F3_120M_512←13              ⍝ 3.5",  120MB  Floppy
         ⎕NA'I RPCRT4|UuidCreate >{I1[4] I1[2] I1[2] I1[2] I1[6]}'
         HKEY_CLASSES_ROOT←¯2147483648
         HKEY_CURRENT_USER←¯2147483647
         HKEY_LOCAL_MACHINE←¯2147483646
         HKEY_USERS←¯2147483645
         HKEY_PERFORMANCE_DATA←¯2147483644
         HKEY_CURRENT_CONFIG←¯2147483643
         HKEY_DYN_DATA←¯2147483642
         REG_OPTION_RESERVED←0          ⍝ Parameter is reserved
         REG_OPTION_NON_VOLATILE←0      ⍝ Key is preserved when system is rebooted
         REG_OPTION_VOLATILE←1          ⍝ Key is not preserved when system is rebooted
         REG_OPTION_CREATE_LINK←2       ⍝ Created key is a symbolic link
         REG_OPTION_BACKUP_RESTORE←4    ⍝ Open for backup or restore special access rules privilege required
         REG_OPTION_OPEN_LINK←8         ⍝ Open symbolic link
         REG_LEGAL_OPTION←15            ⍝ REG_OPTION_RESERVED∨REG_OPTION_NON_VOLATILE∨REG_OPTION_VOLATILE∨REG_OPTION_CREATE_LINK∨REG_OPTION_BACKUP_RESTORE∨REG_OPTION_OPEN_LINK
         REG_CREATED_NEW_KEY←1          ⍝ New Registry Key created
         REG_OPENED_EXISTING_KEY←2      ⍝ Existing Key opened
         REG_WHOLE_HIVE_VOLATILE←1      ⍝ Restore whole hive volatile
         REG_REFRESH_HIVE←2             ⍝ Unwind changes to last flush
         REG_NO_LAZY_FLUSH←4            ⍝ Never lazy flush this hive
         REG_NOTIFY_CHANGE_NAME←1       ⍝ Create or delete (child)
         REG_NOTIFY_CHANGE_ATTRIBUTES←2
         REG_NOTIFY_CHANGE_LAST_SET←4   ⍝ time stamp
         REG_NOTIFY_CHANGE_SECURITY←8
         REG_LEGAL_CHANGE_FILTER←15
         REG_NONE←0                     ⍝ No value type
         REG_SZ←1                       ⍝ ANSI/Unicode nul terminated string
         REG_EXPAND_SZ←2                ⍝ ANSI/Unicode nul terminated string (with environment variable references)
         REG_BINARY←3                   ⍝ Free form binary
         REG_DWORD←4                    ⍝ 32-bit number
         REG_DWORD_LITTLE_ENDIAN←4      ⍝ 32-bit number (same as REG_DWORD)
         REG_DWORD_BIG_ENDIAN←5         ⍝ 32-bit number
         REG_LINK←6                     ⍝ Symbolic Link (unicode)
         REG_MULTI_SZ←7                 ⍝ Multiple Unicode strings
         REG_RESOURCE_LIST←8            ⍝ Resource list in the resource map
         REG_FULL_RESOURCE_DESCRIPTOR←9 ⍝ Resource list in the hardware description
         REG_RESOURCE_REQUIREMENTS_LIST←10
         OWNER_SECURITY_INFORMATION←1   ⍝ owner identifier of the object is being referenced (SECURITY_INFORMATION)
         GROUP_SECURITY_INFORMATION←2   ⍝ primary group identifier of the object is being referenced
         DACL_SECURITY_INFORMATION←4    ⍝ discretionary ACL of the object is being referenced
         SACL_SECURITY_INFORMATION←8    ⍝ system ACL of the object is being referenced
         'RegCreateKeyEx'⎕NA'I ADVAPI32|RegCreateKeyExA I <0T I <0T I I I >I >I'
         'RegDeleteKey'⎕NA'I ADVAPI32|RegDeleteKeyA I <0T'
         'RegOpenKeyEx'⎕NA'I ADVAPI32|RegOpenKeyExA I <0T I I >I'
         ⎕NA'I ADVAPI32|RegCloseKey I'
         'RegQueryInfoKey'⎕NA'I ADVAPI32|RegQueryInfoKeyA I >T[] =I I >I >I >I >I >I >I >I >{U U}'
         'RegQueryInfoKeyK'⎕NA'I ADVAPI32|RegQueryInfoKeyA I I I I >I >I >I >I I I I I'
         'RegQueryInfoKeyS'⎕NA'I ADVAPI32|RegQueryInfoKeyA I I I I >I >I I I I I I I'
         'RegQueryInfoKeyV'⎕NA'I ADVAPI32|RegQueryInfoKeyA I I I I I I I >I >I >I I I'
         'RegQueryInfoKeyC'⎕NA'I ADVAPI32|RegQueryInfoKeyA I I I I >I I I >I I I I I'
         'RegEnumKeyEx'⎕NA'I ADVAPI32|RegEnumKeyExA I I >T[] =I I >T[] =I >{U U}'
         'RegEnumKeyExS'⎕NA'I ADVAPI32|RegEnumKeyExA I I >T[] =I I I I I'
         'RegQueryValueExT'⎕NA'I ADVAPI32|RegQueryValueExA I <0T I >I >T[] =I'
         'RegQueryType'⎕NA'I ADVAPI32|RegQueryValueExA I <0T I >I I I'
         'RegSetValueExI1'⎕NA'I ADVAPI32|RegSetValueExA I <0T I I <I1[] I'
         'RegDeleteValue'⎕NA'I ADVAPI32|RegDeleteValueA I <0T'
         'RegEnumValue'⎕NA'I ADVAPI32|RegEnumValueA I I >T[] =I I >I >T[] =I'
         :Trap 0 ⍝ WinNT only
             ⎕NA'I ADVAPI32|RegGetKeySecurity I I >T[] =I'
             ⎕NA'I ADVAPI32|RegSetKeySecurity I I <I1[]'
         :Else
             RegGetKeySecurity←{ERROR_CALL_NOT_IMPLEMENTED'' 0}
             RegSetKeySecurity←{ERROR_CALL_NOT_IMPLEMENTED}
         :EndTrap
         EVENTLOG_SUCCESS←0            ⍝ The types of events that can be logged
         EVENTLOG_ERROR_TYPE←1
         EVENTLOG_WARNING_TYPE←2
         EVENTLOG_INFORMATION_TYPE←4
         EVENTLOG_AUDIT_SUCCESS←8
         EVENTLOG_AUDIT_FAILURE←16
         EVENTLOG_SEQUENTIAL_READ←1    ⍝ READ flags for Eventlogging
         EVENTLOG_SEEK_READ←2
         EVENTLOG_FORWARDS_READ←4
         EVENTLOG_BACKWARDS_READ←8
         EVENTLOG_START_PAIRED_EVENT←1 ⍝ WRITE flags used by Auditing for paired events
         EVENTLOG_END_PAIRED_EVENT←2
         EVENTLOG_END_ALL_PAIRED_EVENTS←4
         EVENTLOG_PAIRED_EVENT_ACTIVE←8
         EVENTLOG_PAIRED_EVENT_INACTIVE←16
         :Trap 0 ⍝ WinNT only
             'RegisterEventSource'⎕NA'I ADVAPI32|RegisterEventSourceA <0T <0T'
             'RegisterEventSourceI'⎕NA'I ADVAPI32|RegisterEventSourceA I <0T'
             'ReportEvent'⎕NA'I ADVAPI32|ReportEventA I I I I <I1[] I I <I[] <I1[]'
             'ReportEventI'⎕NA'I ADVAPI32|ReportEventA I I I I I I I <I[] <I1[]'
             ⎕NA'I ADVAPI32|DeregisterEventSource I'
             'OpenEventLog'⎕NA'I ADVAPI32|OpenEventLogA <0T <0T'
             'OpenEventLogI'⎕NA'I ADVAPI32|OpenEventLogA I <0T'
             'OpenBackupEventLog'⎕NA'I ADVAPI32|OpenBackupEventLogA <0T <0T'
             'OpenBackupEventLogI'⎕NA'I ADVAPI32|OpenBackupEventLogA I <0T'
             ⎕NA'I ADVAPI32|GetNumberOfEventLogRecords I >I'
             ⎕NA'I ADVAPI32|GetOldestEventLogRecord I >I'
             'ReadEventLog'⎕NA'I ADVAPI32|ReadEventLogA I I I >T[] I >I >I'
             'BackupEventLog'⎕NA'I ADVAPI32|BackupEventLogA I <0T'
             'ClearEventLog'⎕NA'I ADVAPI32|ClearEventLogA I <0T'
             'ClearEventLogI'⎕NA'I ADVAPI32|ClearEventLogA I I'
             ⎕NA'I ADVAPI32|NotifyChangeEventLog I I'
             ⎕NA'I ADVAPI32|CloseEventLog I'
         :Else
             RegisterEventSource←RegisterEventSourceI←ReportEvent←ReportEventI←DeregisterEventSource←OpenEventLog←OpenEventLogI←{0}
             OpenBackupEventLog←OpenBackupEventLogI←BackupEventLog←ClearEventLog←ClearEventLogI←NotifyChangeEventLog←CloseEventLog←{0}
             GetNumberOfEventLogRecords←GetOldestEventLogRecord←{0 0}
             ReadEventLog←{0 '' 0 0}
         :EndTrap
         'GetLogicalDriveStrings'⎕NA'I KERNEL32|GetLogicalDriveStringsA I >T[]'
         DRIVE_UNKNOWN←0
         DRIVE_NO_ROOT_DIR←1
         DRIVE_REMOVABLE←2
         DRIVE_FIXED←3
         DRIVE_REMOTE←4
         DRIVE_CDROM←5
         DRIVE_RAMDISK←6
         'GetDriveType'⎕NA'I KERNEL32|GetDriveTypeA <0T '
         FILE_TYPE_UNKNOWN←0
         FILE_TYPE_DISK←1
         FILE_TYPE_CHAR←2
         FILE_TYPE_PIPE←3
         FILE_TYPE_REMOTE←32768
         ⎕NA'I KERNEL32|GetFileType I'
         'GetCurrentDirectory'⎕NA'I KERNEL32|GetCurrentDirectoryA I >T[]'
         'SetCurrentDirectory'⎕NA'I KERNEL32|SetCurrentDirectoryA <0T'
         'GetFullPathName'⎕NA'I KERNEL32|GetFullPathNameA <0T I >T[] >I'
         'GetFullPathNameI'⎕NA'I KERNEL32|GetFullPathNameA <0T I I >I'
         'SearchPathI'⎕NA'I KERNEL32|SearchPathA I <0T I I >T[] >I'
     
         'CreateSemaphore'⎕NA'I KERNEL32|CreateSemaphoreA <{I I I} I I <0T'
         'CreateSemaphoreI'⎕NA'I KERNEL32|CreateSemaphoreA <{I I I} I I I'
         'OpenSemaphore'⎕NA'I KERNEL32|OpenSemaphoreA I I <0T'
         ⎕NA'I KERNEL32|ReleaseSemaphore I I >I'
         'CreateMutex'⎕NA'I KERNEL32|CreateMutexA <{I I I} I <0T' ⍝ GIF_KEY: CreateMutex SECURITY_ATTRIBUTES 0 'ISAPGIF'
         'CreateMutexI'⎕NA'I KERNEL32|CreateMutexA <{I I I} I I'
         'OpenMutex'⎕NA'I KERNEL32|OpenMutexA I I <0T'
         'ReleaseMutex'⎕NA'I KERNEL32|ReleaseMutex I'
         INVALID_ATOM←0
         'GlobalAddAtom'⎕NA'U2 KERNEL32|GlobalAddAtomA <0T'
         'GlobalFindAtom'⎕NA'U2 KERNEL32|GlobalFindAtomA <0T'
         'GlobalGetAtomName'⎕NA'I KERNEL32|GlobalGetAtomNameA I >T[] I'
         ⎕NA'I KERNEL32|GlobalDeleteAtom I'
         ⎕NA'I KERNEL32|InitAtomTable I'
         'AddAtom'⎕NA'U2 KERNEL32|AddAtomA <0T'
         'FindAtom'⎕NA'I KERNEL32|FindAtomA <0T'
         'GetAtomName'⎕NA'U2 KERNEL32|GetAtomNameA I >T[] I'
         ⎕NA'I KERNEL32|DeleteAtom I'
         :If 0<GetVersion  ⍝ WinNT only
             ⎕NA'I NETAPI32|NetAlertRaiseEx <I1[] <I1[] I <I1[]'
             ⎕NA'I NETAPI32|NetMessageNameEnum <I1[] I >I I >I >I =I'
             'NetMessageNameEnumI'⎕NA'I NETAPI32|NetMessageNameEnum I I >I I >I >I =I'
             'NetMessageBufferSendAA'⎕NA'I NETAPI32|NetMessageBufferSend <I1[] <I1[] <I1[] <I1[] I'
             'NetMessageBufferSendAI'⎕NA'I NETAPI32|NetMessageBufferSend <I1[] <I1[] I <I1[] I'
             'NetMessageBufferSendIA'⎕NA'I NETAPI32|NetMessageBufferSend I <I1[] <I1[] <I1[] I'
             'NetMessageBufferSendII'⎕NA'I NETAPI32|NetMessageBufferSend I <I1[] I <I1[] I'
             ⎕NA'I NETAPI32|NetRemoteTOD <I1[] >I'
             'NetRemoteTODI'⎕NA'I NETAPI32|NetRemoteTOD I >I'
             ⎕NA'I NETAPI32|NetApiBufferSize I >I'
             ⎕NA'I NETAPI32|NetApiBufferFree I'
             LOGON32_LOGON_INTERACTIVE←2       ⍝ LogonTypes:
             LOGON32_LOGON_NETWORK←3
             LOGON32_LOGON_BATCH←4
             LOGON32_LOGON_SERVICE←5
             LOGON32_LOGON_UNLOCK←7
             LOGON32_LOGON_NETWORK_CLEARTEXT←8 ⍝ Win2000 only
             LOGON32_LOGON_NEW_CREDENTIALS←9   ⍝ Win2000 only
             LOGON32_PROVIDER_DEFAULT←0        ⍝ LogonProviders:
             LOGON32_PROVIDER_WINNT35←1
             LOGON32_PROVIDER_WINNT40←2
             LOGON32_PROVIDER_WINNT50←3        ⍝ Win2000 only
             'LogonUser'⎕NA'I ADVAPI32|LogonUserA <0T <0T <0T I I >I'
             ⎕NA'I ADVAPI32|ImpersonateLoggedOnUser I'
             ⎕NA'I ADVAPI32|RevertToSelf'
             ⎕NA'I ADVAPI32|OpenProcessToken I I >I'
             ⎕NA'I ADVAPI32|OpenThreadToken I I I >I'
             ⎕NA'I ADVAPI32|GetTokenInformation I I >T[] I >I'
             TOKEN_ASSIGN_PRIMARY←1
             TOKEN_DUPLICATE←2
             TOKEN_IMPERSONATE←4
             TOKEN_QUERY←8
             TOKEN_QUERY_SOURCE←16
             TOKEN_ADJUST_PRIVILEGES←32
             TOKEN_ADJUST_GROUPS←64
             TOKEN_ADJUST_DEFAULT←128
             TOKEN_ALL_ACCESS←983295
             TOKEN_READ←131080
             TOKEN_WRITE←131296
             TOKEN_EXECUTE←131072
             TokenUser TokenGroups TokenPrivileges TokenOwner TokenPrimaryGroup TokenDefaultDacl TokenSource TokenType TokenImpersonationLevel TokenStatistics←⍳10
             'LookupAccountName'⎕NA'I ADVAPI32|LookupAccountNameA <0T <0T >T[] =I >T[] =I >I[1]'
             'LookupAccountNameI'⎕NA'I ADVAPI32|LookupAccountNameA I <0T >T[] =I >T[] =I >I[1]'
             'LookupPrivilegeName'⎕NA'I ADVAPI32|LookupPrivilegeNameA <0T <{I I} >0T =I'
             'LookupPrivilegeDisplayName'⎕NA'I ADVAPI32|LookupPrivilegeDisplayNameA <0T <0T >0T =I >I'
             'LookupPrivilegeValue'⎕NA'I ADVAPI32|LookupPrivilegeValueA <0T <0T >{I I}'
             ⎕NA'I ADVAPI32|AdjustTokenPrivileges I I <I[] I >I[] =I'
             SE_CREATE_TOKEN_NAME←'SeCreateTokenPrivilege'                 ⍝  2 0 Erstellen eines Tokenobjekts
             SE_ASSIGNPRIMARYTOKEN_NAME←'SeAssignPrimaryTokenPrivilege'    ⍝  3 0 Ersetzen eines Tokens auf Prozeßebene
             SE_LOCK_MEMORY_NAME←'SeLockMemoryPrivilege'                   ⍝  4 0 Seiten im Speicher sperren
             SE_INCREASE_QUOTA_NAME←'SeIncreaseQuotaPrivilege'             ⍝  5 0 Anheben einer Quote
             SE_MACHINE_ACCOUNT_NAME←'SeMachineAccountPrivilege'           ⍝  6 0 Hinzufügen von Arbeitsstationen zur Domäne
             SE_TCB_NAME←'SeTcbPrivilege'                                  ⍝  7 0 Als Teil des Betriebssystems handeln
             SE_SECURITY_NAME←'SeSecurityPrivilege'                        ⍝  8 0 Verwalten von Überwachungs- und Sicherheitsprotokoll
             SE_TAKE_OWNERSHIP_NAME←'SeTakeOwnershipPrivilege'             ⍝  9 0 Übernehmen des Besitzes an Dateien und Objekten
             SE_LOAD_DRIVER_NAME←'SeLoadDriverPrivilege'                   ⍝ 10 0 Laden und Entfernen von Gerätetreibern
             SE_SYSTEM_PROFILE_NAME←'SeSystemProfilePrivilege'             ⍝ 11 0 Erstellen eines Profils der Systemleistung
             SE_SYSTEMTIME_NAME←'SeSystemtimePrivilege'                    ⍝ 12 0 Ändern der Systemzeit
             SE_PROF_SINGLE_PROCESS_NAME←'SeProfileSingleProcessPrivilege' ⍝ 13 0 Erstellen eines Profils für einen Einzelprozeß
             SE_INC_BASE_PRIORITY_NAME←'SeIncreaseBasePriorityPrivilege'   ⍝ 14 0 Anheben der Zeitplanungspriorität
             SE_CREATE_PAGEFILE_NAME←'SeCreatePagefilePrivilege'           ⍝ 15 0 Erstellen einer Auslagerungsdatei
             SE_CREATE_PERMANENT_NAME←'SeCreatePermanentPrivilege'         ⍝ 16 0 Erstellen von dauerhaft freigegebenen Objekten
             SE_BACKUP_NAME←'SeBackupPrivilege'                            ⍝ 17 0 Sichern von Dateien und Verzeichnissen
             SE_RESTORE_NAME←'SeRestorePrivilege'                          ⍝ 18 0 Wiederherstellen von Dateien und Verzeichnissen
             SE_SHUTDOWN_NAME←'SeShutdownPrivilege'                        ⍝ 19 0 System herunterfahren
             SE_DEBUG_NAME←'SeDebugPrivilege'                              ⍝ 20 0 Debuggen von Programmen
             SE_AUDIT_NAME←'SeAuditPrivilege'                              ⍝ 21 0 Generieren von Sicherheitsüberwachungen
             SE_SYSTEM_ENVIRONMENT_NAME←'SeSystemEnvironmentPrivilege'     ⍝ 22 0 Firmware-Umgebungsvariablen verändern
             SE_CHANGE_NOTIFY_NAME←'SeChangeNotifyPrivilege'               ⍝ 23 0 Wechselprüfung umgehen (Default: Enabled)
             SE_REMOTE_SHUTDOWN_NAME←'SeRemoteShutdownPrivilege'           ⍝ 24 0 Herunterfahren von einem Fernsystem aus
             SE_UNSOLICITED_INPUT_NAME←'SeUnsolicitedInputPrivilege'       ⍝ ?? ? ?
             SE_PRIVILEGE_DISABLED←0
             SE_PRIVILEGE_ENABLED_BY_DEFAULT←1
             SE_PRIVILEGE_ENABLED←2
             SE_PRIVILEGE_USED_FOR_ACCESS←¯2147483648
             'WNetGetUniversalName'⎕NA'I MPR|WNetGetUniversalNameA <0T I I =I' ⍝ WinNT only
         :EndIf
         RESOURCE_CONNECTED←1          ⍝ Scope: Currently connected resources (the dwUsage member is undefined).
         RESOURCE_GLOBALNET←2          ⍝ Scope: Resources on the network.
         RESOURCE_REMEMBERED←3         ⍝ Scope: Remembered (persistent) connections (dwUsage is undefined).
         RESOURCE_RECENT←4
         RESOURCE_CONTEXT←5
         RESOURCETYPE_ANY←0            ⍝ Type: All resources
         RESOURCETYPE_DISK←1           ⍝ Type: Disk resources
         RESOURCETYPE_PRINT←2          ⍝ Type: Print resources
         RESOURCETYPE_RESERVED←8
         RESOURCETYPE_UNKNOWN←¯1
         RESOURCEDISPLAYTYPE_GENERIC←0 ⍝ DisplayType: The method used to display the object does not matter.
         RESOURCEDISPLAYTYPE_DOMAIN←1  ⍝ DisplayType: The object should be displayed as a domain.
         RESOURCEDISPLAYTYPE_SERVER←2  ⍝ DisplayType: The object should be displayed as a server.
         RESOURCEDISPLAYTYPE_SHARE←3   ⍝ DisplayType: The object should be displayed as a sharepoint.
         RESOURCEDISPLAYTYPE_FILE←4
         RESOURCEDISPLAYTYPE_GROUP←5
         RESOURCEDISPLAYTYPE_NETWORK←6
         RESOURCEDISPLAYTYPE_ROOT←7
         RESOURCEDISPLAYTYPE_SHAREADMIN←8
         RESOURCEDISPLAYTYPE_DIRECTORY←9
         RESOURCEDISPLAYTYPE_TREE←10
         RESOURCEDISPLAYTYPE_NDSCONTAINER←11
         RESOURCEUSAGE_CONNECTABLE←1   ⍝ Usage: This is a connectable resource; the name pointed to by the lpRemoteName member can be passed to the WNetAddConnection function to make a network connection.
         RESOURCEUSAGE_CONTAINER←2     ⍝ Usage: This is a container resource; the name pointed to by the lpRemoteName member can be passed to the WNetOpenEnum function to enumerate the resources in the container.
         RESOURCEUSAGE_NOLOCALDEVICE←4
         RESOURCEUSAGE_SIBLING←8
         RESOURCEUSAGE_ATTACHED←16
         RESOURCEUSAGE_ALL←19
         RESOURCEUSAGE_RESERVED←¯2147483648
         NETPROPERTY_PERSISTENT←1
         CONNECT_UPDATE_PROFILE←1      ⍝ Flags: The network resource connection should be remembered.
         CONNECT_UPDATE_RECENT←2
         CONNECT_TEMPORARY←4
         CONNECT_INTERACTIVE←8
         CONNECT_PROMPT←16
         CONNECT_NEED_DRIVE←32
         CONNECT_REFCOUNT←64
         CONNECT_REDIRECT←128
         CONNECT_LOCALDRIVE←256
         CONNECT_CURRENT_MEDIA←512
         CONNECT_DEFERRED←1024
         CONNECT_RESERVED←¯16777216
         UNIVERSAL_NAME_INFO_LEVEL←1   ⍝ lpUniversalName
         REMOTE_NAME_INFO_LEVEL←2      ⍝ lpUniversalName lpConnectionName lpRemainingPath
         'WNetAddConnection3'⎕NA'I MPR|WNetAddConnection3A I <{I I I I I I I I} <0T <0T I'
         'WNetCancelConnection2'⎕NA'I MPR|WNetCancelConnection2A <0T I I'
         'WNetGetConnection'⎕NA'I MPR|WNetGetConnectionA <0T >0T =I'
         'WNetSetConnection'⎕NA'I MPR|WNetSetConnectionA <0T I <I'
     
         ⎕NA'I KERNEL32|GetStdHandle I'
         ⎕NA'I KERNEL32|SetStdHandle I I'
         STD_INPUT_HANDLE←¯10          ⍝ Standard input handle
         STD_OUTPUT_HANDLE←¯11         ⍝ Standard output handle
         STD_ERROR_HANDLE←¯12          ⍝ Standard error handle
         ⎕NA'I KERNEL32|AllocConsole'
         ⎕NA'I KERNEL32|FreeConsole'
         ⎕NA'I KERNEL32|Sleep& I'
         ⎕NA'I KERNEL32|WaitForSingleObject& I I'
         ⎕NA'I KERNEL32|OpenProcess I I I'
         PROCESS_TERMINATE←1
         PROCESS_CREATE_THREAD←2
         PROCESS_VM_OPERATION←8
         PROCESS_VM_READ←16
         PROCESS_VM_WRITE←32
         PROCESS_DUP_HANDLE←64
         PROCESS_CREATE_PROCESS←128
         PROCESS_SET_QUOTA←256
         PROCESS_SET_INFORMATION←512
         PROCESS_QUERY_INFORMATION←1024
         PROCESS_ALL_ACCESS←2035711
         THREAD_TERMINATE←1
         THREAD_SUSPEND_RESUME←2
         THREAD_GET_CONTEXT←8
         THREAD_SET_CONTEXT←16
         THREAD_SET_INFORMATION←32
         THREAD_QUERY_INFORMATION←64
         THREAD_SET_THREAD_TOKEN←128
         THREAD_IMPERSONATE←256
         THREAD_DIRECT_IMPERSONATION←512
         THREAD_ALL_ACCESS←2032639
         'CreateProcess'⎕NA'I KERNEL32|CreateProcessA I <0T I I I I I <0T <{I I I I I I I I I I I I I2 I2 I I I I} >{I I I I}'
         ⎕NA'I KERNEL32|CreateThread <{I I I} I I I I >I'
         ⎕NA'I KERNEL32|GetCurrentThread'
         ⎕NA'I KERNEL32|GetCurrentProcess'
         ⎕NA'I KERNEL32|GetCurrentProcessId'
         ⎕NA'I KERNEL32|GetCurrentThreadId'
         ⎕NA'I KERNEL32|GetExitCodeProcess I >I'
         ⎕NA'I KERNEL32|GetExitCodeThread I >I'
         ⎕NA'I KERNEL32|ExitProcess I'
         ⎕NA'I KERNEL32|TerminateProcess I I'
         ⎕NA'I KERNEL32|ExitThread I'
         ⎕NA'I KERNEL32|TerminateThread I I'
         ⎕NA'I KERNEL32|GetPriorityClass I'
         ⎕NA'I KERNEL32|SetPriorityClass I I'
         ⎕NA'I KERNEL32|GetThreadPriority I'
         ⎕NA'I KERNEL32|SetThreadPriority I I'
         STARTUPINFO←68 0 0 0 0 0 640 480 80 25 30 0 0 0 0 0 0 0
                                                        ⍝ dwCreationFlag values:
         DEBUG_PROCESS←1                           ⍝ The calling process is treated as a debugger, the new process is a process being debugged
         DEBUG_ONLY_THIS_PROCESS←2                 ⍝ If not set and the calling process is being debugged, the new process becomes another process being debugged by the calling process's debugger.
         CREATE_SUSPENDED←4                        ⍝ The primary thread of the new process is created in a suspended state, and does not run until the ResumeThread function is called.
         DETACHED_PROCESS←8                        ⍝ For console processes, the new process does not have access to the console of the parent process.
         CREATE_NEW_CONSOLE←16                     ⍝ The new process has a new console, instead of inheriting the parent's console. This flag cannot be used with the DETACHED_PROCESS flag.
         NORMAL_PRIORITY_CLASS←32                  ⍝ No special scheduling needs.
         IDLE_PRIORITY_CLASS←64                    ⍝ Threads run only when the system is idle and are preempted by the threads of any process running in a higher priority class.
         HIGH_PRIORITY_CLASS←128                   ⍝ Perform time-critical tasks that must be executed immediately for it to run correctly.
         REALTIME_PRIORITY_CLASS←256               ⍝ Highest possible priority.
         CREATE_NEW_PROCESS_GROUP←512              ⍝ New process is the root process of a new process group.
         CREATE_UNICODE_ENVIRONMENT←1024           ⍝ Environment block pointed to by lpEnvironment uses Unicode characters.
         CREATE_SEPARATE_WOW_VDM←2048              ⍝ 16-bit: new process is run in a private Virtual DOS Machine (VDM).
         CREATE_SHARED_WOW_VDM←4096                ⍝ WinNT: The flag is valid only when launching a 16-bit Windows program.
         CREATE_FORCEDOS←8192                      ⍝
         BELOW_NORMAL_PRIORITY_CLASS←16384         ⍝ Win2K: Between idle and normal
         ABOVE_NORMAL_PRIORITY_CLASS←32768         ⍝ Win2K: Between normal and high
         STACK_SIZE_PARAM_IS_A_RESERVATION←65536   ⍝ Win2K
         CREATE_BREAKAWAY_FROM_JOB←16777216        ⍝ Win2K
         CREATE_PRESERVE_CODE_AUTHZ_LEVEL←33554432 ⍝ Win2K
         CREATE_DEFAULT_ERROR_MODE←67108864        ⍝ Do not inherit the error mode of the calling process.
         CREATE_NO_WINDOW←134217728                ⍝
         PROFILE_USER←268435456                    ⍝
         PROFILE_KERNEL←536870912                  ⍝
         PROFILE_SERVER←1073741824                 ⍝
         STARTF_USESHOWWINDOW←1        ⍝ If this value is not specified, the wShowWindow member is ignored.
         STARTF_USESIZE←2              ⍝ If this value is not specified, the dwXSize and dwYSize members are ignored.
         STARTF_USEPOSITION←4          ⍝ If this value is not specified, the dwX and dwY members are ignored.
         STARTF_USECOUNTCHARS←8        ⍝ If this value is not specified, the dwXCountChars and dwYCountChars members are ignored.
         STARTF_USEFILLATTRIBUTE←16    ⍝ If this value is not specified, the dwFillAttribute member is ignored.
         STARTF_RUNFULLSCREEN←32       ⍝ ignored for non-x86 platforms
         STARTF_FORCEONFEEDBACK←64     ⍝ If this value is specified, the cursor is in feedback mode for two seconds after CreateProcess is called.
         STARTF_FORCEOFFFEEDBACK←128   ⍝ If specified, the feedback cursor is forced off while the process is starting.
         STARTF_USESTDHANDLES←256      ⍝ If this value is specified, uses hStdInput, hStdOutput, and hStdError members of the STARTUPINFO structure.
         STARTF_USEHOTKEY←512
         THREAD_PRIORITY_IDLE←¯15         ⍝ value that gets a thread to idle
         THREAD_PRIORITY_LOWEST←¯2        ⍝ minimum thread base priority boost
         THREAD_PRIORITY_BELOW_NORMAL←¯1
         THREAD_PRIORITY_NORMAL←0
         THREAD_PRIORITY_ABOVE_NORMAL←1
         THREAD_PRIORITY_HIGHEST←2        ⍝ maximum thread base priority boost
         THREAD_PRIORITY_TIME_CRITICAL←15 ⍝ value that gets a thread to LowRealtime-1
         THREAD_PRIORITY_ERROR_RETURN←MAXLONG
         SW_HIDE←0
         SW_SHOWNORMAL←1
         SW_NORMAL←1
         SW_SHOWMINIMIZED←2
         SW_SHOWMAXIMIZED←3
         SW_MAXIMIZE←3
         SW_SHOWNOACTIVATE←4
         SW_SHOW←5
         SW_MINIMIZE←6
         SW_SHOWMINNOACTIVE←7
         SW_SHOWNA←8
         SW_RESTORE←9
         SW_SHOWDEFAULT←10
         SW_MAX←10
         STATUS_WAIT_0←0
         STATUS_ABANDONED_WAIT_0←128
         STATUS_USER_APC←192
         STATUS_TIMEOUT←258
         STATUS_PENDING←259
         STATUS_SEGMENT_NOTIFICATION←1073741829
         STATUS_GUARD_PAGE_VIOLATION←¯2147483647
         STATUS_DATATYPE_MISALIGNMENT←¯2147483646
         STATUS_BREAKPOINT←¯2147483645
         STATUS_SINGLE_STEP←¯2147483644
         STATUS_ACCESS_VIOLATION←¯1073741819
         STATUS_IN_PAGE_ERROR←¯1073741818
         STATUS_INVALID_HANDLE←¯1073741816
         STATUS_NO_MEMORY←¯1073741801
         STATUS_ILLEGAL_INSTRUCTION←¯1073741795
         STATUS_NONCONTINUABLE_EXCEPTION←¯1073741787
         STATUS_INVALID_DISPOSITION←¯1073741786
         STATUS_ARRAY_BOUNDS_EXCEEDED←¯1073741684
         STATUS_FLOAT_DENORMAL_OPERAND←¯1073741683
         STATUS_FLOAT_DIVIDE_BY_ZERO←¯1073741682
         STATUS_FLOAT_INEXACT_RESULT←¯1073741681
         STATUS_FLOAT_INVALID_OPERATION←¯1073741680
         STATUS_FLOAT_OVERFLOW←¯1073741679
         STATUS_FLOAT_STACK_CHECK←¯1073741678
         STATUS_FLOAT_UNDERFLOW←¯1073741677
         STATUS_INTEGER_DIVIDE_BY_ZERO←¯1073741676
         STATUS_INTEGER_OVERFLOW←¯1073741675
         STATUS_PRIVILEGED_INSTRUCTION←¯1073741674
         STATUS_STACK_OVERFLOW←¯1073741571
         STATUS_CONTROL_C_EXIT←¯1073741510
         WAIT_OBJECT_0←STATUS_WAIT_0
         WAIT_ABANDONED←STATUS_ABANDONED_WAIT_0
         WAIT_ABANDONED_0←STATUS_ABANDONED_WAIT_0
         WAIT_IO_COMPLETION←STATUS_USER_APC
         WAIT_TIMEOUT←STATUS_TIMEOUT
         WAIT_FAILED←¯1
         STILL_ACTIVE←STATUS_PENDING
         CONTROL_C_EXIT←STATUS_CONTROL_C_EXIT
         EXCEPTION_ACCESS_VIOLATION←STATUS_ACCESS_VIOLATION
         EXCEPTION_DATATYPE_MISALIGNMENT←STATUS_DATATYPE_MISALIGNMENT
         EXCEPTION_BREAKPOINT←STATUS_BREAKPOINT
         EXCEPTION_SINGLE_STEP←STATUS_SINGLE_STEP
         EXCEPTION_ARRAY_BOUNDS_EXCEEDED←STATUS_ARRAY_BOUNDS_EXCEEDED
         EXCEPTION_FLT_DENORMAL_OPERAND←STATUS_FLOAT_DENORMAL_OPERAND
         EXCEPTION_FLT_DIVIDE_BY_ZERO←STATUS_FLOAT_DIVIDE_BY_ZERO
         EXCEPTION_FLT_INEXACT_RESULT←STATUS_FLOAT_INEXACT_RESULT
         EXCEPTION_FLT_INVALID_OPERATION←STATUS_FLOAT_INVALID_OPERATION
         EXCEPTION_FLT_OVERFLOW←STATUS_FLOAT_OVERFLOW
         EXCEPTION_FLT_STACK_CHECK←STATUS_FLOAT_STACK_CHECK
         EXCEPTION_FLT_UNDERFLOW←STATUS_FLOAT_UNDERFLOW
         EXCEPTION_INT_DIVIDE_BY_ZERO←STATUS_INTEGER_DIVIDE_BY_ZERO
         EXCEPTION_INT_OVERFLOW←STATUS_INTEGER_OVERFLOW
         EXCEPTION_PRIV_INSTRUCTION←STATUS_PRIVILEGED_INSTRUCTION
         EXCEPTION_IN_PAGE_ERROR←STATUS_IN_PAGE_ERROR
         EXCEPTION_ILLEGAL_INSTRUCTION←STATUS_ILLEGAL_INSTRUCTION
         EXCEPTION_NONCONTINUABLE_EXCEPTION←STATUS_NONCONTINUABLE_EXCEPTION
         EXCEPTION_STACK_OVERFLOW←STATUS_STACK_OVERFLOW
         EXCEPTION_INVALID_DISPOSITION←STATUS_INVALID_DISPOSITION
         EXCEPTION_GUARD_PAGE←STATUS_GUARD_PAGE_VIOLATION
         EXCEPTION_INVALID_HANDLE←STATUS_INVALID_HANDLE
     
         GET_ALG_CLASS←57344 ⍝ 0xE000 ALG_ID masks (Algorithm IDs and Flags)
         GET_ALG_TYPE←7680   ⍝ 0x1E00
         GET_ALG_SID←511     ⍝ 0x01FF
         ALG_CLASS_ANY←0              ⍝ Algorithm classes
         ALG_CLASS_SIGNATURE←8192     ⍝ 1: SIGNATURE
         ALG_CLASS_MSG_ENCRYPT←16384  ⍝ 2: MSG ENCRYPT
         ALG_CLASS_DATA_ENCRYPT←24576 ⍝ 3: DATA ENCRYPT
         ALG_CLASS_HASH←32768         ⍝ 4: HASH
         ALG_CLASS_KEY_EXCHANGE←40960 ⍝ 5: KEY EXCHANGE
         ALG_TYPE_ANY←0               ⍝ Algorithm types
         ALG_TYPE_DSS←512             ⍝ 1: DSS
         ALG_TYPE_RSA←1024            ⍝ 2: RSA
         ALG_TYPE_BLOCK←1536          ⍝ 3: Block Cipher
         ALG_TYPE_STREAM←2048         ⍝ 4: Stream Cipher
         ALG_TYPE_DH←2560             ⍝ 5: Diffie-Hellman
         ALG_TYPE_SECURECHANNEL←3072  ⍝ 6: Secure Channel
         ALG_SID_ANY←0                ⍝ Algorithm sub-ids
         ALG_SID_RSA_ANY←0            ⍝ Some RSA sub-ids
         ALG_SID_RSA_PKCS←1
         ALG_SID_RSA_MSATWORK←2
         ALG_SID_RSA_ENTRUST←3
         ALG_SID_RSA_PGP←4
         ALG_SID_DSS_ANY←0            ⍝ 1: Some DSS sub-ids
         ALG_SID_DSS_PKCS←1
         ALG_SID_DSS_DMS←2
         ALG_SID_DES←1                ⍝ DES sub_ids (Block cipher sub ids)
         ALG_SID_3DES←3
         ALG_SID_DESX←4
         ALG_SID_IDEA←5
         ALG_SID_CAST←6
         ALG_SID_SAFERSK64←7
         ALG_SID_SAFERSK128←8
         ALG_SID_3DES_112←9
         ALG_SID_CYLINK_MEK←12
         ALG_SID_RC5←13
         ALG_SID_SKIPJACK←10          ⍝ Fortezza sub-ids
         ALG_SID_TEK←11
         CRYPT_MODE_CBCI←6            ⍝ ANSI CBC Interleaved (KP_MODE)
         CRYPT_MODE_CFBP←7            ⍝ ANSI CFB Pipelined (*)
         CRYPT_MODE_OFBP←8            ⍝ ANSI OFB Pipelined
         CRYPT_MODE_CBCOFM←9          ⍝ ANSI CBC + OF Masking
         CRYPT_MODE_CBCOFMI←10        ⍝ ANSI CBC + OFM Interleaved
         ALG_SID_RC2←2                ⍝ 2: RC2 sub-ids
         ALG_SID_RC4←1                ⍝ Stream cipher sub-ids
         ALG_SID_SEAL←2
         ALG_SID_DH_SANDF←1           ⍝ Diffie-Hellman sub-ids
         ALG_SID_DH_EPHEM←2
         ALG_SID_AGREED_KEY_ANY←3
         ALG_SID_KEA←4
         ALG_SID_MD2←1                ⍝ Hash sub ids
         ALG_SID_MD4←2
         ALG_SID_MD5←3
         ALG_SID_SHA←4
         ALG_SID_SHA1←4
         ALG_SID_MAC←5
         ALG_SID_RIPEMD←6
         ALG_SID_RIPEMD160←7
         ALG_SID_SSL3SHAMD5←8
         ALG_SID_HMAC←9
         ALG_SID_SSL3_MASTER←1        ⍝ secure channel sub ids
         ALG_SID_SCHANNEL_MASTER_HASH←2
         ALG_SID_SCHANNEL_MAC_KEY←3
         ALG_SID_PCT1_MASTER←4
         ALG_SID_SSL2_MASTER←5
         ALG_SID_TLS1_MASTER←6
         ALG_SID_SCHANNEL_ENC_KEY←7
         CALG_MD2←ALG_CLASS_HASH+ALG_TYPE_ANY+ALG_SID_MD2 ⍝ algorithm identifier definitions
         CALG_MD4←ALG_CLASS_HASH+ALG_TYPE_ANY+ALG_SID_MD4
         CALG_MD5←ALG_CLASS_HASH+ALG_TYPE_ANY+ALG_SID_MD5
         CALG_SHA←ALG_CLASS_HASH+ALG_TYPE_ANY+ALG_SID_SHA
         CALG_SHA1←ALG_CLASS_HASH+ALG_TYPE_ANY+ALG_SID_SHA1
         CALG_MAC←ALG_CLASS_HASH+ALG_TYPE_ANY+ALG_SID_MAC
         CALG_RIPEMD←ALG_CLASS_HASH+ALG_TYPE_ANY+ALG_SID_RIPEMD
         CALG_RIPEMD160←ALG_CLASS_HASH+ALG_TYPE_ANY+ALG_SID_RIPEMD160
         CALG_RSA_SIGN←ALG_CLASS_SIGNATURE+ALG_TYPE_RSA+ALG_SID_RSA_ANY
         CALG_DSS_SIGN←ALG_CLASS_SIGNATURE+ALG_TYPE_DSS+ALG_SID_DSS_ANY
         CALG_RSA_KEYX←ALG_CLASS_KEY_EXCHANGE+ALG_TYPE_RSA+ALG_SID_RSA_ANY
         CALG_DES←ALG_CLASS_DATA_ENCRYPT+ALG_TYPE_BLOCK+ALG_SID_DES
         CALG_3DES_112←ALG_CLASS_DATA_ENCRYPT+ALG_TYPE_BLOCK+ALG_SID_3DES_112
         CALG_3DES←ALG_CLASS_DATA_ENCRYPT+ALG_TYPE_BLOCK+ALG_SID_3DES
         CALG_RC2←ALG_CLASS_DATA_ENCRYPT+ALG_TYPE_BLOCK+ALG_SID_RC2
         CALG_RC4←ALG_CLASS_DATA_ENCRYPT+ALG_TYPE_STREAM+ALG_SID_RC4
         CALG_SEAL←ALG_CLASS_DATA_ENCRYPT+ALG_TYPE_STREAM+ALG_SID_SEAL
         CALG_DH_SF←ALG_CLASS_KEY_EXCHANGE+ALG_TYPE_DH+ALG_SID_DH_SANDF
         CALG_DH_EPHEM←ALG_CLASS_KEY_EXCHANGE+ALG_TYPE_DH+ALG_SID_DH_EPHEM
         CALG_AGREEDKEY_ANY←ALG_CLASS_KEY_EXCHANGE+ALG_TYPE_DH+ALG_SID_AGREED_KEY_ANY
         CALG_KEA_KEYX←ALG_CLASS_KEY_EXCHANGE+ALG_TYPE_DH+ALG_SID_KEA
         CALG_HUGHES_MD5←ALG_CLASS_KEY_EXCHANGE+ALG_TYPE_ANY+ALG_SID_MD5
         CALG_SKIPJACK←ALG_CLASS_DATA_ENCRYPT+ALG_TYPE_BLOCK+ALG_SID_SKIPJACK
         CALG_TEK←ALG_CLASS_DATA_ENCRYPT+ALG_TYPE_BLOCK+ALG_SID_TEK
         CALG_CYLINK_MEK←ALG_CLASS_DATA_ENCRYPT+ALG_TYPE_BLOCK+ALG_SID_CYLINK_MEK
         CALG_SSL3_SHAMD5←ALG_CLASS_HASH+ALG_TYPE_ANY+ALG_SID_SSL3SHAMD5
         CALG_SSL3_MASTER←ALG_CLASS_MSG_ENCRYPT+ALG_TYPE_SECURECHANNEL+ALG_SID_SSL3_MASTER
         CALG_SCHANNEL_MASTER_HASH←ALG_CLASS_MSG_ENCRYPT+ALG_TYPE_SECURECHANNEL+ALG_SID_SCHANNEL_MASTER_HASH
         CALG_SCHANNEL_MAC_KEY←ALG_CLASS_MSG_ENCRYPT+ALG_TYPE_SECURECHANNEL+ALG_SID_SCHANNEL_MAC_KEY
         CALG_SCHANNEL_ENC_KEY←ALG_CLASS_MSG_ENCRYPT+ALG_TYPE_SECURECHANNEL+ALG_SID_SCHANNEL_ENC_KEY
         CALG_PCT1_MASTER←ALG_CLASS_MSG_ENCRYPT+ALG_TYPE_SECURECHANNEL+ALG_SID_PCT1_MASTER
         CALG_SSL2_MASTER←ALG_CLASS_MSG_ENCRYPT+ALG_TYPE_SECURECHANNEL+ALG_SID_SSL2_MASTER
         CALG_TLS1_MASTER←ALG_CLASS_MSG_ENCRYPT+ALG_TYPE_SECURECHANNEL+ALG_SID_TLS1_MASTER
         CALG_RC5←ALG_CLASS_DATA_ENCRYPT+ALG_TYPE_BLOCK+ALG_SID_RC5
         CALG_HMAC←ALG_CLASS_HASH+ALG_TYPE_ANY+ALG_SID_HMAC
         CRYPT_VERIFYCONTEXT←¯268435456 ⍝ CryptAcquireContext Flags
         CRYPT_NEWKEYSET←8
         CRYPT_DELETEKEYSET←16
         CRYPT_MACHINE_KEYSET←32
         CRYPT_EXPORTABLE←1     ⍝ Flags for CryptGenKey Flags
         CRYPT_USER_PROTECTED←2
         CRYPT_CREATE_SALT←4
         CRYPT_UPDATE_KEY←8
         CRYPT_NO_SALT←16
         CRYPT_PREGEN←64
         CRYPT_RECIPIENT←16
         CRYPT_INITIATOR←64
         CRYPT_ONLINE←128
         CRYPT_SF←256
         CRYPT_CREATE_IV←512
         CRYPT_KEK←1024
         CRYPT_DATA_KEY←2048
         CRYPT_SERVER←1024      ⍝ CryptDeriveKey Flags
         KEY_LENGTH_MASK←¯65536
         CRYPT_Y_ONLY←1         ⍝ CryptExportKey Flags
         CRYPT_SSL2_FALLBACK←2
         CRYPT_DESTROYKEY←4
         CRYPT_OAEP←64
         CRYPT_SSL2_SLUMMING←2
         CRYPT_LITTLE_ENDIAN←1  ⍝ CryptHashSessionKey  Flags
         CRYPT_MACHINE_DEFAULT←1⍝ CryptGetDefaultProvider and CryptSetProviderEx Flags
         CRYPT_USER_DEFAULT←2
         CRYPT_DELETE_DEFAULT←4
         CRYPT_NOHASHOID←1      ⍝ dwFlags definitions for CryptSignHash and CryptVerifySignature
         CRYPT_TYPE2_FORMAT←2
         CRYPT_X931_FORMAT←4
         SIMPLEBLOB←1           ⍝ exported key blob definitions
         PUBLICKEYBLOB←6
         PRIVATEKEYBLOB←7
         PLAINTEXTKEYBLOB←8
         OPAQUEKEYBLOB←9
         PUBLICKEYBLOBEX←10
         SYMMETRICWRAPKEYBLOB←11
         AT_KEYEXCHANGE←1       ⍝ KeySpec values
         AT_SIGNATURE←2
         CRYPT_USERDATA←1
         KP_IV←1                ⍝ Initialization vector (dwParam)
         KP_SALT←2              ⍝ Salt value
         KP_PADDING←3           ⍝ Padding values
         KP_MODE←4              ⍝ Mode of the cipher
         KP_MODE_BITS←5         ⍝ Number of bits to feedback
         KP_PERMISSIONS←6       ⍝ Key permissions DWORD
         KP_ALGID←7             ⍝ Key algorithm
         KP_BLOCKLEN←8          ⍝ Block size of the cipher
         KP_KEYLEN←9            ⍝ Length of key in bits
         KP_SALT_EX←10          ⍝ Length of salt in bytes
         KP_P←11                ⍝ DSS/Diffie-Hellman P value
         KP_G←12                ⍝ DSS/Diffie-Hellman G value
         KP_Q←13                ⍝ DSS Q value
         KP_X←14                ⍝ Diffie-Hellman X value
         KP_Y←15                ⍝ Y value
         KP_RA←16               ⍝ Fortezza RA value
         KP_RB←17               ⍝ Fortezza RB value
         KP_INFO←18             ⍝ for putting information into an RSA envelope
         KP_EFFECTIVE_KEYLEN←19 ⍝ setting and getting RC2 effective key length
         KP_SCHANNEL_ALG←20     ⍝ for setting the Secure Channel algorithms
         KP_CLIENT_RANDOM←21    ⍝ for setting the Secure Channel client random data
         KP_SERVER_RANDOM←22    ⍝ for setting the Secure Channel server random data
         KP_RP←23
         KP_PRECOMP_MD5←24
         KP_PRECOMP_SHA←25
         KP_CERTIFICATE←26      ⍝ for setting Secure Channel certificate data (PCT1)
         KP_CLEAR_KEY←27        ⍝ for setting Secure Channel clear key data (PCT1)
         KP_PUB_EX_LEN←28
         KP_PUB_EX_VAL←29
         KP_KEYVAL←30
         KP_ADMIN_PIN←31
         KP_KEYEXCHANGE_PIN←32
         KP_SIGNATURE_PIN←33
         KP_PREHASH←34
         KP_OAEP_PARAMS←36      ⍝ for setting OAEP params on RSA keys
         KP_CMS_KEY_INFO←37
         KP_CMS_DH_KEY_INFO←38
         KP_PUB_PARAMS←39       ⍝ for setting public parameters
         KP_VERIFY_PARAMS←40    ⍝ for verifying DSA and DH parameters
         KP_HIGHEST_VERSION←41  ⍝ for TLS protocol version setting
         PKCS5_PADDING←1        ⍝ KP_PADDING: PKCS 5 (sec 6.2) padding method
         RANDOM_PADDING←2
         ZERO_PADDING←3
         CRYPT_MODE_CBC←1       ⍝ KP_MODE: Cipher block chaining
         CRYPT_MODE_ECB←2       ⍝ Electronic code book
         CRYPT_MODE_OFB←3       ⍝ Output feedback mode
         CRYPT_MODE_CFB←4       ⍝ Cipher feedback mode
         CRYPT_MODE_CTS←5       ⍝ Ciphertext stealing mode
         CRYPT_ENCRYPT←1        ⍝ KP_PERMISSIONS: Allow encryption
         CRYPT_DECRYPT←2        ⍝ Allow decryption
         CRYPT_EXPORT←4         ⍝ Allow key to be exported
         CRYPT_READ←8           ⍝ Allow parameters to be read
         CRYPT_WRITE←16         ⍝ Allow parameters to be set
         CRYPT_MAC←32           ⍝ Allow MACs to be used with key
         CRYPT_EXPORT_KEY←64    ⍝ Allow key to be used for exporting keys
         CRYPT_IMPORT_KEY←128   ⍝ Allow key to be used for importing keys
         HP_ALGID←1             ⍝ Hash algorithm
         HP_HASHVAL←2           ⍝ Hash value
         HP_HASHSIZE←4          ⍝ Hash value size
         HP_HMAC_INFO←5         ⍝ information for creating an HMAC
         CRYPT_FAILED←FALSE
         CRYPT_SUCCEED←TRUE
         RCRYPT_SUCCEEDED←CRYPT_SUCCEED
         RCRYPT_FAILED←CRYPT_FAILED
         PP_ENUMALGS←1             ⍝ Get: Information about each algorithm supported
         PP_CLIENT_HWND←1          ⍝ Set: Specifies that a window handle is contained in pbData
         PP_ENUMCONTAINERS←2       ⍝ Get: Name of each key container maintained by CSP
         PP_IMPTYPE←3              ⍝ Get: DWORD how CSP is implemented (CRYPT_IMPL...)
         PP_NAME←4                 ⍝ Get: Name of CSP as NULL terminated CHAR string
         PP_VERSION←5              ⍝ Get: DWORD Version number of CSP
         PP_CONTAINER←6            ⍝ Get: Name of the current key container as NULL terminated char string
         PP_CHANGE_PASSWORD←7
         PP_KEYSET_SEC_DESCR←8     ⍝ Get/Set: Security Descriptor for registry entry of machine key set
         PP_CERTCHAIN←9            ⍝ Get: For retrieving certificates from tokens
         PP_KEY_TYPE_SUBTYPE←10    ⍝ Get:
         PP_CONTEXT_INFO←11        ⍝ Set:
         PP_KEYEXCHANGE_KEYSIZE←12 ⍝ Set:
         PP_SIGNATURE_KEYSIZE←13   ⍝ Set:
         PP_KEYEXCHANGE_ALG←14     ⍝ Set:
         PP_SIGNATURE_ALG←15       ⍝ Set:
         PP_PROVTYPE←16            ⍝ Get: PP_PROVTYPE
         PP_KEYSTORAGE←17          ⍝ Get:
         PP_APPLI_CERT←18          ⍝ Get:
         PP_SYM_KEYSIZE←19         ⍝ Get:
         PP_SESSION_KEYSIZE←20     ⍝ Get:
         PP_UI_PROMPT←21
         PP_ENUMALGS_EX←22         ⍝ Get: Information about each algorithm supported
         PP_DELETEKEY←24           ⍝ Set:
         PP_ENUMMANDROOTS←25
         PP_ENUMELECTROOTS←26
         PP_KEYSET_TYPE←27         ⍝ Result: 0 or 32(=CRYPT_MACHINE_KEYSET)
         PP_ADMIN_PIN←31
         PP_KEYEXCHANGE_PIN←32
         PP_SIGNATURE_PIN←33
         PP_SIG_KEYSIZE_INC←34     ⍝ Get: Length increment of AT_SIGNATURE
         PP_KEYX_KEYSIZE_INC←35    ⍝ Get: Length increment of AT_KEYEXCHANGE
         PP_UNIQUE_CONTAINER←36    ⍝ Get: Name of current key container
         PP_SGC_INFO←37
         PP_USE_HARDWARE_RNG←38    ⍝ Get: HW-RandomNumberGenerator support; Set: Force RNG usage
         PP_KEYSPEC←39             ⍝ GetProvParam: Support for AT_SIGNATURE | AT_KEYEXCHANGE
         PP_ENUMEX_SIGNING_PROT←40
         CRYPT_FIRST←1
         CRYPT_NEXT←2
         CRYPT_SGC_ENUM←4
         CRYPT_IMPL_HARDWARE←1
         CRYPT_IMPL_SOFTWARE←2
         CRYPT_IMPL_MIXED←3
         CRYPT_IMPL_UNKNOWN←4
         CRYPT_IMPL_REMOVABLE←8
         CRYPT_SEC_DESCR←1          ⍝ key storage flags
         CRYPT_PSTORE←2
         CRYPT_UI_PROMPT←4
         CRYPT_FLAG_PCT1←1          ⍝ protocol flags
         CRYPT_FLAG_SSL2←2
         CRYPT_FLAG_SSL3←4
         CRYPT_FLAG_TLS1←8
         PROV_RSA_FULL←1            ⍝ Microsoft Base/Enhanced Cryptographic Provider v1.0
         PROV_RSA_SIG←2             ⍝ RSA Signature Only ...
         PROV_DSS←3                 ⍝ Microsoft Base DSS Cryptographic Provider
         PROV_FORTEZZA←4            ⍝ Fortezza
         PROV_MS_EXCHANGE←5         ⍝ Exchange
         PROV_SSL←6                 ⍝ SSL
         PROV_STT_MER←7             ⍝ STT defined Providers
         PROV_STT_ACQ←8
         PROV_STT_BRND←9
         PROV_STT_ROOT←10
         PROV_STT_ISS←11
         PROV_RSA_SCHANNEL←12       ⍝ Microsoft Base RSA SChannel Cryptographic Provider
         PROV_DSS_DH←13             ⍝ Microsoft Base DSS and Diffie-Hellman Cryptographic Provider
         PROV_EC_ECDSA_SIG←14
         PROV_EC_ECNRA_SIG←15
         PROV_EC_ECDSA_FULL←16
         PROV_EC_ECNRA_FULL←17
         PROV_SPYRUS_LYNKS←20
         PROV_INTEL_SEC←22
         INTEL_DEF_PROV←'Intel Hardware Cryptographic Service Provider'
         MS_DEF_PROV←'Microsoft Base Cryptographic Provider v1.0' ⍝ Provider friendly names
         MS_ENHANCED_PROV←'Microsoft Enhanced Cryptographic Provider v1.0'
         MS_DEF_RSA_SIG_PROV←'Microsoft RSA Signature Cryptographic Provider'
         MS_EXCHANGE_PROV←'Microsoft Exchange Cryptographic Provider v1.0'
         MS_DEF_RSA_SCHANNEL_PROV←'Microsoft Base RSA SChannel Cryptographic Provider'
         MS_ENHANCED_RSA_SCHANNEL_PROV←'Microsoft Enhanced RSA SChannel Cryptographic Provider'
         MS_DEF_DSS_PROV←'Microsoft Base DSS Cryptographic Provider'
         MS_DEF_DSS_DH_PROV←'Microsoft Base DSS and Diffie-Hellman Cryptographic Provider'
         :Trap 0 ⍝ WinNT/OSR2 only
     ⍝            'CryptEnumProviders'⎕NA'I ADVAPI32|CryptEnumProvidersA I I I >I >T[] =I'
             'CryptSetProvider'⎕NA'I ADVAPI32|CryptSetProviderA <0T I'
             'CryptAcquireContext'⎕NA'I ADVAPI32|CryptAcquireContextA >I I I I I'
             'CryptAcquireContextP'⎕NA'I ADVAPI32|CryptAcquireContextA >I I <0T I I'
             'CryptAcquireContextC'⎕NA'I ADVAPI32|CryptAcquireContextA >I <0T I I I'
             'CryptAcquireContextCP'⎕NA'I ADVAPI32|CryptAcquireContextA >I <0T <0T I I'
             ⎕NA'I ADVAPI32|CryptGetProvParam I I >T[] =I I'
             'CryptGetProvParamI'⎕NA'I ADVAPI32|CryptGetProvParam I I I =I I'
             ⎕NA'I ADVAPI32|CryptSetProvParam I I <I1[] I'
             ⎕NA'I ADVAPI32|CryptGenKey I I I >I'
             ⎕NA'I ADVAPI32|CryptDeriveKey I I I I =I'
             ⎕NA'I ADVAPI32|CryptImportKey I <I1[] I I I >I'
             ⎕NA'I ADVAPI32|CryptExportKey I I I I >T[] =I'
             ⎕NA'I ADVAPI32|CryptGetUserKey I I >I'
             ⎕NA'I ADVAPI32|CryptDestroyKey I'
             ⎕NA'I ADVAPI32|CryptGetKeyParam I I >T[] =I I'
             ⎕NA'I ADVAPI32|CryptSetKeyParam I I <I1[] I'
             ⎕NA'I ADVAPI32|CryptGenRandom I I =I1[]'
             ⎕NA'I ADVAPI32|CryptCreateHash I I I I >I'
             ⎕NA'I ADVAPI32|CryptHashSessionKey I I I'
             ⎕NA'I ADVAPI32|CryptHashData I <I1[] I I'
             'CryptHashDataM'⎕NA'I ADVAPI32|CryptHashData I I I I'
             ⎕NA'I ADVAPI32|CryptGetHashParam I I >T[] =I I'
             ⎕NA'I ADVAPI32|CryptSetHashParam I I <I1[] I'
             'CryptSetHashParamI'⎕NA'I ADVAPI32|CryptSetHashParam I I I I'
             'CryptSignHash'⎕NA'I ADVAPI32|CryptSignHashA I I <I1[] I >T[] =I'
             'CryptVerifySignature'⎕NA'I ADVAPI32|CryptVerifySignatureA I <I1[] I I <I1[] I'
             ⎕NA'I ADVAPI32|CryptDestroyHash I'
             ⎕NA'I ADVAPI32|CryptReleaseContext I I'
             ⎕NA'I ADVAPI32|CryptEncrypt I I I I =I1[] =I I'
             'CryptEncryptM'⎕NA'I ADVAPI32|CryptEncrypt I I I I I =I I'
             ⎕NA'I ADVAPI32|CryptDecrypt I I I I =I1[] =I'
             'CryptDecryptM'⎕NA'I ADVAPI32|CryptDecrypt I I I I I =I'
         :Else
             CryptSetProvider←CryptSetProvParam←CryptSetKeyParam←CryptDestroyKey←{0}
             CryptHashSessionKey←CryptHashData←CryptHashDataM←CryptSetHashParam←{0}
             CryptSetHashParamI←CryptVerifySignature←CryptDestroyHash←CryptReleaseContext←{0}
             CryptAcquireContext←CryptAcquireContextP←CryptAcquireContextC←CryptAcquireContextCP←{0 ¯1}
             CryptGenKey←CryptDeriveKey←CryptImportKey←CryptGetUserKey←CryptCreateHash←{0 ¯1}
             CryptGetProvParam←CryptExportKey←CryptGetKeyParam←CryptSignHash←{0 '' 0}
             CryptGetHashParam←{0 ''}
             CryptGetProvParamI←CryptEncryptM←CryptDecryptM←{0 0}
             CryptGenRandom←{0 ⍬}
             CryptEncrypt←CryptDecrypt←{0 ⍬ 0}
         :EndTrap
         X509_ASN_ENCODING←1       ⍝ EncodingTypes for CERT_STORE_PROV_MSG CERT_STORE_PROV_PKCS7 CERT_STORE_PROV_FILENAME
         PKCS_7_ASN_ENCODING←65536
         CERT_STORE_PROV_MSG←1     ⍝ Certificate Store Provider Types
         CERT_STORE_PROV_MEMORY←2
         CERT_STORE_PROV_FILE←3
         CERT_STORE_PROV_REG←4
         CERT_STORE_PROV_PKCS7←5
         CERT_STORE_PROV_SERIALIZED←6
         CERT_STORE_PROV_FILENAME←7
         CERT_STORE_PROV_SYSTEM←9
         CERT_STORE_PROV_COLLECTION←11
         CERT_STORE_PROV_SYSTEM_REGISTRY←12
         CERT_STORE_PROV_PHYSICAL_W←14
         CERT_STORE_PROV_SMART_CARD_W←15
         CERT_STORE_PROV_LDAP_W←16
         sz_CERT_STORE_PROV_MEMORY←'Memory'
         sz_CERT_STORE_PROV_FILENAME←'File'
         sz_CERT_STORE_PROV_SYSTEM←'System'
         sz_CERT_STORE_PROV_PKCS7←'PKCS7'
         sz_CERT_STORE_PROV_SERIALIZED←'Serialized'
         sz_CERT_STORE_PROV_COLLECTION←'Collection'
         sz_CERT_STORE_PROV_SYSTEM_REGISTRY←'SystemRegistry'
         sz_CERT_STORE_PROV_PHYSICAL←'Physical'
         sz_CERT_STORE_PROV_SMART_CARD←'SmartCard'
         sz_CERT_STORE_PROV_LDAP←'Ldap'
         CERT_STORE_SIGNATURE_FLAG←1        ⍝ Certificate Store verify/results flags
         CERT_STORE_TIME_VALIDITY_FLAG←2
         CERT_STORE_REVOCATION_FLAG←4
         CERT_STORE_NO_CRL_FLAG←65536
         CERT_STORE_NO_ISSUER_FLAG←131072
         CERT_STORE_NO_CRYPT_RELEASE_FLAG←1 ⍝ Certificate Store open/property flags
         CERT_STORE_SET_LOCALIZED_NAME_FLAG←2
         CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG←4
         CERT_STORE_DELETE_FLAG←16
         CERT_STORE_MANIFOLD_FLAG←256
         CERT_STORE_ENUM_ARCHIVED_FLAG←512
         CERT_STORE_UPDATE_KEYID_FLAG←1024
         CERT_STORE_READONLY_FLAG←32768
         CERT_STORE_OPEN_EXISTING_FLAG←16384
         CERT_STORE_CREATE_NEW_FLAG←8192
         CERT_STORE_MAXIMUM_ALLOWED_FLAG←4096
         CERT_SYSTEM_STORE_UNPROTECTED_FLAG←1073741824 ⍝ Certificate System Store Flag Values
         CERT_SYSTEM_STORE_CURRENT_USER←65536                ⍝ HKEY_CURRENT_USER
         CERT_SYSTEM_STORE_LOCAL_MACHINE←131072              ⍝ HKEY_LOCAL_MACHINE
         CERT_SYSTEM_STORE_CURRENT_SERVICE←262144            ⍝ HKEY_LOCAL_MACHINE\Software\Microsoft\Cryptography\Services
         CERT_SYSTEM_STORE_SERVICES←327680
         CERT_SYSTEM_STORE_USERS←393216                      ⍝ HKEY_USERS
         CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY←458752  ⍝ HKEY_CURRENT_USER\Software\Policies\Microsoft\SystemCertificates
         CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY←524288 ⍝ HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\SystemCertificates
         CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE←589824   ⍝ HKEY_LOCAL_MACHINE\Software\Microsoft\EnterpriseCertificates
         CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH←'Software\Policies\Microsoft\SystemCertificates'    ⍝ Group Policy Store Defines
         CERT_EFSBLOB_REGPATH←CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH,'\EFS'                         ⍝ EFS Defines
         CERT_EFSBLOB_VALUE_NAME←'EFSBlob'
         CERT_PROT_ROOT_FLAGS_REGPATH←CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH,'\Root\ProtectedRoots' ⍝ Protected Root Defines
         CERT_PROT_ROOT_FLAGS_VALUE_NAME←'Flags'
         CERT_STORE_ADD_NEW←1
         CERT_STORE_ADD_USE_EXISTING←2
         CERT_STORE_ADD_REPLACE_EXISTING←3
         CERT_STORE_ADD_ALWAYS←4
         CERT_STORE_SAVE_AS_STORE←1
         CERT_STORE_SAVE_AS_PKCS7←2
         CERT_STORE_SAVE_TO_FILE←1
         CERT_STORE_SAVE_TO_MEMORY←2
         CERT_STORE_SAVE_TO_FILENAME_A←3
         CERT_V1←0
         CERT_V2←1
         CERT_V3←2
         CERT_INFO_VERSION_FLAG←1
         CERT_INFO_SERIAL_NUMBER_FLAG←2
         CERT_INFO_SIGNATURE_ALGORITHM_FLAG←3
         CERT_INFO_ISSUER_FLAG←4
         CERT_INFO_NOT_BEFORE_FLAG←5
         CERT_INFO_NOT_AFTER_FLAG←6
         CERT_INFO_SUBJECT_FLAG←7
         CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG←8
         CERT_INFO_ISSUER_UNIQUE_ID_FLAG←9
         CERT_INFO_SUBJECT_UNIQUE_ID_FLAG←10
         CERT_INFO_EXTENSION_FLAG←11
         CERT_COMPARE_ANY←0
         CERT_COMPARE_SHA1_HASH←1
         CERT_COMPARE_NAME←2
         CERT_COMPARE_ATTR←3
         CERT_COMPARE_MD5_HASH←4
         CERT_COMPARE_PROPERTY←5
         CERT_COMPARE_PUBLIC_KEY←6
         CERT_COMPARE_NAME_STR_A←7
         CERT_COMPARE_KEY_SPEC←9
         CERT_COMPARE_ENHKEY_USAGE←10
         CERT_COMPARE_SUBJECT_CERT←11
         CERT_COMPARE_ISSUER_OF←12
         CERT_COMPARE_EXISTING←13
         CERT_COMPARE_SIGNATURE_HASH←14
         CERT_COMPARE_KEY_IDENTIFIER←15
         CERT_COMPARE_CERT_ID←16
         CERT_FIND_ANY←0
         CERT_FIND_SHA1_HASH←65536
         CERT_FIND_MD5_HASH←262144
         CERT_FIND_SIGNATURE_HASH←917504
         CERT_FIND_KEY_IDENTIFIER←983040
         CERT_FIND_PROPERTY←327680
         CERT_FIND_PUBLIC_KEY←393216
         CERT_FIND_SUBJECT_NAME←131079
         CERT_FIND_SUBJECT_ATTR←196615
         CERT_FIND_ISSUER_NAME←131076
         CERT_FIND_ISSUER_ATTR←196612
         CERT_FIND_SUBJECT_STR_A←458759
         CERT_FIND_ISSUER_STR_A←458756
         CERT_FIND_KEY_SPEC←589824
         CERT_FIND_ENHKEY_USAGE←655360
         CERT_FIND_SUBJECT_CERT←720896
         CERT_FIND_ISSUER_OF←786432
         CERT_FIND_EXISTING←851968
         CERT_FIND_CERT_ID←1048576
         CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG←1
         CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG←2
         CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG←4
         CERT_FIND_NO_ENHKEY_USAGE_FLAG←8
         CERT_FIND_OR_ENHKEY_USAGE_FLAG←16
         CERT_FIND_VALID_ENHKEY_USAGE_FLAG←32
         CERT_KEY_PROV_HANDLE_PROP_ID←1
         CERT_KEY_PROV_INFO_PROP_ID←2
         CERT_SHA1_HASH_PROP_ID←3
         CERT_MD5_HASH_PROP_ID←4
         CERT_KEY_CONTEXT_PROP_ID←5
         CERT_KEY_SPEC_PROP_ID←6
         CERT_IE30_RESERVED_PROP_ID←7
         CERT_PUBKEY_HASH_RESERVED_PROP_ID←8
         CERT_ENHKEY_USAGE_PROP_ID←9
         CERT_NEXT_UPDATE_LOCATION_PROP_ID←10
         CERT_FRIENDLY_NAME_PROP_ID←11
         CERT_PVK_FILE_PROP_ID←12
         CERT_DESCRIPTION_PROP_ID←13
         CERT_ACCESS_STATE_PROP_ID←14
         CERT_SIGNATURE_HASH_PROP_ID←15
         CERT_SMART_CARD_DATA_PROP_ID←16
         CERT_EFS_PROP_ID←17
         CERT_FORTEZZA_DATA_PROP_ID←18
         CERT_ARCHIVED_PROP_ID←19
         CERT_KEY_IDENTIFIER_PROP_ID←20
         CERT_AUTO_ENROLL_PROP_ID←21
         CERT_PUBKEY_ALG_PARA_PROP_ID←22
         CERT_CROSS_CERT_DIST_POINTS_PROP_ID←23
         CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID←24
         CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID←25
         CERT_ENROLLMENT_PROP_ID←26
         CERT_DATE_STAMP_PROP_ID←27
         CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID←28
         CERT_SUBJECT_NAME_MD5_HASH_PROP_ID←29
         CERT_EXTENDED_ERROR_INFO_PROP_ID←30
         CERT_RENEWAL_PROP_ID←64
         CERT_ARCHIVED_KEY_HASH_PROP_ID←65
         CERT_FIRST_USER_PROP_ID←32768
         CERT_LAST_USER_PROP_ID←65535
         CRL_REASON_UNSPECIFIED←0
         CRL_REASON_KEY_COMPROMISE←1
         CRL_REASON_CA_COMPROMISE←2
         CRL_REASON_AFFILIATION_CHANGED←3
         CRL_REASON_SUPERSEDED←4
         CRL_REASON_CESSATION_OF_OPERATION←5
         CRL_REASON_CERTIFICATE_HOLD←6
         CRL_REASON_REMOVE_FROM_CRL←8
         CRL_REASON_PRIVILEGE_WITHDRAWN←9
         CRL_REASON_AA_COMPROMISE←10
         :Trap 0 ⍝ WinNT/OSR2 only
             'CertOpenStoreT'⎕NA'I CRYPT32|CertOpenStore I I I I <0T'
             'CertOpenStoreI'⎕NA'I CRYPT32|CertOpenStore I I I I I'
             'CertOpenSystemStore'⎕NA'I CRYPT32|CertOpenSystemStoreA I <0T'
             ⎕NA'I CRYPT32|CertCloseStore I I'
             ⎕NA'I CRYPT32|CertFindCertificateInStore I I I I I I'
             ⎕NA'I CRYPT32|CertEnumCertificatesInStore I I'
             ⎕NA'I CRYPT32|CertGetIssuerCertificateFromStore I I I =I'
             'CertSaveStoreI'⎕NA'I CRYPT32|CertSaveStore I I I I I I'
             'CertSaveStoreM'⎕NA'I CRYPT32|CertSaveStore I I I I =I[2] I'
             'CertSaveStoreT'⎕NA'I CRYPT32|CertSaveStore I I I I <0T I'
             ⎕NA'I CRYPT32|CertAddEncodedCertificateToStore I I <I1[] I I I'
             ⎕NA'I CRYPT32|CertAddCertificateContextToStore I I I I'
             ⎕NA'I CRYPT32|CertDeleteCertificateFromStore I'
             ⎕NA'I CRYPT32|CertCreateCertificateContext I <I1[] I'
             ⎕NA'I CRYPT32|CertFreeCertificateContext I'
             ⎕NA'I CRYPT32|CertEnumCertificateContextProperties I I'
             ⎕NA'I CRYPT32|CertGetCertificateContextProperty I I I =I'
         :Else
             CertOpenStoreT←CertOpenStoreI←CertOpenSystemStore←CertCloseStore←CertFindCertificateInStore←CertEnumCertificatesInStore←{0}
             CertGetIssuerCertificateFromStore←CertGetCertificateContextProperty←{0 0}
             CertSaveStoreI←CertSaveStoreM←CertSaveStoreT←CertAddEncodedCertificateToStore←CertAddCertificateContextToStore←{0}
             CertDeleteCertificateFromStore←CertCreateCertificateContext←CertFreeCertificateContext←CertEnumCertificateContextProperties←{0}
         :EndTrap
         SCARD_AUTOALLOCATE←¯1
         SCARD_SCOPE_USER←0
         SCARD_SCOPE_TERMINAL←1
         SCARD_SCOPE_SYSTEM←2
         SCARD_SHARE_EXCLUSIVE←1
         SCARD_SHARE_SHARED←2
         SCARD_SHARE_DIRECT←3
         SCARD_LEAVE_CARD←0
         SCARD_RESET_CARD←1
         SCARD_UNPOWER_CARD←2
         SCARD_EJECT_CARD←3
         SCARD_ATR_LENGTH←33
         SCARD_PROTOCOL_OPTIMAL←0
         SCARD_PROTOCOL_UNDEFINED←0
         SCARD_PROTOCOL_T0←1
         SCARD_PROTOCOL_T1←2
         SCARD_PROTOCOL_RAW←65536
         SCARD_PROTOCOL_DEFAULT←¯2147483648
         SCARD_PCI_T0←TxtHex'0100000008000000'
         SCARD_PCI_T1←TxtHex'0200000008000000'
         SCARD_PCI_RAW←TxtHex'0000010008000000'
         SCARD_UNKNOWN←0
         SCARD_ABSENT←1
         SCARD_PRESENT←2
         SCARD_SWALLOWED←3
         SCARD_POWERED←4
         SCARD_NEGOTIABLE←5
         SCARD_SPECIFIC←6
         :Trap 0 ⍝ WinNT4SP3/OSR2 only
             ⎕NA'I WINSCARD|SCardEstablishContext I I I >I'
             'SCardConnect'⎕NA'I WINSCARD|SCardConnectA I <0I1 I I >I >I'
             ⎕NA'I WINSCARD|SCardReconnect I I I I >I'
             ⎕NA'I WINSCARD|SCardBeginTransaction I'
             ⎕NA'I WINSCARD|SCardTransmit I <I1[] <I1[] I =I1[] >T[] =I'
             'SCardTransmitI'⎕NA'I WINSCARD|SCardTransmit I <I1[] <I1[] I I >T[] =I'
             ⎕NA'I WINSCARD|SCardEndTransaction I I'
             'SCardStatus'⎕NA'I WINSCARD|SCardStatusA I >0T =I >I >I >T[] =I'
             ⎕NA'I WINSCARD|SCardDisconnect I I'
             'SCardListCardsI'⎕NA'I WINSCARD|SCardListCardsA I I I I I =I'
             'SCardListCards'⎕NA'I WINSCARD|SCardListCardsA I I I I >T[] =I'
             'SCardListCardsAI'⎕NA'I WINSCARD|SCardListCardsA I <0I1 I I I =I'
             'SCardListCardsA'⎕NA'I WINSCARD|SCardListCardsA I <0I1 I I >T[] =I'
             'SCardListInterfacesI'⎕NA'I WINSCARD|SCardListInterfacesA I <0I1 I =I'
             'SCardListInterfaces'⎕NA'I WINSCARD|SCardListInterfacesA I <0I1 >T[] =I'
             'SCardListReadersI'⎕NA'I WINSCARD|SCardListReadersA I I I =I'
             'SCardListReaders'⎕NA'I WINSCARD|SCardListReadersA I I >T[] =I'
             'SCardListReadersTI'⎕NA'I WINSCARD|SCardListReadersA I <0I1 I =I'
             'SCardListReadersT'⎕NA'I WINSCARD|SCardListReadersA I <0I1 >T[] =I'
             'SCardListReaderGroupsI'⎕NA'I WINSCARD|SCardListReaderGroupsA I I =I'
             'SCardListReaderGroups'⎕NA'I WINSCARD|SCardListReaderGroupsA I >T[] =I'
             'SCardLocateCardsByATR'⎕NA'I WINSCARD|SCardLocateCardsByATRA I <{I I1[36] I1[36]}[] I ={I I I I I I1[36]}[] I'
             ⎕NA'I WINSCARD|SCardReleaseContext I'
         :Else
             SCardEstablishContext←{120 ¯1}
             SCardConnect←{120 ¯1 0}
             SCardBeginTransaction←SCardEndTransaction←SCardDisconnect←SCardReleaseContext←{120}
             SCardTransmit←{120 '' '' 0}
             SCardTransmitI←SCardListCards←SCardListCardsA←SCardListReaders←SCardListReadersT←SCardListReaderGroups←{120 '' 0}
             SCardStatus←{120 '' 0 0 0 '' 0}
             SCardReconnect←SCardListCardsI←SCardListCardsAI←SCardListReadersI←SCardListReadersTI←SCardListReaderGroupsI←{120 0}
         :EndTrap
     :EndIf
 :EndHold
∇

∇ InitCodePages
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 CP_ACP←0            ⍝ Default ANSI code page
 CP_OEMCP←1          ⍝ Default OEM  code page
 CP_MACCP←2          ⍝ Default MAC  code page
 CP_THREAD_ACP←3     ⍝ Current thread's ANSI code page
 CP_SYMBOL←42        ⍝ SYMBOL translations
 CP_ANSI874←874      ⍝ windows-874          Thai (Windows)
 CP_ANSI1250←1250    ⍝ windows-1250         Central European (Windows)
 CP_ANSI1251←1251    ⍝ windows-1251         Cyrillic (Windows)
 CP_ANSI←1252        ⍝ Windows-1252         Western European (ANSI code page)
 CP_ANSI1253←1253    ⍝ windows-1253         Greek (Windows)
 CP_ANSI1254←1254    ⍝ windows-1254         Turkish (Windows)
 CP_ANSI1255←1255    ⍝ windows-1255         Hebrew (Windows)
 CP_ANSI1256←1256    ⍝ windows-1256         Arabic (Windows)
 CP_ANSI1257←1257    ⍝ windows-1257         Baltic (Windows)
 CP_ANSI1258←1258    ⍝ windows-1258         Vietnamese (Windows)
 CP_OEM437←437       ⍝ IBM437               OEM United States
 CP_OEM708←708       ⍝ ASMO-708             Arabic (ASMO 708)
 CP_OEM720←720       ⍝ DOS-720              Arabic (DOS)
 CP_OEM737←737       ⍝ ibm737               Greek (DOS)
 CP_OEM775←775       ⍝ ibm775               Baltic (DOS)
 CP_OEM850←850       ⍝ ibm850               Western European Multilingual Latin I (DOS)
 CP_OEM852←852       ⍝ ibm852               Central European Slavic Latin II (DOS)
 CP_OEM855←855       ⍝ ibm855               Cyrillic (primarily Russian) (DOS)
 CP_OEM860←860       ⍝ ibm860               Portuguese ISO-8859-15 Latin 9 (DOS)
 CP_OEM861←861       ⍝ ibm861               Icelandic (DOS)
 CP_OEM862←862       ⍝ DOS-862              Hebrew (DOS)
 CP_OEM863←863       ⍝ ibm863               Canadian-French (DOS)
 CP_OEM864←864       ⍝ ibm864               Arabic (DOS)
 CP_OEM865←865       ⍝ ibm865               Nordic (DOS)
 CP_OEM866←866       ⍝ cp866                Cyrillic Russian (former USSR) (DOS)
 CP_OEM869←869       ⍝ ibm869               Greek, Modern (DOS)
 CP_ISO6937←20269    ⍝ iso-6937             ISO-6937
 CP_ISO8859_1←28591  ⍝ iso-8859-1           ISO 8859-1 Western European Latin I
 CP_ISO8859_2←28592  ⍝ iso-8859-2           ISO 8859-2 Central European
 CP_ISO8859_3←28593  ⍝ iso-8859-3           ISO 8859-3 Turkish Latin 3
 CP_ISO8859_4←28594  ⍝ iso-8859-4           ISO 8859-4 Baltic Baltic
 CP_ISO8859_5←28595  ⍝ iso-8859-5           ISO 8859-5 Cyrillic
 CP_ISO8859_6←28596  ⍝ iso-8859-6           ISO 8859-6 Arabic
 CP_ISO8859_7←28597  ⍝ iso-8859-7           ISO 8859-7 Greek
 CP_ISO8859_8←28598  ⍝ iso-8859-8           ISO 8859-8 Hebrew
 CP_ISO8859_9←28599  ⍝ iso-8859-9           ISO 8859-9 Turkish Latin 5
 CP_ISO8859_15←28605 ⍝ iso-8859-15          ISO 8859-15 Portuguese Latin 9
 CP_IA5←20105        ⍝ x-IA5                Western European (IA5) (IRV)
 CP_IA5DE←20106      ⍝ x-IA5-German         German (IA5) (DIN 66003)
 CP_IA5SW←20107      ⍝ x-IA5-Swedish        Swedish (IA5) (SEN 850200 B)
 CP_IA5NO←20108      ⍝ x-IA5-Norwegian      Norwegian (IA5) (NS 4551-1)
 CP_USASCII←20127    ⍝ us-ascii             US-ASCII
 CP_T61←20261        ⍝ T61                  T.61 T61STRING
 CP_WINUNICODE←1200  ⍝*unicode              Unicode (UTF-16, BMP of ISO 10646)
 CP_UTF7←65000       ⍝ utf-7                Unicode (UTF-7)
 CP_UTF8←65001       ⍝ utf-8                Unicode (UTF-8)
 CP_MAC←10000        ⍝ macintosh            Western European (Mac)
 CP_LOWERCASE←21027  ⍝                      Ext Alpha Lowercase
 CP_875←875          ⍝ x-EBCDIC-GreekModern Greek Modern (IBM EBCDIC)
 CP_936←936          ⍝ gb2312               Chinese Simplified PRC Singapore
 CP_949←949          ⍝ ks_c_5601-1987       Korean
 CP_950←950          ⍝ big5                 Chinese Traditional Taiwan Hong Kong SAR PRC Big5
 CP_EUROPA3←29001    ⍝ x-Europa             Europa 3
 CP_CNCNS←20000      ⍝ x-Chinese-CNS        Chinese Traditional (CNS)
 CP_CNTCA←20001      ⍝ x-Chinese-TCA        Taiwan (TCA)
 CP_CNETEN←20002     ⍝ x-Chinese-Eten       Chinese Traditional (Eten)
 CP_KRJOHAB←1361     ⍝ Johab                Korean (Johab)
 CP_TWIBM←20003      ⍝ IBM5550              Taiwan (IBM5550)
 CP_TWTT←20004       ⍝ Taiwan_TeleText      Taiwan (TeleText)
 CP_TWWANG←20005     ⍝ Taiwan_Wang          Taiwan (Wang)
 CP_KOI8R←20866      ⍝ koi8-r               Ukrainian Cyrillic (KOI8-R)
 CP_KOI8U←21866      ⍝ koi8-u               Russian Cyrillic (KOI8-U)
∇

∇ InitMessages
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
     ⍝ Window Messages
 WM_NULL←0
 WM_CREATE←1
 WM_DESTROY←2
 WM_MOVE←3
 WM_SIZE←5
 WM_ACTIVATE←6
 WM_SETFOCUS←7
 WM_KILLFOCUS←8
 WM_ENABLE←10
 WM_SETREDRAW←11
 WM_SETTEXT←12
 WM_GETTEXT←13
 WM_GETTEXTLENGTH←14
 WM_PAINT←15
 WM_CLOSE←16
 WM_QUERYENDSESSION←17
 WM_QUIT←18
 WM_QUERYOPEN←19
 WM_ERASEBKGND←20
 WM_SYSCOLORCHANGE←21
 WM_ENDSESSION←22
 WM_SHOWWINDOW←24
 WM_SETTINGCHANGE←26
 WM_DEVMODECHANGE←27
 WM_ACTIVATEAPP←28
 WM_FONTCHANGE←29
 WM_TIMECHANGE←30
 WM_CANCELMODE←31
 WM_SETCURSOR←32
 WM_MOUSEACTIVATE←33
 WM_CHILDACTIVATE←34
 WM_QUEUESYNC←35
 WM_GETMINMAXINFO←36
 WM_PAINTICON←38
 WM_ICONERASEBKGND←39
 WM_NEXTDLGCTL←40
 WM_SPOOLERSTATUS←42
 WM_DRAWITEM←43
 WM_MEASUREITEM←44
 WM_DELETEITEM←45
 WM_VKEYTOITEM←46
 WM_CHARTOITEM←47
 WM_SETFONT←48
 WM_GETFONT←49
 WM_SETHOTKEY←50
 WM_GETHOTKEY←51
 WM_QUERYDRAGICON←55
 WM_COMPAREITEM←57
 WM_GETOBJECT←61
 WM_COMPACTING←65
 WM_COMMNOTIFY←68
 WM_WINDOWPOSCHANGING←70
 WM_WINDOWPOSCHANGED←71
 WM_POWER←72
 WM_COPYDATA←74
 WM_CANCELJOURNAL←75
 WM_NOTIFY←78
 WM_INPUTLANGCHANGEREQUEST←80
 WM_INPUTLANGCHANGE←81
 WM_TCARD←82
 WM_HELP←83
 WM_USERCHANGED←84
 WM_NOTIFYFORMAT←85
 WM_CONTEXTMENU←123
 WM_STYLECHANGING←124
 WM_STYLECHANGED←125
 WM_DISPLAYCHANGE←126
 WM_GETICON←127
 WM_SETICON←128
 WM_NCCREATE←129
 WM_NCDESTROY←130
 WM_NCCALCSIZE←131
 WM_NCHITTEST←132
 WM_NCPAINT←133
 WM_NCACTIVATE←134
 WM_GETDLGCODE←135
 WM_NCMOUSEMOVE←160
 WM_NCLBUTTONDOWN←161
 WM_NCLBUTTONUP←162
 WM_NCLBUTTONDBLCLK←163
 WM_NCRBUTTONDOWN←164
 WM_NCRBUTTONUP←165
 WM_NCRBUTTONDBLCLK←166
 WM_NCMBUTTONDOWN←167
 WM_NCMBUTTONUP←168
 WM_NCMBUTTONDBLCLK←169
 WM_NCXBUTTONDOWN←171
 WM_NCXBUTTONUP←172
 WM_NCXBUTTONDBLCLK←173
 WM_INPUT←255
 WM_KEYFIRST←256
 WM_KEYDOWN←256
 WM_KEYUP←257
 WM_CHAR←258
 WM_DEADCHAR←259
 WM_SYSKEYDOWN←260
 WM_SYSKEYUP←261
 WM_SYSCHAR←262
 WM_SYSDEADCHAR←263
 WM_UNICHAR←265
 WM_KEYLAST←265
 WM_IME_STARTCOMPOSITION←269
 WM_IME_ENDCOMPOSITION←270
 WM_IME_COMPOSITION←271
 WM_IME_KEYLAST←271
 WM_INITDIALOG←272
 WM_COMMAND←273
 WM_SYSCOMMAND←274
 WM_TIMER←275
 WM_HSCROLL←276
 WM_VSCROLL←277
 WM_INITMENU←278
 WM_INITMENUPOPUP←279
 WM_INITMENUPOPUPCLOSE←280
 WM_MENUSELECT←287
 WM_MENUCHAR←288
 WM_ENTERIDLE←289
 WM_MENURBUTTONUP←290
 WM_MENUDRAG←291
 WM_MENUGETOBJECT←292
 WM_UNINITMENUPOPUP←293
 WM_MENUCOMMAND←294
 WM_CHANGEUISTATE←295
 WM_UPDATEUISTATE←296
 WM_QUERYUISTATE←297
 WM_CTLCOLORMSGBOX←306
 WM_CTLCOLOREDIT←307
 WM_CTLCOLORLISTBOX←308
 WM_CTLCOLORBTN←309
 WM_CTLCOLORDLG←310
 WM_CTLCOLORSCROLLBAR←311
 WM_CTLCOLORSTATIC←312
 WM_MOUSEFIRST←512
 WM_MOUSEMOVE←512
 WM_LBUTTONDOWN←513
 WM_LBUTTONUP←514
 WM_LBUTTONDBLCLK←515
 WM_RBUTTONDOWN←516
 WM_RBUTTONUP←517
 WM_RBUTTONDBLCLK←518
 WM_MBUTTONDOWN←519
 WM_MBUTTONUP←520
 WM_MBUTTONDBLCLK←521
 WM_MOUSEWHEEL←522
 WM_XBUTTONDOWN←523
 WM_XBUTTONUP←524
 WM_XBUTTONDBLCLK←525
 WM_MOUSELAST←525
 WM_PARENTNOTIFY←528
 WM_ENTERMENULOOP←529
 WM_EXITMENULOOP←530
 WM_NEXTMENU←531
 WM_SIZING←532
 WM_CAPTURECHANGED←533
 WM_MOVING←534
 WM_POWERBROADCAST←536
 WM_DEVICECHANGE←537
 WM_IME_SETCONTEXT←641
 WM_IME_NOTIFY←642
 WM_IME_CONTROL←643
 WM_IME_COMPOSITIONFULL←644
 WM_IME_SELECT←645
 WM_IME_CHAR←646
 WM_IME_REQUEST←648
 WM_IME_KEYDOWN←656
 WM_IME_KEYUP←657
 WM_MDICREATE←544
 WM_MDIDESTROY←545
 WM_MDIACTIVATE←546
 WM_MDIRESTORE←547
 WM_MDINEXT←548
 WM_MDIMAXIMIZE←549
 WM_MDITILE←550
 WM_MDICASCADE←551
 WM_MDIICONARRANGE←552
 WM_MDIGETACTIVE←553
 WM_MDISETMENU←560
 WM_ENTERSIZEMOVE←561
 WM_EXITSIZEMOVE←562
 WM_DROPFILES←563
 WM_MDIREFRESHMENU←564
 WM_NCMOUSEHOVER←672
 WM_MOUSEHOVER←673
 WM_NCMOUSELEAVE←674
 WM_MOUSELEAVE←675
 WM_CUT←768
 WM_COPY←769
 WM_PASTE←770
 WM_CLEAR←771
 WM_UNDO←772
 WM_RENDERFORMAT←773
 WM_RENDERALLFORMATS←774
 WM_DESTROYCLIPBOARD←775
 WM_DRAWCLIPBOARD←776
 WM_PAINTCLIPBOARD←777
 WM_VSCROLLCLIPBOARD←778
 WM_SIZECLIPBOARD←779
 WM_ASKCBFORMATNAME←780
 WM_CHANGECBCHAIN←781
 WM_HSCROLLCLIPBOARD←782
 WM_QUERYNEWPALETTE←783
 WM_PALETTEISCHANGING←784
 WM_PALETTECHANGED←785
 WM_HOTKEY←786
 WM_PRINT←791
 WM_PRINTCLIENT←792
 WM_APPCOMMAND←793
 WM_THEMECHANGED←794
 WM_HANDHELDFIRST←856
 WM_HANDHELDLAST←863
 WM_AFXFIRST←864
 WM_AFXLAST←895
 WM_PENWINFIRST←896
 WM_PENWINLAST←911
 WM_USER←1024
     ⍝ Common Dialog PageSetupDlg messages
 WM_PSD_PAGESETUPDLG←WM_USER
 WM_PSD_FULLPAGERECT←WM_USER+1
 WM_PSD_MINMARGINRECT←WM_USER+2
 WM_PSD_MARGINRECT←WM_USER+3
 WM_PSD_GREEKTEXTRECT←WM_USER+4
 WM_PSD_ENVSTAMPRECT←WM_USER+5
 WM_PSD_YAFULLPAGERECT←WM_USER+6
     ⍝ Application messages
 WM_APP←32768
     ⍝ Common Dialog registered window message strings
 LBSELCHSTRING←'commdlg_LBSelChangedNotify'
 SHAREVISTRING←'commdlg_ShareViolation'
 FILEOKSTRING←'commdlg_FileNameOK'
 COLOROKSTRING←'commdlg_ColorOK'
 SETRGBSTRING←'commdlg_SetRGBColor'
 HELPMSGSTRING←'commdlg_help'
 FINDMSGSTRING←'commdlg_FindReplace'
     ⍝ Dyalog registered window message strings
 DYALOGCUSTOM1MSGSTRING←'DyalogCustomMessage1'
     ⍝ wParm-Key State Masks for Mouse Messages
 MK_LBUTTON←1
 MK_RBUTTON←2
 MK_SHIFT←4
 MK_CONTROL←8
 MK_MBUTTON←16
     ⍝ lParam-Flags for WM_KEYUP/DOWN/CHAR
 KF_EXTENDED←256
 KF_DLGMODE←2048
 KF_MENUMODE←4096
 KF_ALTDOWN←8192
 KF_REPEAT←16384
 KF_UP←32768
     ⍝ wParam-Virtual Key Codes for WM_KEYUP/DOWN/CHAR
 VK_LBUTTON←1
 VK_RBUTTON←2
 VK_CANCEL←3
 VK_MBUTTON←4
 VK_BACK←8
 VK_TAB←9
 VK_CLEAR←12
 VK_RETURN←13
 VK_SHIFT←16
 VK_CONTROL←17
 VK_MENU←18
 VK_PAUSE←19
 VK_CAPITAL←20
 VK_ESCAPE←27
 VK_SPACE←32
 VK_PRIOR←33
 VK_NEXT←34
 VK_END←35
 VK_HOME←36
 VK_LEFT←37
 VK_UP←38
 VK_RIGHT←39
 VK_DOWN←40
 VK_SELECT←41
 VK_PRINT←42
 VK_EXECUTE←43
 VK_SNAPSHOT←44
 VK_INSERT←45
 VK_DELETE←46
 VK_HELP←47
 VK_0←48
 VK_1←49
 VK_2←50
 VK_3←51
 VK_4←52
 VK_5←53
 VK_6←54
 VK_7←55
 VK_8←56
 VK_9←57
 VK_A←65
 VK_B←66
 VK_C←67
 VK_D←68
 VK_E←69
 VK_F←70
 VK_G←71
 VK_H←72
 VK_I←73
 VK_J←74
 VK_K←75
 VK_L←76
 VK_M←77
 VK_N←78
 VK_O←79
 VK_P←80
 VK_Q←81
 VK_R←82
 VK_S←83
 VK_T←84
 VK_U←85
 VK_V←86
 VK_W←87
 VK_X←88
 VK_Y←89
 VK_Z←90
 VK_LWIN←91
 VK_RWIN←92
 VK_APPS←93
 VK_NUMPAD0←96
 VK_NUMPAD1←97
 VK_NUMPAD2←98
 VK_NUMPAD3←99
 VK_NUMPAD4←100
 VK_NUMPAD5←101
 VK_NUMPAD6←102
 VK_NUMPAD7←103
 VK_NUMPAD8←104
 VK_NUMPAD9←105
 VK_MULTIPLY←106
 VK_ADD←107
 VK_SEPARATOR←108
 VK_SUBTRACT←109
 VK_DECIMAL←110
 VK_DIVIDE←111
 VK_F1←112
 VK_F2←113
 VK_F3←114
 VK_F4←115
 VK_F5←116
 VK_F6←117
 VK_F7←118
 VK_F8←119
 VK_F9←120
 VK_F10←121
 VK_F11←122
 VK_F12←123
 VK_F13←124
 VK_F14←125
 VK_F15←126
 VK_F16←127
 VK_F17←128
 VK_F18←129
 VK_F19←130
 VK_F20←131
 VK_F21←132
 VK_F22←133
 VK_F23←134
 VK_F24←135
 VK_NUMLOCK←144
 VK_SCROLL←145
 VK_LSHIFT←160
 VK_RSHIFT←161
 VK_LCONTROL←162
 VK_RCONTROL←163
 VK_LMENU←164
 VK_RMENU←165
 VK_PROCESSKEY←229
 VK_ATTN←246
 VK_CRSEL←247
 VK_EXSEL←248
 VK_EREOF←249
 VK_PLAY←250
 VK_ZOOM←251
 VK_NONAME←252
 VK_PA1←253
 VK_OEM_CLEAR←254
 'RegisterWindowMessage'⎕NA'I USER32|RegisterWindowMessageA <0T'
 'SendMessage'⎕NA'I USER32|SendMessageA I I I I'
 'PostMessage'⎕NA'I USER32|PostMessageA I I I I'
 'PostThreadMessage'⎕NA'I USER32|PostThreadMessageA I I I I'
∇

∇ InitRCodes;Base
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 NO_ERROR←0
 ERROR_SUCCESS←0                  ⍝ The operation completed successfully.
 ERROR_INVALID_FUNCTION←1         ⍝ Incorrect function.
 ERROR_FILE_NOT_FOUND←2           ⍝ The system cannot find the file specified.
 ERROR_PATH_NOT_FOUND←3           ⍝ The system cannot find the path specified.
 ERROR_TOO_MANY_OPEN_FILES←4      ⍝ The system cannot open the file.
 ERROR_ACCESS_DENIED←5            ⍝ Access is denied.
 ERROR_INVALID_HANDLE←6           ⍝ The handle is invalid.
 ERROR_ARENA_TRASHED←7            ⍝ The storage control blocks were destroyed.
 ERROR_NOT_ENOUGH_MEMORY←8        ⍝ Not enough storage is available to process this command.
 ERROR_INVALID_BLOCK←9            ⍝ The storage control block address is invalid.
 ERROR_BAD_ENVIRONMENT←10         ⍝ The environment is incorrect.
 ERROR_BAD_FORMAT←11              ⍝ An attempt was made to load a program with an incorrect format.
 ERROR_INVALID_ACCESS←12          ⍝ The access code is invalid.
 ERROR_INVALID_DATA←13            ⍝ The data is invalid.
 ERROR_OUTOFMEMORY←14             ⍝ Not enough storage is available to complete this operation.
 ERROR_INVALID_DRIVE←15           ⍝ The system cannot find the drive specified.
 ERROR_CURRENT_DIRECTORY←16       ⍝ The directory cannot be removed.
 ERROR_NOT_SAME_DEVICE←17         ⍝ The system cannot move the file to a different disk drive.
 ERROR_NO_MORE_FILES←18           ⍝ There are no more files.
 ERROR_WRITE_PROTECT←19           ⍝ The media is write protected.
 ERROR_BAD_UNIT←20                ⍝ The system cannot find the device specified.
 ERROR_NOT_READY←21               ⍝ The device is not ready.
 ERROR_BAD_COMMAND←22             ⍝ The device does not recognize the command.
 ERROR_CRC←23                     ⍝ Data error (cyclic redundancy check)
 ERROR_BAD_LENGTH←24              ⍝ The program issued a command but the command length is incorrect.
 ERROR_SEEK←25                    ⍝ The drive cannot locate a specific area or track on the disk.
 ERROR_NOT_DOS_DISK←26            ⍝ The specified disk or diskette cannot be accessed.
 ERROR_SECTOR_NOT_FOUND←27        ⍝ The drive cannot find the sector requested.
 ERROR_OUT_OF_PAPER←28            ⍝ The printer is out of paper.
 ERROR_WRITE_FAULT←29             ⍝ The system cannot write to the specified device.
 ERROR_READ_FAULT←30              ⍝ The system cannot read from the specified device.
 ERROR_GEN_FAILURE←31             ⍝ A device attached to the system is not functioning.
 ERROR_SHARING_VIOLATION←32       ⍝ The process cannot access the file because it is being used by another process.
 ERROR_LOCK_VIOLATION←33          ⍝ The process cannot access the file because another process has locked a portion of the file.
 ERROR_WRONG_DISK←34              ⍝ The wrong diskette is in the drive. Insert %2 (Volume Serial Number: %3) into drive %1.
 ERROR_SHARING_BUFFER_EXCEEDED←36 ⍝ Too many files opened for sharing.
 ERROR_HANDLE_EOF←38              ⍝ Reached end of file.
 ERROR_HANDLE_DISK_FULL←39        ⍝ The disk is full.
 ERROR_NOT_SUPPORTED←50               ⍝ The network request is not supported.
 ERROR_REM_NOT_LIST←51                ⍝ The remote computer is not available.
 ERROR_DUP_NAME←52                    ⍝ A duplicate name exists on the network.
 ERROR_BAD_NETPATH←53                 ⍝ The network path was not found.
 ERROR_NETWORK_BUSY←54                ⍝ The network is busy.
 ERROR_DEV_NOT_EXIST←55               ⍝ The specified network resource or device is no longer available.
 ERROR_TOO_MANY_CMDS←56               ⍝ The network BIOS command limit has been reached.
 ERROR_ADAP_HDW_ERR←57                ⍝ A network adapter hardware error occurred.
 ERROR_BAD_NET_RESP←58                ⍝ The specified server cannot perform the requested operation.
 ERROR_UNEXP_NET_ERR←59               ⍝ An unexpected network error occurred.
 ERROR_BAD_REM_ADAP←60                ⍝ The remote adapter is not compatible.
 ERROR_PRINTQ_FULL←61                 ⍝ The printer queue is full.
 ERROR_NO_SPOOL_SPACE←62              ⍝ Space to store the file waiting to be printed is not available on the server.
 ERROR_PRINT_CANCELLED←63             ⍝ Your file waiting to be printed was deleted.
 ERROR_NETNAME_DELETED←64             ⍝ The specified network name is no longer available.
 ERROR_NETWORK_ACCESS_DENIED←65       ⍝ Network access is denied.
 ERROR_BAD_DEV_TYPE←66                ⍝ The network resource type is not correct.
 ERROR_BAD_NET_NAME←67                ⍝ The network name cannot be found.
 ERROR_TOO_MANY_NAMES←68              ⍝ The name limit for the local computer network adapter card was exceeded.
 ERROR_TOO_MANY_SESS←69               ⍝ The network BIOS session limit was exceeded.
 ERROR_SHARING_PAUSED←70              ⍝ The remote server has been paused or is in the process of being started.
 ERROR_REQ_NOT_ACCEP←71               ⍝ No more connections can be made to this remote computer
 ERROR_REDIR_PAUSED←72                ⍝ The specified printer or disk device has been paused.
 ERROR_FILE_EXISTS←80                 ⍝ The file exists.
 ERROR_CANNOT_MAKE←82                 ⍝ The directory or file cannot be created.
 ERROR_FAIL_I24←83                    ⍝ Fail on INT 24
 ERROR_OUT_OF_STRUCTURES←84           ⍝ Storage to process this request is not available.
 ERROR_ALREADY_ASSIGNED←85            ⍝ The local device name is already in use.
 ERROR_INVALID_PASSWORD←86            ⍝ The specified network password is not correct.
 ERROR_INVALID_PARAMETER←87           ⍝ The parameter is incorrect.
 ERROR_NET_WRITE_FAULT←88             ⍝ A write fault occurred on the network.
 ERROR_NO_PROC_SLOTS←89               ⍝ The system cannot start another process at this time.
 ERROR_TOO_MANY_SEMAPHORES←100        ⍝ Cannot create another system semaphore.
 ERROR_EXCL_SEM_ALREADY_OWNED←101     ⍝ The exclusive semaphore is owned by another process.
 ERROR_SEM_IS_SET←102                 ⍝ The semaphore is set and cannot be closed.
 ERROR_TOO_MANY_SEM_REQUESTS←103      ⍝ The semaphore cannot be set again.
 ERROR_INVALID_AT_INTERRUPT_TIME←104  ⍝ Cannot request exclusive semaphores at interrupt time.
 ERROR_SEM_OWNER_DIED←105             ⍝ The previous ownership of this semaphore has ended.
 ERROR_SEM_USER_LIMIT←106             ⍝ Insert the diskette for drive %1.
 ERROR_DISK_CHANGE←107                ⍝ Program stopped because alternate diskette was not inserted.
 ERROR_DRIVE_LOCKED←108               ⍝ The disk is in use or locked by another process.
 ERROR_BROKEN_PIPE←109                ⍝ The pipe has been ended.
 ERROR_OPEN_FAILED←110                ⍝ The system cannot open the device or file specified.
 ERROR_BUFFER_OVERFLOW←111            ⍝ The file name is too long.
 ERROR_DISK_FULL←112                  ⍝ There is not enough space on the disk.
 ERROR_NO_MORE_SEARCH_HANDLES←113     ⍝ No more internal file identifiers available.
 ERROR_INVALID_TARGET_HANDLE←114      ⍝ The target internal file identifier is incorrect.
 ERROR_INVALID_CATEGORY←117           ⍝ The IOCTL call made by the application program is not correct.
 ERROR_INVALID_VERIFY_SWITCH←118      ⍝ The verify-on-write switch parameter value is not correct.
 ERROR_BAD_DRIVER_LEVEL←119           ⍝ The system does not support the command requested.
 ERROR_CALL_NOT_IMPLEMENTED←120       ⍝ This function is only valid in Windows NT mode.
 ERROR_SEM_TIMEOUT←121                ⍝ The semaphore timeout period has expired.
 ERROR_INSUFFICIENT_BUFFER←122        ⍝ The data area passed to a system call is too small.
 ERROR_INVALID_NAME←123               ⍝ The filename, directory name, or volume label syntax is incorrect.
 ERROR_INVALID_LEVEL←124              ⍝ The system call level is not correct.
 ERROR_NO_VOLUME_LABEL←125            ⍝ The disk has no volume label.
 ERROR_MOD_NOT_FOUND←126              ⍝ The specified module could not be found.
 ERROR_PROC_NOT_FOUND←127             ⍝ The specified procedure could not be found.
 ERROR_WAIT_NO_CHILDREN←128           ⍝ There are no child processes to wait for.
 ERROR_CHILD_NOT_COMPLETE←129         ⍝ The %1 application cannot be run in Windows NT mode.
 ERROR_DIRECT_ACCESS_HANDLE←130       ⍝ Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O.
 ERROR_NEGATIVE_SEEK←131              ⍝ An attempt was made to move the file pointer before the beginning of the file.
 ERROR_SEEK_ON_DEVICE←132             ⍝ The file pointer cannot be set on the specified device or file.
 ERROR_IS_JOIN_TARGET←133             ⍝ A JOIN or SUBST command cannot be used for a drive that contains previously joined drives.
 ERROR_IS_JOINED←134                  ⍝ An attempt was made to use a JOIN or SUBST command on a drive that has already been joined.
 ERROR_IS_SUBSTED←135                 ⍝ An attempt was made to use a JOIN or SUBST command on a drive that has already been substituted.
 ERROR_NOT_JOINED←136                 ⍝ The system tried to delete the JOIN of a drive that is not joined.
 ERROR_NOT_SUBSTED←137                ⍝ The system tried to delete the substitution of a drive that is not substituted.
 ERROR_JOIN_TO_JOIN←138               ⍝ The system tried to join a drive to a directory on a joined drive.
 ERROR_SUBST_TO_SUBST←139             ⍝ The system tried to substitute a drive to a directory on a substituted drive.
 ERROR_JOIN_TO_SUBST←140              ⍝ The system tried to join a drive to a directory on a substituted drive.
 ERROR_SUBST_TO_JOIN←141              ⍝ The system tried to SUBST a drive to a directory on a joined drive.
 ERROR_BUSY_DRIVE←142                 ⍝ The system cannot perform a JOIN or SUBST at this time.
 ERROR_SAME_DRIVE←143                 ⍝ The system cannot join or substitute a drive to or for a directory on the same drive.
 ERROR_DIR_NOT_ROOT←144               ⍝ The directory is not a subdirectory of the root directory.
 ERROR_DIR_NOT_EMPTY←145              ⍝ The directory is not empty.
 ERROR_IS_SUBST_PATH←146              ⍝ The path specified is being used in a substitute.
 ERROR_IS_JOIN_PATH←147               ⍝ Not enough resources are available to process this command.
 ERROR_PATH_BUSY←148                  ⍝ The path specified cannot be used at this time.
 ERROR_IS_SUBST_TARGET←149            ⍝ An attempt was made to join or substitute a substituted drive
 ERROR_SYSTEM_TRACE←150               ⍝ System trace information was not specified in your CONFIG.SYS file, or tracing is disallowed.
 ERROR_INVALID_EVENT_COUNT←151        ⍝ The number of specified semaphore events for DosMuxSemWait is not correct.
 ERROR_TOO_MANY_MUXWAITERS←152        ⍝ DosMuxSemWait did not execute; too many semaphores are already set.
 ERROR_INVALID_LIST_FORMAT←153        ⍝ The DosMuxSemWait list is not correct.
 ERROR_LABEL_TOO_LONG←154             ⍝ The volume label you entered exceeds the label character limit of the target file system.
 ERROR_TOO_MANY_TCBS←155              ⍝ Cannot create another thread.
 ERROR_SIGNAL_REFUSED←156             ⍝ The recipient process has refused the signal.
 ERROR_DISCARDED←157                  ⍝ The segment is already discarded and cannot be locked.
 ERROR_NOT_LOCKED←158                 ⍝ The segment is already unlocked.
 ERROR_BAD_THREADID_ADDR←159          ⍝ The address for the thread ID is not correct.
 ERROR_BAD_ARGUMENTS←160              ⍝ The argument string passed to DosExecPgm is not correct.
 ERROR_BAD_PATHNAME←161               ⍝ The specified path is invalid.
 ERROR_SIGNAL_PENDING←162             ⍝ A signal is already pending.
 ERROR_MAX_THRDS_REACHED←164          ⍝ No more threads can be created in the system.
 ERROR_LOCK_FAILED←167                ⍝ Unable to lock a region of a file.
 ERROR_BUSY←170                       ⍝ The requested resource is in use.
 ERROR_CANCEL_VIOLATION←173           ⍝ A lock request was not outstanding for the supplied cancel region.
 ERROR_ATOMIC_LOCKS_NOT_SUPPORTED←174 ⍝ The file system does not support atomic changes to the lock type.
 ERROR_INVALID_SEGMENT_NUMBER←180     ⍝ The system detected a segment number that was not correct.
 ERROR_INVALID_ORDINAL←182            ⍝ The operating system cannot run %1.
 ERROR_ALREADY_EXISTS←183             ⍝ Cannot create a file when that file already exists.
 ERROR_INVALID_FLAG_NUMBER←186        ⍝ The flag passed is not correct.
 ERROR_SEM_NOT_FOUND←187              ⍝ The specified system semaphore name was not found.
 ERROR_INVALID_STARTING_CODESEG←188   ⍝ The operating system cannot run %1.
 ERROR_INVALID_STACKSEG←189           ⍝ The operating system cannot run %1.
 ERROR_INVALID_MODULETYPE←190         ⍝ The operating system cannot run %1.
 ERROR_INVALID_EXE_SIGNATURE←191      ⍝ Cannot run %1 in Windows NT mode.
 ERROR_EXE_MARKED_INVALID←192         ⍝ The operating system cannot run %1.
 ERROR_BAD_EXE_FORMAT←193             ⍝ %1 is not a valid Windows NT application.
 ERROR_ITERATED_DATA_EXCEEDS_64k←194  ⍝ The operating system cannot run %1.
 ERROR_INVALID_MINALLOCSIZE←195       ⍝ The operating system cannot run %1.
 ERROR_DYNLINK_FROM_INVALID_RING←196  ⍝ The operating system cannot run this application program.
 ERROR_IOPL_NOT_ENABLED←197           ⍝ The operating system is not presently configured to run this application.
 ERROR_INVALID_SEGDPL←198             ⍝ The operating system cannot run %1.
 ERROR_AUTODATASEG_EXCEEDS_64k←199    ⍝ The operating system cannot run this application program.
 ERROR_RING2SEG_MUST_BE_MOVABLE←200   ⍝ The code segment cannot be greater than or equal to 64KB.
 ERROR_RELOC_CHAIN_XEEDS_SEGLIM←201   ⍝ The operating system cannot run %1.
 ERROR_INFLOOP_IN_RELOC_CHAIN←202     ⍝ The operating system cannot run %1.
 ERROR_ENVVAR_NOT_FOUND←203           ⍝ The system could not find the environment option that was entered.
 ERROR_NO_SIGNAL_SENT←205             ⍝ No process in the command subtree has a signal handler.
 ERROR_FILENAME_EXCED_RANGE←206       ⍝ The filename or extension is too long.
 ERROR_RING2_STACK_IN_USE←207         ⍝ The ring 2 stack is in use.
 ERROR_META_EXPANSION_TOO_LONG←208    ⍝ The global filename characters, * or ?, are entered incorrectly
 ERROR_INVALID_SIGNAL_NUMBER←209      ⍝ The signal being posted is not correct.
 ERROR_THREAD_1_INACTIVE←210          ⍝ The signal handler cannot be set.
 ERROR_LOCKED←212                     ⍝ The segment is locked and cannot be reallocated.
 ERROR_TOO_MANY_MODULES←214           ⍝ Too many dynamic link modules are attached to this program or dynamic link module.
 ERROR_NESTING_NOT_ALLOWED←215        ⍝ Can't nest calls to LoadModule.
 ERROR_EXE_MACHINE_TYPE_MISMATCH←216  ⍝ The image file %1 is valid, but is for a machine type other than the current machine.
 ERROR_BAD_PIPE←230                   ⍝ The pipe state is invalid.
 ERROR_PIPE_BUSY←231                  ⍝ All pipe instances are busy.
 ERROR_NO_DATA←232                    ⍝ The pipe is being closed.
 ERROR_PIPE_NOT_CONNECTED←233         ⍝ No process is on the other end of the pipe.
 ERROR_MORE_DATA←234                  ⍝ More data is available.
 ERROR_VC_DISCONNECTED←240            ⍝ The session was cancelled.
 ERROR_INVALID_EA_NAME←254            ⍝ The specified extended attribute name was invalid.
 ERROR_EA_LIST_INCONSISTENT←255       ⍝ The extended attributes are inconsistent.
 ERROR_NO_MORE_ITEMS←259              ⍝ No more data is available.
 ERROR_CANNOT_COPY←266                ⍝ The Copy API cannot be used.
 ERROR_DIRECTORY←267                  ⍝ The directory name is invalid.
 ERROR_EAS_DIDNT_FIT←275              ⍝ The extended attributes did not fit in the buffer.
 ERROR_EA_FILE_CORRUPT←276            ⍝ The extended attribute file on the mounted file system is corrupt.
 ERROR_EA_TABLE_FULL←277              ⍝ The extended attribute table file is full.
 ERROR_INVALID_EA_HANDLE←278          ⍝ The specified extended attribute handle is invalid.
 ERROR_EAS_NOT_SUPPORTED←282          ⍝ The mounted file system does not support extended attributes.
 ERROR_NOT_OWNER←288                  ⍝ Attempt to release mutex not owned by caller.
 ERROR_TOO_MANY_POSTS←298             ⍝ Too many posts were made to a semaphore.
 ERROR_PARTIAL_COPY←299               ⍝ Only part of a Read/WriteProcessMemory request was completed.
 ERROR_MR_MID_NOT_FOUND←317           ⍝ The system cannot find message for message number 0x%1 in message file for %2.
     
 ERROR_KEYFILE_INVALID←320      ⍝ No valid keyfile.
 ERROR_KEYFILE_FULL←321         ⍝ Keyfile full.
 ERROR_KEYFILE_INCONSISTENT←322 ⍝ Keyfile is inconsistent.
 ERROR_KEY_NOT_EXIST←323        ⍝ Key does not exist.
 ERROR_KEY_EXISTS←324           ⍝ Key already exists.
 ERROR_KEY_NO_EXACT_MATCH←325   ⍝ No identical key found.
 ERROR_KEY_NO_MORE←326          ⍝ No more keys found.
 ERROR_KEY_INDEX_INVALID←327    ⍝ Requested index is invalid.
 ERROR_KEY_INDEX_INUSE←328      ⍝ Requested index is still in use.
 ERROR_FIXFILE_INVALID←330          ⍝ No valid fixfile.
 ERROR_FIX_INDEX_INVALID←331        ⍝ Invalid fix-record index.
 ERROR_FIXFILE_INCONSISTENT←332     ⍝ Fix-file is inconsistent.
 ERROR_FIX_INVALID_RECORDCOUNT←333  ⍝ Not matching number of fix-records.
 ERROR_FIX_INVALID_RECORDFORMAT←334 ⍝ Not matching format for fix-record.
 ERROR_FIX_IMPROPER_VALUE←335       ⍝ Impropper value for data field in fix-record.
 ERROR_FIX_RECORD_LOCKED←336        ⍝ Fix-record actually locked.
     
 ERROR_INVALID_ADDRESS←487     ⍝ Attempt to access invalid address.
 ERROR_ARITHMETIC_OVERFLOW←534 ⍝ Arithmetic result exceeded 32 bits.
 ERROR_PIPE_CONNECTED←535      ⍝ There is a process on other end of the pipe.
 ERROR_PIPE_LISTENING←536      ⍝ Waiting for a process to open the other end of the pipe.
 ERROR_EA_ACCESS_DENIED←994    ⍝ Access to the extended attribute was denied.
 ERROR_OPERATION_ABORTED←995   ⍝ The I/O operation has been aborted because of either a thread exit or an application request.
 ERROR_IO_INCOMPLETE←996       ⍝ Overlapped I/O event is not in a signaled state.
 ERROR_IO_PENDING←997          ⍝ Overlapped I/O operation is in progress.
 ERROR_NOACCESS←998            ⍝ Invalid access to memory location.
 ERROR_SWAPERROR←999           ⍝ Error performing inpage operation.
 ERROR_STACK_OVERFLOW←1001     ⍝ Recursion too deep; the stack overflowed.
 ERROR_INVALID_MESSAGE←1002    ⍝ The window cannot act on the sent message.
 ERROR_CAN_NOT_COMPLETE←1003   ⍝ Cannot complete this function.
 ERROR_INVALID_FLAGS←1004      ⍝ Invalid flags.
 ERROR_UNRECOGNIZED_VOLUME←1005⍝ The volume does not contain a recognized file system.
 ERROR_FILE_INVALID←1006       ⍝ The volume for a file has been externally altered so that the opened file is no longer valid.
 ERROR_FULLSCREEN_MODE←1007    ⍝ The requested operation cannot be performed in full-screen mode.
 ERROR_NO_TOKEN←1008           ⍝ An attempt was made to reference a token that does not exist.
 ERROR_BADDB←1009              ⍝ The configuration registry database is corrupt.
 ERROR_BADKEY←1010             ⍝ The configuration registry key is invalid.
 ERROR_CANTOPEN←1011           ⍝ The configuration registry key could not be opened.
 ERROR_CANTREAD←1012           ⍝ The configuration registry key could not be read.
 ERROR_CANTWRITE←1013          ⍝ The configuration registry key could not be written.
 ERROR_REGISTRY_RECOVERED←1014 ⍝ One of the files in the registry database had to be recovered by use of a log or alternate copy.
 ERROR_REGISTRY_CORRUPT←1015   ⍝ The registry is corrupted.
 ERROR_REGISTRY_IO_FAILED←1016 ⍝ An I/O operation initiated by the registry failed unrecoverably.
 ERROR_NOT_REGISTRY_FILE←1017  ⍝ The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.
 ERROR_KEY_DELETED←1018        ⍝ Illegal operation attempted on a registry key that has been marked for deletion.
 ERROR_NO_LOG_SPACE←1019       ⍝ System could not allocate the required space in a registry log.
 ERROR_KEY_HAS_CHILDREN←1020   ⍝ Cannot create a symbolic link in a registry key that already has subkeys or values.
 ERROR_CHILD_MUST_BE_VOLATILE←1021    ⍝ Cannot create a stable subkey under a volatile parent key.
 ERROR_NOTIFY_ENUM_DIR←1022           ⍝ A notify change request is being completed and the information is not being returned in the caller's buffer.
 ERROR_DEPENDENT_SERVICES_RUNNING←1051⍝ A stop control has been sent to a service that other running services are dependent on.
 ERROR_INVALID_SERVICE_CONTROL←1052   ⍝ The requested control is not valid for this service.
 ERROR_SERVICE_REQUEST_TIMEOUT←1053   ⍝ The service did not respond to the start or control request in a timely fashion.
 ERROR_SERVICE_NO_THREAD←1054         ⍝ A thread could not be created for the service.
 ERROR_SERVICE_DATABASE_LOCKED←1055   ⍝ The service database is locked.
 ERROR_SERVICE_ALREADY_RUNNING←1056   ⍝ An instance of the service is already running.
 ERROR_INVALID_SERVICE_ACCOUNT←1057   ⍝ The account name is invalid or does not exist, or the password is invalid for the account name specified.
 ERROR_SERVICE_DISABLED←1058          ⍝ The service cannot be started, either because it is disabled or because it has no enabled devices associated with it.
 ERROR_CIRCULAR_DEPENDENCY←1059       ⍝ Circular service dependency was specified.
 ERROR_SERVICE_DOES_NOT_EXIST←1060    ⍝ The specified service does not exist as an installed service.
 ERROR_SERVICE_CANNOT_ACCEPT_CTRL←1061⍝ The service cannot accept control messages at this time.
 ERROR_SERVICE_NOT_ACTIVE←1062        ⍝ The service has not been started.
 ERROR_FAILED_SERVICE_CONTROLLER_CONNECT←1063⍝ The service process could not connect to the service controller.
 ERROR_EXCEPTION_IN_SERVICE←1064      ⍝ An exception occurred in the service when handling the control request.
 ERROR_DATABASE_DOES_NOT_EXIST←1065   ⍝ The database specified does not exist.
 ERROR_SERVICE_SPECIFIC_ERROR←1066    ⍝ The service has returned a service-specific error code.
 ERROR_PROCESS_ABORTED←1067           ⍝ The process terminated unexpectedly.
 ERROR_SERVICE_DEPENDENCY_FAIL←1068   ⍝ The dependency service or group failed to start.
 ERROR_SERVICE_LOGON_FAILED←1069      ⍝ The service did not start due to a logon failure.
 ERROR_SERVICE_START_HANG←1070        ⍝ After starting, the service hung in a start-pending state.
 ERROR_INVALID_SERVICE_LOCK←1071      ⍝ The specified service database lock is invalid.
 ERROR_SERVICE_MARKED_FOR_DELETE←1072 ⍝ The specified service has been marked for deletion.
 ERROR_SERVICE_EXISTS←1073            ⍝ The specified service already exists.
 ERROR_ALREADY_RUNNING_LKG←1074       ⍝ The system is currently running with the last-known-good configuration.
 ERROR_SERVICE_DEPENDENCY_DELETED←1075⍝ The dependency service does not exist or has been marked for deletion.
 ERROR_BOOT_ALREADY_ACCEPTED←1076     ⍝ The current boot has already been accepted for use as the last-known-good control set.
 ERROR_SERVICE_NEVER_STARTED←1077     ⍝ No attempts to start the service have been made since the last boot.
 ERROR_DUPLICATE_SERVICE_NAME←1078    ⍝ The name is already in use as either a service name or a service display name.
 ERROR_DIFFERENT_SERVICE_ACCOUNT←1079 ⍝ The account specified for this service is different from the account specified for other services running in the same process.
 ERROR_CANNOT_DETECT_DRIVER_FAILURE←1080⍝ Failure actions can only be set for Win32 services, not for drivers.
 ERROR_CANNOT_DETECT_PROCESS_ABORT←1081⍝ This service runs in the same process as the service control manager.
 ERROR_NO_RECOVERY_PROGRAM←1082       ⍝ No recovery program has been configured for this service.
 ERROR_SERVICE_NOT_IN_EXE←1083        ⍝ The executable program that this service is configured to run in does not implement the service.
 ERROR_NOT_SAFEBOOT_SERVICE←1084      ⍝ This service cannot be started in Safe Mode
 ERROR_END_OF_MEDIA←1100              ⍝ The physical end of the tape has been reached.
 ERROR_FILEMARK_DETECTED←1101         ⍝ A tape access reached a filemark.
 ERROR_BEGINNING_OF_MEDIA←1102        ⍝ The beginning of the tape or a partition was encountered.
 ERROR_SETMARK_DETECTED←1103          ⍝ A tape access reached the end of a set of files.
 ERROR_NO_DATA_DETECTED←1104          ⍝ No more data is on the tape.
 ERROR_PARTITION_FAILURE←1105         ⍝ Tape could not be partitioned.
 ERROR_INVALID_BLOCK_LENGTH←1106      ⍝ When accessing a new tape of a multivolume partition, the current block size is incorrect.
 ERROR_DEVICE_NOT_PARTITIONED←1107    ⍝ Tape partition information could not be found when loading a tape.
 ERROR_UNABLE_TO_LOCK_MEDIA←1108      ⍝ Unable to lock the media eject mechanism.
 ERROR_UNABLE_TO_UNLOAD_MEDIA←1109    ⍝ Unable to unload the media.
 ERROR_MEDIA_CHANGED←1110             ⍝ The media in the drive may have changed.
 ERROR_BUS_RESET←1111                 ⍝ The I/O bus was reset.
 ERROR_NO_MEDIA_IN_DRIVE←1112         ⍝ No media in drive.
 ERROR_NO_UNICODE_TRANSLATION←1113    ⍝ No mapping for the Unicode character exists in the target multi-byte code page.
 ERROR_DLL_INIT_FAILED←1114
 ERROR_SHUTDOWN_IN_PROGRESS←1115
 ERROR_NO_SHUTDOWN_IN_PROGRESS←1116
 ERROR_IO_DEVICE←1117
 ERROR_SERIAL_NO_DEVICE←1118
 ERROR_IRQ_BUSY←1119
 ERROR_MORE_WRITES←1120
 ERROR_COUNTER_TIMEOUT←1121
 ERROR_FLOPPY_ID_MARK_NOT_FOUND←1122
 ERROR_FLOPPY_WRONG_CYLINDER←1123
 ERROR_FLOPPY_UNKNOWN_ERROR←1124
 ERROR_FLOPPY_BAD_REGISTERS←1125
 ERROR_DISK_RECALIBRATE_FAILED←1126
 ERROR_DISK_OPERATION_FAILED←1127
 ERROR_DISK_RESET_FAILED←1128
 ERROR_EOM_OVERFLOW←1129
 ERROR_NOT_ENOUGH_SERVER_MEMORY←1130
 ERROR_POSSIBLE_DEADLOCK←1131
 ERROR_MAPPED_ALIGNMENT←1132
 ERROR_TOO_MANY_LINKS←1142
 ERROR_OLD_WIN_VERSION←1150
 ERROR_APP_WRONG_OS←1151
 ERROR_SINGLE_INSTANCE_APP←1152
 ERROR_RMODE_APP←1153
 ERROR_INVALID_DLL←1154
 ERROR_NO_ASSOCIATION←1155
 ERROR_DDE_FAIL←1156
 ERROR_DLL_NOT_FOUND←1157
 ERROR_NO_MORE_USER_HANDLES←1158
 ERROR_MESSAGE_SYNC_ONLY←1159
 ERROR_SOURCE_ELEMENT_EMPTY←1160
 ERROR_DESTINATION_ELEMENT_FULL←1161
 ERROR_ILLEGAL_ELEMENT_ADDRESS←1162
 ERROR_MAGAZINE_NOT_PRESENT←1163
 ERROR_DEVICE_REINITIALIZATION_NEEDED←1164
 ERROR_DEVICE_REQUIRES_CLEANING←1165
 ERROR_DEVICE_DOOR_OPEN←1166
 ERROR_DEVICE_NOT_CONNECTED←1167      ⍝ The device is not connected.
 ERROR_NOT_FOUND←1168                 ⍝ Element not found.
 ERROR_NO_MATCH←1169                  ⍝ There was no match for the specified key in the index.
 ERROR_SET_NOT_FOUND←1170             ⍝ The property set specified does not exist on the object.
 ERROR_POINT_NOT_FOUND←1171           ⍝ The point passed to GetMouseMovePoints is not in the buffer.
 ERROR_NO_TRACKING_SERVICE←1172       ⍝ The tracking (workstation) service is not running.
 ERROR_NO_VOLUME_ID←1173              ⍝ The Volume ID could not be found.
 ERROR_UNABLE_TO_REMOVE_REPLACED←1175 ⍝ Unable to remove the file to be replaced.
 ERROR_UNABLE_TO_MOVE_REPLACEMENT←1176⍝ Unable to move the replacement file to the file to be replaced.
 ERROR_UNABLE_TO_MOVE_REPLACEMENT_2←1177⍝ Unable to move the replacement file to the file to be replaced.
 ERROR_JOURNAL_DELETE_IN_PROGRESS←1178⍝ The volume change journal is being deleted.
 ERROR_JOURNAL_NOT_ACTIVE←1179        ⍝ The volume change journal is not active.
 ERROR_POTENTIAL_FILE_FOUND←1180      ⍝ A file was found, but it may not be the correct file.
 ERROR_JOURNAL_ENTRY_DELETED←1181     ⍝ The journal entry has been deleted from the journal.
 ERROR_BAD_DEVICE←1200                ⍝ The specified device name is invalid.
 ERROR_CONNECTION_UNAVAIL←1201        ⍝ The device is not currently connected but it is a remembered connection.
 ERROR_DEVICE_ALREADY_REMEMBERED←1202 ⍝ The local device name has a remembered connection to another network resource.
 ERROR_NO_NET_OR_BAD_PATH←1203        ⍝ No network provider accepted the given network path.
 ERROR_BAD_PROVIDER←1204              ⍝ The specified network provider name is invalid.
 ERROR_CANNOT_OPEN_PROFILE←1205       ⍝ Unable to open the network connection profile.
 ERROR_BAD_PROFILE←1206               ⍝ The network connection profile is corrupted.
 ERROR_NOT_CONTAINER←1207             ⍝ Cannot enumerate a noncontainer.
 ERROR_EXTENDED_ERROR←1208            ⍝ An extended error has occurred.
 ERROR_INVALID_GROUPNAME←1209         ⍝ The format of the specified group name is invalid.
 ERROR_INVALID_COMPUTERNAME←1210      ⍝ The format of the specified computer name is invalid.
 ERROR_INVALID_EVENTNAME←1211         ⍝ The format of the specified event name is invalid.
 ERROR_INVALID_DOMAINNAME←1212        ⍝ The format of the specified domain name is invalid.
 ERROR_INVALID_SERVICENAME←1213       ⍝ The format of the specified service name is invalid.
 ERROR_INVALID_NETNAME←1214           ⍝ The format of the specified network name is invalid.
 ERROR_INVALID_SHARENAME←1215         ⍝ The format of the specified share name is invalid.
 ERROR_INVALID_PASSWORDNAME←1216      ⍝ The format of the specified password is invalid.
 ERROR_INVALID_MESSAGENAME←1217       ⍝ The format of the specified message name is invalid.
 ERROR_INVALID_MESSAGEDEST←1218       ⍝ The format of the specified message destination is invalid.
 ERROR_SESSION_CREDENTIAL_CONFLICT←1219⍝ Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed.
 ERROR_REMOTE_SESSION_LIMIT_EXCEEDED←1220⍝ An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.
 ERROR_DUP_DOMAINNAME←1221            ⍝ The workgroup or domain name is already in use by another computer on the network.
 ERROR_NO_NETWORK←1222                ⍝ The network is not present or not started.
 ERROR_CANCELLED←1223                 ⍝ The operation was canceled by the user.
 ERROR_USER_MAPPED_FILE←1224          ⍝ The requested operation cannot be performed on a file with a user-mapped section open.
 ERROR_CONNECTION_REFUSED←1225        ⍝ The remote system refused the network connection.
 ERROR_GRACEFUL_DISCONNECT←1226       ⍝ The network connection was gracefully closed.
 ERROR_ADDRESS_ALREADY_ASSOCIATED←1227⍝ The network transport endpoint already has an address associated with it.
 ERROR_ADDRESS_NOT_ASSOCIATED←1228    ⍝ An address has not yet been associated with the network endpoint.
 ERROR_CONNECTION_INVALID←1229        ⍝ An operation was attempted on a nonexistent network connection.
 ERROR_CONNECTION_ACTIVE←1230         ⍝ An invalid operation was attempted on an active network connection.
 ERROR_NETWORK_UNREACHABLE←1231       ⍝ The network location cannot be reached.
 ERROR_HOST_UNREACHABLE←1232          ⍝ The network location cannot be reached.
 ERROR_PROTOCOL_UNREACHABLE←1233      ⍝ The network location cannot be reached.
 ERROR_PORT_UNREACHABLE←1234          ⍝ No service is operating at the destination network endpoint on the remote system.
 ERROR_REQUEST_ABORTED←1235           ⍝ The request was aborted.
 ERROR_CONNECTION_ABORTED←1236        ⍝ The network connection was aborted by the local system.
 ERROR_RETRY←1237                     ⍝ The operation could not be completed.
 ERROR_CONNECTION_COUNT_LIMIT←1238    ⍝ A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.
 ERROR_LOGIN_TIME_RESTRICTION←1239    ⍝ Attempting to log in during an unauthorized time of day for this account.
 ERROR_LOGIN_WKSTA_RESTRICTION←1240   ⍝ The account is not authorized to log in from this station.
 ERROR_INCORRECT_ADDRESS←1241         ⍝ The network address could not be used for the operation requested.
 ERROR_ALREADY_REGISTERED←1242        ⍝ The service is already registered.
 ERROR_SERVICE_NOT_FOUND←1243         ⍝ The specified service does not exist.
 ERROR_NOT_AUTHENTICATED←1244         ⍝ The operation being requested was not performed because the user has not been authenticated.
 ERROR_NOT_LOGGED_ON←1245             ⍝ The operation being requested was not performed because the user has not logged on to the network.
 ERROR_CONTINUE←1246                  ⍝ Continue with work in progress.
 ERROR_ALREADY_INITIALIZED←1247       ⍝ An attempt was made to perform an initialization operation when initialization has already been completed.
 ERROR_NO_MORE_DEVICES←1248           ⍝ No more local devices.
 ERROR_NO_SUCH_SITE←1249              ⍝ The specified site does not exist.
 ERROR_DOMAIN_CONTROLLER_EXISTS←1250  ⍝ A domain controller with the specified name already exists.
 ERROR_ONLY_IF_CONNECTED←1251         ⍝ This operation is supported only when you are connected to the server.
 ERROR_OVERRIDE_NOCHANGES←1252        ⍝ The group policy framework should call the extension even if there are no changes.
 ERROR_BAD_USER_PROFILE←1253          ⍝ The specified user does not have a valid profile.
 ERROR_NOT_SUPPORTED_ON_SBS←1254      ⍝ This operation is not supported on a Microsoft Small Business Server
 ERROR_SERVER_SHUTDOWN_IN_PROGRESS←1255⍝ The server machine is shutting down.
 ERROR_HOST_DOWN←1256                 ⍝ The remote system is not available.
 ERROR_NON_ACCOUNT_SID←1257           ⍝ The security identifier provided is not from an account domain.
 ERROR_NON_DOMAIN_SID←1258            ⍝ The security identifier provided does not have a domain component.
 ERROR_APPHELP_BLOCK←1259             ⍝ AppHelp dialog canceled thus preventing the application from starting.
 ERROR_ACCESS_DISABLED_BY_POLICY←1260 ⍝ Windows cannot open this program because it has been prevented by a software restriction policy.
 ERROR_REG_NAT_CONSUMPTION←1261       ⍝ A program attempt to use an invalid register value.
 ERROR_CSCSHARE_OFFLINE←1262          ⍝ The share is currently offline or does not exist.
 ERROR_PKINIT_FAILURE←1263            ⍝ The kerberos protocol encountered an error while validating the KDC certificate during smartcard logon.
 ERROR_SMARTCARD_SUBSYSTEM_FAILURE←1264⍝ The kerberos protocol encountered an error while attempting to utilize the smartcard subsystem.
 ERROR_DOWNGRADE_DETECTED←1265        ⍝ The system detected a possible attempt to compromise security.
 SEC_E_SMARTCARD_CERT_REVOKED←1266    ⍝ The smartcard certificate used for authentication has been revoked.
 SEC_E_ISSUING_CA_UNTRUSTED←1267      ⍝ An untrusted certificate authority was detected While processing the smartcard certificate used for authentication.
 SEC_E_REVOCATION_OFFLINE_C←1268      ⍝ The revocation status of the smartcard certificate used for authentication could not be determined.
 SEC_E_PKINIT_CLIENT_FAILURE←1269     ⍝ The smartcard certificate used for authentication was not trusted.
 SEC_E_SMARTCARD_CERT_EXPIRED←1270    ⍝ The smartcard certificate used for authentication has expired.
 ERROR_MACHINE_LOCKED←1271            ⍝ The machine is locked and can not be shut down without the force option.
 ERROR_CALLBACK_SUPPLIED_INVALID_DATA←1273⍝ An application-defined callback gave invalid data when called.
 ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED←1274⍝ The group policy framework should call the extension in the synchronous foreground policy refresh.
 ERROR_DRIVER_BLOCKED←1275            ⍝ This driver has been blocked from loading
 ERROR_INVALID_IMPORT_OF_NON_DLL←1276 ⍝ A DLL referenced a module that was neither a DLL nor the process's executable image.
 ERROR_NOT_ALL_ASSIGNED←1300          ⍝ Not all privileges referenced are assigned to the caller.
 ERROR_SOME_NOT_MAPPED←1301           ⍝ Some mapping between account names and security IDs was not done.
 ERROR_NO_QUOTAS_FOR_ACCOUNT←1302     ⍝ No system quota limits are specifically set for this account.
 ERROR_LOCAL_USER_SESSION_KEY←1303    ⍝ No encryption key is available.
 ERROR_NULL_LM_PASSWORD←1304          ⍝ The password is too complex to be converted to a LAN Manager password.
 ERROR_UNKNOWN_REVISION←1305          ⍝ The revision level is unknown.
 ERROR_REVISION_MISMATCH←1306         ⍝ Indicates two revision levels are incompatible.
 ERROR_INVALID_OWNER←1307             ⍝ This security ID may not be assigned as the owner of this object.
 ERROR_INVALID_PRIMARY_GROUP←1308     ⍝ This security ID may not be assigned as the primary group of an object.
 ERROR_NO_IMPERSONATION_TOKEN←1309    ⍝ An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.
 ERROR_CANT_DISABLE_MANDATORY←1310    ⍝ The group may not be disabled.
 ERROR_NO_LOGON_SERVERS←1311          ⍝ There are currently no logon servers available to service the logon request.
 ERROR_NO_SUCH_LOGON_SESSION←1312     ⍝ A specified logon session does not exist.
 ERROR_NO_SUCH_PRIVILEGE←1313         ⍝ A specified privilege does not exist.
 ERROR_PRIVILEGE_NOT_HELD←1314        ⍝ A required privilege is not held by the client.
 ERROR_INVALID_ACCOUNT_NAME←1315      ⍝ The name provided is not a properly formed account name.
 ERROR_USER_EXISTS←1316               ⍝ The specified user already exists.
 ERROR_NO_SUCH_USER←1317              ⍝ The specified user does not exist.
 ERROR_GROUP_EXISTS←1318              ⍝ The specified group already exists.
 ERROR_NO_SUCH_GROUP←1319             ⍝ The specified group does not exist.
 ERROR_MEMBER_IN_GROUP←1320           ⍝ Either the specified user account is already a member of the specified group, or the specified group cannot be deleted because it contains a member.
 ERROR_MEMBER_NOT_IN_GROUP←1321       ⍝ The specified user account is not a member of the specified group account.
 ERROR_LAST_ADMIN←1322                ⍝ The last remaining administration account cannot be disabled or deleted.
 ERROR_WRONG_PASSWORD←1323            ⍝ Unable to update the password.
 ERROR_ILL_FORMED_PASSWORD←1324       ⍝ Unable to update the password.
 ERROR_PASSWORD_RESTRICTION←1325      ⍝ Unable to update the password.
 ERROR_LOGON_FAILURE←1326             ⍝ Logon failure: unknown user name or bad password.
 ERROR_ACCOUNT_RESTRICTION←1327       ⍝ Logon failure: user account restriction.
 ERROR_INVALID_LOGON_HOURS←1328       ⍝ Logon failure: account logon time restriction violation.
 ERROR_INVALID_WORKSTATION←1329       ⍝ Logon failure: user not allowed to log on to this computer.
 ERROR_PASSWORD_EXPIRED←1330          ⍝ Logon failure: the specified account password has expired.
 ERROR_ACCOUNT_DISABLED←1331          ⍝ Logon failure: account currently disabled.
 ERROR_NONE_MAPPED←1332               ⍝ No mapping between account names and security IDs was done.
 ERROR_TOO_MANY_LUIDS_REQUESTED←1333  ⍝ Too many local user identifiers (LUIDs) were requested at one time.
 ERROR_LUIDS_EXHAUSTED←1334           ⍝ No more local user identifiers (LUIDs) are available.
 ERROR_INVALID_SUB_AUTHORITY←1335     ⍝ The subauthority part of a security ID is invalid for this particular use.
 ERROR_INVALID_ACL←1336               ⍝ The access control list (ACL) structure is invalid.
 ERROR_INVALID_SID←1337               ⍝ The security ID structure is invalid.
 ERROR_INVALID_SECURITY_DESCR←1338    ⍝ The security descriptor structure is invalid.
 ERROR_BAD_INHERITANCE_ACL←1340       ⍝ The inherited access control list (ACL) or access control entry (ACE) could not be built.
 ERROR_SERVER_DISABLED←1341           ⍝ The server is currently disabled.
 ERROR_SERVER_NOT_DISABLED←1342       ⍝ The server is currently enabled.
 ERROR_INVALID_ID_AUTHORITY←1343      ⍝ The value provided was an invalid value for an identifier authority.
 ERROR_ALLOTTED_SPACE_EXCEEDED←1344   ⍝ No more memory is available for security information updates.
 ERROR_INVALID_GROUP_ATTRIBUTES←1345  ⍝ The specified attributes are invalid, or incompatible with the attributes for the group as a whole.
 ERROR_BAD_IMPERSONATION_LEVEL←1346   ⍝ Either a required impersonation level was not provided, or the provided impersonation level is invalid.
 ERROR_CANT_OPEN_ANONYMOUS←1347       ⍝ Cannot open an anonymous level security token.
 ERROR_BAD_VALIDATION_CLASS←1348      ⍝ The validation information class requested was invalid.
 ERROR_BAD_TOKEN_TYPE←1349            ⍝ The type of the token is inappropriate for its attempted use.
 ERROR_NO_SECURITY_ON_OBJECT←1350     ⍝ Unable to perform a security operation on an object that has no associated security.
 ERROR_CANT_ACCESS_DOMAIN_INFO←1351   ⍝ Configuration information could not be read from the domain controller, either because the machine is unavailable, or access has been denied.
 ERROR_INVALID_SERVER_STATE←1352      ⍝ The security account manager (SAM) or local security authority (LSA) server was in the wrong state to perform the security operation.
 ERROR_INVALID_DOMAIN_STATE←1353      ⍝ The domain was in the wrong state to perform the security operation.
 ERROR_INVALID_DOMAIN_ROLE←1354       ⍝ This operation is only allowed for the Primary Domain Controller of the domain.
 ERROR_NO_SUCH_DOMAIN←1355            ⍝ The specified domain either does not exist or could not be contacted.
 ERROR_DOMAIN_EXISTS←1356             ⍝ The specified domain already exists.
 ERROR_DOMAIN_LIMIT_EXCEEDED←1357     ⍝ An attempt was made to exceed the limit on the number of domains per server.
 ERROR_INTERNAL_DB_CORRUPTION←1358    ⍝ Unable to complete the requested operation because of either a catastrophic media failure or a data structure corruption on the disk.
 ERROR_INTERNAL_ERROR←1359            ⍝ An internal error occurred.
 ERROR_GENERIC_NOT_MAPPED←1360        ⍝ Generic access types were contained in an access mask which should already be mapped to nongeneric types.
 ERROR_BAD_DESCRIPTOR_FORMAT←1361     ⍝ A security descriptor is not in the right format (absolute or self-relative).
 ERROR_NOT_LOGON_PROCESS←1362         ⍝ The requested action is restricted for use by logon processes only.
 ERROR_LOGON_SESSION_EXISTS←1363      ⍝ Cannot start a new logon session with an ID that is already in use.
 ERROR_NO_SUCH_PACKAGE←1364           ⍝ A specified authentication package is unknown.
 ERROR_BAD_LOGON_SESSION_STATE←1365   ⍝ The logon session is not in a state that is consistent with the requested operation.
 ERROR_LOGON_SESSION_COLLISION←1366   ⍝ The logon session ID is already in use.
 ERROR_INVALID_LOGON_TYPE←1367        ⍝ A logon request contained an invalid logon type value.
 ERROR_CANNOT_IMPERSONATE←1368        ⍝ Unable to impersonate using a named pipe until data has been read from that pipe.
 ERROR_RXACT_INVALID_STATE←1369       ⍝ The transaction state of a registry subtree is incompatible with the requested operation.
 ERROR_RXACT_COMMIT_FAILURE←1370      ⍝ An internal security database corruption has been encountered.
 ERROR_SPECIAL_ACCOUNT←1371           ⍝ Cannot perform this operation on built-in accounts.
 ERROR_SPECIAL_GROUP←1372             ⍝ Cannot perform this operation on this built-in special group.
 ERROR_SPECIAL_USER←1373              ⍝ Cannot perform this operation on this built-in special user.
 ERROR_MEMBERS_PRIMARY_GROUP←1374     ⍝ The user cannot be removed from a group because the group is currently the user's primary group.
 ERROR_TOKEN_ALREADY_IN_USE←1375      ⍝ The token is already in use as a primary token.
 ERROR_NO_SUCH_ALIAS←1376             ⍝ The specified local group does not exist.
 ERROR_MEMBER_NOT_IN_ALIAS←1377       ⍝ The specified account name is not a member of the local group.
 ERROR_MEMBER_IN_ALIAS←1378           ⍝ The specified account name is already a member of the local group.
 ERROR_ALIAS_EXISTS←1379              ⍝ The specified local group already exists.
 ERROR_LOGON_NOT_GRANTED←1380         ⍝ Logon failure: the user has not been granted the requested logon type at this computer.
 ERROR_TOO_MANY_SECRETS←1381          ⍝ The maximum number of secrets that may be stored in a single system has been exceeded.
 ERROR_SECRET_TOO_LONG←1382           ⍝ The length of a secret exceeds the maximum length allowed.
 ERROR_INTERNAL_DB_ERROR←1383         ⍝ The local security authority database contains an internal inconsistency.
 ERROR_TOO_MANY_CONTEXT_IDS←1384      ⍝ During a logon attempt, the user's security context accumulated too many security IDs.
 ERROR_LOGON_TYPE_NOT_GRANTED←1385    ⍝ Logon failure: the user has not been granted the requested logon type at this computer.
 ERROR_NT_CROSS_ENCRYPTION_REQUIRED←1386⍝ A cross-encrypted password is necessary to change a user password.
 ERROR_NO_SUCH_MEMBER←1387            ⍝ A member could not be added to or removed from the local group because the member does not exist.
 ERROR_INVALID_MEMBER←1388            ⍝ A new member could not be added to a local group because the member has the wrong account type.
 ERROR_TOO_MANY_SIDS←1389             ⍝ Too many security IDs have been specified.
 ERROR_LM_CROSS_ENCRYPTION_REQUIRED←1390⍝ A cross-encrypted password is necessary to change this user password.
 ERROR_NO_INHERITANCE←1391            ⍝ Indicates an ACL contains no inheritable components.
 ERROR_FILE_CORRUPT←1392              ⍝ The file or directory is corrupted and unreadable.
 ERROR_DISK_CORRUPT←1393              ⍝ The disk structure is corrupted and unreadable.
 ERROR_NO_USER_SESSION_KEY←1394       ⍝ There is no user session key for the specified logon session.
 ERROR_LICENSE_QUOTA_EXCEEDED←1395    ⍝ The service being accessed is licensed for a particular number of connections.
 ERROR_WRONG_TARGET_NAME←1396         ⍝ Logon Failure: The target account name is incorrect.
 ERROR_MUTUAL_AUTH_FAILED←1397        ⍝ Mutual Authentication failed.
 ERROR_TIME_SKEW←1398                 ⍝ There is a time and/or date difference between the client and server.
 ERROR_CURRENT_DOMAIN_NOT_ALLOWED←1399⍝ This operation can not be performed on the current domain.
 ERROR_INVALID_WINDOW_HANDLE←1400     ⍝ Invalid window handle.
 ERROR_INVALID_MENU_HANDLE←1401       ⍝ Invalid menu handle.
 ERROR_INVALID_CURSOR_HANDLE←1402     ⍝ Invalid cursor handle.
 ERROR_INVALID_ACCEL_HANDLE←1403      ⍝ Invalid accelerator table handle.
 ERROR_INVALID_HOOK_HANDLE←1404       ⍝ Invalid hook handle.
 ERROR_INVALID_DWP_HANDLE←1405        ⍝ Invalid handle to a multiple-window position structure.
 ERROR_TLW_WITH_WSCHILD←1406          ⍝ Cannot create a top-level child window.
 ERROR_CANNOT_FIND_WND_CLASS←1407     ⍝ Cannot find window class.
 ERROR_WINDOW_OF_OTHER_THREAD←1408    ⍝ Invalid window; it belongs to other thread.
 ERROR_HOTKEY_ALREADY_REGISTERED←1409 ⍝ Hot key is already registered.
 ERROR_CLASS_ALREADY_EXISTS←1410      ⍝ Class already exists.
 ERROR_CLASS_DOES_NOT_EXIST←1411      ⍝ Class does not exist.
 ERROR_CLASS_HAS_WINDOWS←1412         ⍝ Class still has open windows.
 ERROR_INVALID_INDEX←1413             ⍝ Invalid index.
 ERROR_INVALID_ICON_HANDLE←1414       ⍝ Invalid icon handle.
 ERROR_PRIVATE_DIALOG_INDEX←1415      ⍝ Using private DIALOG window words.
 ERROR_LISTBOX_ID_NOT_FOUND←1416      ⍝ The list box identifier was not found.
 ERROR_NO_WILDCARD_CHARACTERS←1417    ⍝ No wildcards were found.
 ERROR_CLIPBOARD_NOT_OPEN←1418        ⍝ Thread does not have a clipboard open.
 ERROR_HOTKEY_NOT_REGISTERED←1419     ⍝ Hot key is not registered.
 ERROR_WINDOW_NOT_DIALOG←1420         ⍝ The window is not a valid dialog window.
 ERROR_CONTROL_ID_NOT_FOUND←1421      ⍝ Control ID not found.
 ERROR_INVALID_COMBOBOX_MESSAGE←1422  ⍝ Invalid message for a combo box because it does not have an edit control.
 ERROR_WINDOW_NOT_COMBOBOX←1423       ⍝ The window is not a combo box.
 ERROR_INVALID_EDIT_HEIGHT←1424       ⍝ Height must be less than 256.
 ERROR_DC_NOT_FOUND←1425              ⍝ Invalid device context (DC) handle.
 ERROR_INVALID_HOOK_FILTER←1426       ⍝ Invalid hook procedure type.
 ERROR_INVALID_FILTER_PROC←1427       ⍝ Invalid hook procedure.
 ERROR_HOOK_NEEDS_HMOD←1428           ⍝ Cannot set nonlocal hook without a module handle.
 ERROR_GLOBAL_ONLY_HOOK←1429          ⍝ This hook procedure can only be set globally.
 ERROR_JOURNAL_HOOK_SET←1430          ⍝ The journal hook procedure is already installed.
 ERROR_HOOK_NOT_INSTALLED←1431        ⍝ The hook procedure is not installed.
 ERROR_INVALID_LB_MESSAGE←1432        ⍝ Invalid message for single-selection list box.
 ERROR_SETCOUNT_ON_BAD_LB←1433        ⍝ LB_SETCOUNT sent to non-lazy list box.
 ERROR_LB_WITHOUT_TABSTOPS←1434       ⍝ This list box does not support tab stops.
 ERROR_DESTROY_OBJECT_OF_OTHER_THREAD←1435⍝ Cannot destroy object created by another thread.
 ERROR_CHILD_WINDOW_MENU←1436         ⍝ Child windows cannot have menus.
 ERROR_NO_SYSTEM_MENU←1437            ⍝ The window does not have a system menu.
 ERROR_INVALID_MSGBOX_STYLE←1438      ⍝ Invalid message box style.
 ERROR_INVALID_SPI_VALUE←1439         ⍝ Invalid system-wide (SPI_*) parameter.
 ERROR_SCREEN_ALREADY_LOCKED←1440     ⍝ Screen already locked.
 ERROR_HWNDS_HAVE_DIFF_PARENT←1441    ⍝ All handles to windows in a multiple-window position structure must have the same parent.
 ERROR_NOT_CHILD_WINDOW←1442          ⍝ The window is not a child window.
 ERROR_INVALID_GW_COMMAND←1443        ⍝ Invalid GW_* command.
 ERROR_INVALID_THREAD_ID←1444         ⍝ Invalid thread identifier.
 ERROR_NON_MDICHILD_WINDOW←1445       ⍝ Cannot process a message from a window that is not a multiple document interface (MDI) window.
 ERROR_POPUP_ALREADY_ACTIVE←1446      ⍝ Popup menu already active.
 ERROR_NO_SCROLLBARS←1447             ⍝ The window does not have scroll bars.
 ERROR_INVALID_SCROLLBAR_RANGE←1448   ⍝ Scroll bar range cannot be greater than MAXLONG.
 ERROR_INVALID_SHOWWIN_COMMAND←1449   ⍝ Cannot show or remove the window in the way specified.
 ERROR_NO_SYSTEM_RESOURCES←1450       ⍝ Insufficient system resources exist to complete the requested service.
 ERROR_NONPAGED_SYSTEM_RESOURCES←1451 ⍝ Insufficient system resources exist to complete the requested service.
 ERROR_PAGED_SYSTEM_RESOURCES←1452    ⍝ Insufficient system resources exist to complete the requested service.
 ERROR_WORKING_SET_QUOTA←1453         ⍝ Insufficient quota to complete the requested service.
 ERROR_PAGEFILE_QUOTA←1454            ⍝ Insufficient quota to complete the requested service.
 ERROR_COMMITMENT_LIMIT←1455          ⍝ The paging file is too small for this operation to complete.
 ERROR_MENU_ITEM_NOT_FOUND←1456       ⍝ A menu item was not found.
 ERROR_INVALID_KEYBOARD_HANDLE←1457   ⍝ Invalid keyboard layout handle.
 ERROR_HOOK_TYPE_NOT_ALLOWED←1458     ⍝ Hook type not allowed.
 ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION←1459⍝ This operation requires an interactive window station.
 ERROR_TIMEOUT←1460                   ⍝ This operation returned because the timeout period expired.
 ERROR_INVALID_MONITOR_HANDLE←1461    ⍝ Invalid monitor handle.
 ERROR_EVENTLOG_FILE_CORRUPT←1500     ⍝ The event log file is corrupted.
 ERROR_EVENTLOG_CANT_START←1501       ⍝ No event log file could be opened, so the event logging service did not start.
 ERROR_LOG_FILE_FULL←1502             ⍝ The event log file is full.
 ERROR_EVENTLOG_FILE_CHANGED←1503     ⍝ The event log file has changed between read operations.
 ERROR_INSTALL_SERVICE_FAILURE←1601   ⍝ The Windows Installer Service could not be accessed.
 ERROR_INSTALL_USEREXIT←1602          ⍝ User cancelled installation.
 ERROR_INSTALL_FAILURE←1603           ⍝ Fatal error during installation.
 ERROR_INSTALL_SUSPEND←1604           ⍝ Installation suspended, incomplete.
 ERROR_UNKNOWN_PRODUCT←1605           ⍝ This action is only valid for products that are currently installed.
 ERROR_UNKNOWN_FEATURE←1606           ⍝ Feature ID not registered.
 ERROR_UNKNOWN_COMPONENT←1607         ⍝ Component ID not registered.
 ERROR_UNKNOWN_PROPERTY←1608          ⍝ Unknown property.
 ERROR_INVALID_HANDLE_STATE←1609      ⍝ Handle is in an invalid state.
 ERROR_BAD_CONFIGURATION←1610         ⍝ The configuration data for this product is corrupt.
 ERROR_INDEX_ABSENT←1611              ⍝ Component qualifier not present.
 ERROR_INSTALL_SOURCE_ABSENT←1612     ⍝ The installation source for this product is not available.
 ERROR_INSTALL_PACKAGE_VERSION←1613   ⍝ This installation package cannot be installed by the Windows Installer service.
 ERROR_PRODUCT_UNINSTALLED←1614       ⍝ Product is uninstalled.
 ERROR_BAD_QUERY_SYNTAX←1615          ⍝ SQL query syntax invalid or unsupported.
 ERROR_INVALID_FIELD←1616             ⍝ Record field does not exist.
 ERROR_DEVICE_REMOVED←1617            ⍝ The device has been removed.
 ERROR_INSTALL_ALREADY_RUNNING←1618   ⍝ Another installation is already in progress.
 ERROR_INSTALL_PACKAGE_OPEN_FAILED←1619⍝ This installation package could not be opened.
 ERROR_INSTALL_PACKAGE_INVALID←1620   ⍝ This installation package could not be opened.
 ERROR_INSTALL_UI_FAILURE←1621        ⍝ There was an error starting the Windows Installer service user interface.
 ERROR_INSTALL_LOG_FAILURE←1622       ⍝ Error opening installation log file.
 ERROR_INSTALL_LANGUAGE_UNSUPPORTED←1623⍝ The language of this installation package is not supported by your system.
 ERROR_INSTALL_TRANSFORM_FAILURE←1624 ⍝ Error applying transforms.
 ERROR_INSTALL_PACKAGE_REJECTED←1625  ⍝ This installation is forbidden by system policy.
 ERROR_FUNCTION_NOT_CALLED←1626       ⍝ Function could not be executed.
 ERROR_FUNCTION_FAILED←1627           ⍝ Function failed during execution.
 ERROR_INVALID_TABLE←1628             ⍝ Invalid or unknown table specified.
 ERROR_DATATYPE_MISMATCH←1629         ⍝ Data supplied is of wrong type.
 ERROR_UNSUPPORTED_TYPE←1630          ⍝ Data of this type is not supported.
 ERROR_CREATE_FAILED←1631             ⍝ The Windows Installer service failed to start.
 ERROR_INSTALL_TEMP_UNWRITABLE←1632   ⍝ The Temp folder is on a drive that is full or is inaccessible.
 ERROR_INSTALL_PLATFORM_UNSUPPORTED←1633 ⍝ This installation package is not supported by this processor type.
 ERROR_INSTALL_NOTUSED←1634           ⍝ Component not used on this computer.
 ERROR_PATCH_PACKAGE_OPEN_FAILED←1635 ⍝ This patch package could not be opened.
 ERROR_PATCH_PACKAGE_INVALID←1636     ⍝ This patch package could not be opened.
 ERROR_PATCH_PACKAGE_UNSUPPORTED←1637 ⍝ This patch package cannot be processed by the Windows Installer service.
 ERROR_PRODUCT_VERSION←1638           ⍝ Another version of this product is already installed.
 ERROR_INVALID_COMMAND_LINE←1639      ⍝ Invalid command line argument.
 ERROR_INSTALL_REMOTE_DISALLOWED←1640 ⍝ Only administrators have permission to add, remove, or configure server software during a Terminal services remote session.
 ERROR_SUCCESS_REBOOT_INITIATED←1641  ⍝ The requested operation completed successfully.
 ERROR_PATCH_TARGET_NOT_FOUND←1642    ⍝ The upgrade patch cannot be installed.
 ERROR_PATCH_PACKAGE_REJECTED←1643    ⍝ The patch package is not permitted by software restriction policy.
 ERROR_INSTALL_TRANSFORM_REJECTED←1644⍝ One or more customizations are not permitted by software restriction policy.
     ⍝ Windows Sockets definitions of regular Microsoft C Error Constants
 WSAEINTR←10004  ⍝ 10004 Unterbrochener Systemaufruf
 WSAEBADF←10009  ⍝ 10009 Falsche Dateinummer
 WSAEACCES←10013 ⍝ 10060 Berechtigung verweigert
 WSAEFAULT←10014 ⍝ 10013 Falsche Adresse
 WSAEINVAL←10022 ⍝ 10022 Ungültiges Argument
 WSAEMFILE←10024 ⍝ 10023 Zu viele offene Dateien
     ⍝ Windows Sockets definitions of regular Berkeley Error Constants
 WSAEWOULDBLOCK←10035     ⍝ 10010 Vorgang würde blockieren
 WSAEINPROGRESS←10036     ⍝ 10011 Vorgang läuft
 WSAEALREADY←10037        ⍝ 10012 Vorgang läuft bereits
 WSAENOTSOCK←10038        ⍝ 10026 Socket-Vorgang auf Nicht-Socket
 WSAEDESTADDRREQ←10039    ⍝ 10014 Zieladresse erforderlich
 WSAEMSGSIZE←10040        ⍝ 10015 Nachricht zu lang
 WSAEPROTOTYPE←10041      ⍝ 10044 Falscher Protokolltyp für Socket
 WSAENOPROTOOPT←10042     ⍝ 10036 Falsche Protokolloption
 WSAEPROTONOSUPPORT←10043 ⍝ 10031 Protokoll nicht unterstützt
 WSAESOCKTNOSUPPORT←10044 ⍝ 10030 Sockettyp nicht unterstützt
 WSAEOPNOTSUPP←10045      ⍝ 10045 Vorgang nicht unterstützt von Socket
 WSAEPFNOSUPPORT←10046    ⍝ 10016 Protokollfamilie nicht unterstützt
 WSAEAFNOSUPPORT←10047    ⍝ 10029 Adressfamilie nicht unterstützt von Protokollfamilie
 WSAEADDRINUSE←10048      ⍝ 10028 Adresse wird bereits verwendet
 WSAEADDRNOTAVAIL←10049   ⍝ 10122 Angeforderte Adresse kann nicht zugewiesen werden
 WSAENETDOWN←10050        ⍝ 10039 Netzwerkausfall
 WSAENETUNREACH←10051     ⍝ 10046 ICMP-Netzwerk nicht erreichbar
 WSAENETRESET←10052       ⍝ 10040 Netzwerk wurde zurückgesetzt
 WSAECONNABORTED←10053    ⍝ 10038 Software hat Verbindungsabbruch verursacht
 WSAECONNRESET←10054      ⍝ 10037 Verbindung von Peer zurückgesetzt
 WSAENOBUFS←10055         ⍝ 10127 Kein Pufferraum verfügbar
 WSAEISCONN←10056         ⍝ 10034 Socket ist bereits verbunden
 WSAENOTCONN←10057        ⍝ 10035 Socket ist nicht verbunden
 WSAESHUTDOWN←10058       ⍝ 10003 Kein Senden möglich nach Herunterfahren des Socket
 WSAETOOMANYREFS←10059    ⍝ 10047 Zu viele Verweise
 WSAETIMEDOUT←10060       ⍝ 10033 Verbindung wegen Zeitüberschreitung abgebrochen
 WSAECONNREFUSED←10061    ⍝ 10135 Verbindung abgelehnt
 WSAELOOP←10062           ⍝ Cannot translate name
 WSAENAMETOOLONG←10063    ⍝ 10000 Name zu lang
 WSAEHOSTDOWN←10064       ⍝ 10042 Host ist ausgefallen
 WSAEHOSTUNREACH←10065    ⍝ 10043 Host nicht erreichbar
 WSAENOTEMPTY←10066       ⍝ 10017 Verzeichnis nicht leer
 WSAEPROCLIM←10067        ⍝ 10018 EPROCLIM zurückgegeben
 WSAEUSERS←10068          ⍝ 10019 EUSERS zurückgegeben
 WSAEDQUOT←10069          ⍝ 10020 Datenträgerkontingent überschritten
 WSAESTALE←10070          ⍝ 10021 ESTALE zurückgegeben
 WSAEREMOTE←10071         ⍝ 10025 Dies ist ein Remote-Objekt
     ⍝ Extended Windows Sockets Error Constants definitions
 WSASYSNOTREADY←10091         ⍝ 10001 System nicht bereit
 WSAVERNOTSUPPORTED←10092     ⍝ 10002 Version wird nicht unterstützt
 WSANOTINITIALISED←10093      ⍝ 10148 Sockets-Bibliothek nicht initalisiert
 WSAEDISCON←10101             ⍝ Returned by WSARecv or WSARecvFrom to indicate the remote party has initiated a graceful shutdown sequence
 WSAENOMORE←10102             ⍝ No more results can be returned by WSALookupServiceNext
 WSAECANCELLED←10103          ⍝ A call to WSALookupServiceEnd was made while this call was still processing
 WSAEINVALIDPROCTABLE←10104   ⍝ The procedure call table is invalid
 WSAEINVALIDPROVIDER←10105    ⍝ The requested service provider is invalid
 WSAEPROVIDERFAILEDINIT←10106 ⍝ The requested service provider could not be loaded or initialized
 WSASYSCALLFAILURE←10107      ⍝ A system call that should never fail has failed
 WSASERVICE_NOT_FOUND←10108   ⍝ No such service is known
 WSATYPE_NOT_FOUND←10109      ⍝ Class Type not found
 WSA_E_NO_MORE←10110          ⍝ No more results can be returned by WSALookupServiceNext
 WSA_E_CANCELLED←10111        ⍝ A call to WSALookupServiceEnd was made while this call was still processing
 WSAEREFUSED←10112            ⍝ 10041 Verbindung abgelehnt
     ⍝ Error return codes from gethostbyname() and gethostbyaddr()
 WSAHOST_NOT_FOUND←11001 ⍝ 10005 Host nicht gefunden
 WSATRY_AGAIN←11002      ⍝ 10006 Versuchen Sie es erneut
 WSANO_RECOVERY←11003    ⍝ 10007 Nichtbehebbarer Fehler
 WSANO_ADDRESS←11004     ⍝ 10114 Gegebener Protokollname nicht eindeutig
     ⍝ Define QOS related error return codes
 WSA_QOS_RECEIVERS←11005          ⍝ at least one Reserve has arrived
 WSA_QOS_SENDERS←11006            ⍝ at least one Path has arrived
 WSA_QOS_NO_SENDERS←11007         ⍝ there are no senders
 WSA_QOS_NO_RECEIVERS←11008       ⍝ there are no receivers
 WSA_QOS_REQUEST_CONFIRMED←11009  ⍝ Reserve has been confirmed
 WSA_QOS_ADMISSION_FAILURE←11010  ⍝ error due to lack of resources
 WSA_QOS_POLICY_FAILURE←11011     ⍝ rejected for administrative reasons - bad credentials
 WSA_QOS_BAD_STYLE←11012          ⍝ unknown or conflicting style
 WSA_QOS_BAD_OBJECT←11013         ⍝ problem with some part of the filterspec or providerspecific buffer in general
 WSA_QOS_TRAFFIC_CTRL_ERROR←11014 ⍝ problem with some part of the flowspec
 WSA_QOS_GENERIC_ERROR←11015      ⍝ general error
 INTERNET_ERROR_BASE←12000                      ⍝ INTERNET_ERROR_BASE
 ERROR_INTERNET_OUT_OF_HANDLES←12001            ⍝ Es können keine weiteren Internetzugriffsnummern reserviert werden.
 ERROR_INTERNET_TIMEOUT←12002                   ⍝ Das Zeitlimit für den Vorgang wurde erreicht.
 ERROR_INTERNET_EXTENDED_ERROR←12003            ⍝ Der Server lieferte erweiterte Informationen.
 ERROR_INTERNET_INTERNAL_ERROR←12004            ⍝ In den Microsoft-Interneterweiterungen ist ein interner Fehler aufgetreten.
 ERROR_INTERNET_INVALID_URL←12005               ⍝ Der URL ist ungültig.
 ERROR_INTERNET_UNRECOGNIZED_SCHEME←12006       ⍝ Der URL verwendet kein bekanntes Protokoll.
 ERROR_INTERNET_NAME_NOT_RESOLVED←12007         ⍝ Der Servername oder die Serveradresse konnte nicht verarbeitet werden.
 ERROR_INTERNET_PROTOCOL_NOT_FOUND←12008        ⍝ Es wurde kein Protokoll mit den erforderlichen Funktionsmerkmalen gefunden.
 ERROR_INTERNET_INVALID_OPTION←12009            ⍝ Die Option ist ungültig.
 ERROR_INTERNET_BAD_OPTION_LENGTH←12010         ⍝ Die Länge entspricht nicht dem Optionstyp.
 ERROR_INTERNET_OPTION_NOT_SETTABLE←12011       ⍝ Der Optionswert konnte nicht festgelegt werden.
 ERROR_INTERNET_SHUTDOWN←12012                  ⍝ Die Unterstützung für die Microsoft-Interneterweiterung wurde beendet.
 ERROR_INTERNET_INCORRECT_USER_NAME←12013       ⍝ Der Benutzername war unzulässig.
 ERROR_INTERNET_INCORRECT_PASSWORD←12014        ⍝ Das Kennwort war unzulässig.
 ERROR_INTERNET_LOGIN_FAILURE←12015             ⍝ Die Anmeldeanforderung wurde verweigert.
 ERROR_INTERNET_OPERATION_CANCELLED←12017       ⍝ Der Vorgang wurde abgebrochen.
 ERROR_INTERNET_INCORRECT_HANDLE_TYPE←12018     ⍝ Der Typ der gelieferten Zugriffsnummer entspricht nicht dem angeforderten Vorgang.
 ERROR_INTERNET_INCORRECT_HANDLE_STATE←12019    ⍝ Der Status der Zugriffsnummer entspricht nicht dem angeforderten Vorgang.
 ERROR_INTERNET_NOT_PROXY_REQUEST←12020         ⍝ Die Anforderung ist für eine Proxy-Sitzung ungültig.
 ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND←12021  ⍝ Der Registrierungswert wurde nicht gefunden.
 ERROR_INTERNET_BAD_REGISTRY_PARAMETER←12022    ⍝ Der Registrierungsparameter ist falsch.
 ERROR_INTERNET_NO_DIRECT_ACCESS←12023          ⍝ Der direkte Internetzugriff ist nicht verfügbar.
 ERROR_INTERNET_NO_CONTEXT←12024                ⍝ Es wurde kein Kontextwert bereitgestellt.
 ERROR_INTERNET_NO_CALLBACK←12025               ⍝ Eine Statusrückmeldung blieb aus.
 ERROR_INTERNET_REQUEST_PENDING←12026           ⍝ Es stehen noch Anforderungen an.
 ERROR_INTERNET_INCORRECT_FORMAT←12027          ⍝ Die Informationen liegen im falschen Format vor.
 ERROR_INTERNET_ITEM_NOT_FOUND←12028            ⍝ Das angeforderte Objekt wurde nicht gefunden.
 ERROR_INTERNET_CANNOT_CONNECT←12029            ⍝ Die Serververbindung konnte nicht hergestellt werden.
 ERROR_INTERNET_CONNECTION_ABORTED←12030        ⍝ Die Serververbindung wurde aufgrund eines Fehlers beendet.
 ERROR_INTERNET_CONNECTION_RESET←12031          ⍝ Die Serververbindung für diese Webseite wurde getrennt.
 ERROR_INTERNET_FORCE_RETRY←12032               ⍝ Der Vorgang muss wiederholt werden
 ERROR_INTERNET_INVALID_PROXY_REQUEST←12033     ⍝ Die Proxyanforderung ist ungültig
 ERROR_INTERNET_NEED_UI←12034                   ⍝ Es ist ein Benutzereingriff erforderlich, um den Vorgang fertig zu stellen
 ERROR_INTERNET_HANDLE_EXISTS←12036             ⍝ Der Handle ist bereits vorhanden
 ERROR_INTERNET_SEC_CERT_DATE_INVALID←12037     ⍝ Das Datum des Zertifikats ist ungültig oder das Zertifikat ist abgelaufen
 ERROR_INTERNET_SEC_CERT_CN_INVALID←12038       ⍝ Der Hostname des Zertifikats ist ungültig oder stimmt nicht überein
 ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR←12039    ⍝ Eine Redirect-Anforderung ändert eine nicht sichere in eine sichere Verbindung
 ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR←12040    ⍝ Eine Redirect-Anforderung ändert eine sichere in eine nicht sichere Verbindung
 ERROR_INTERNET_MIXED_SECURITY←12041            ⍝ Gemischte sichere und nicht sichere Verbindungen
 ERROR_INTERNET_CHG_POST_IS_NON_SECURE←12042    ⍝ Ändern zu einer nicht sicheren Bereitstellung
 ERROR_INTERNET_POST_IS_NON_SECURE←12043        ⍝ Daten werden über eine nicht sichere Verbindung bereitgestellt
 ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED←12044   ⍝ Für die Client-Authentifikation wird ein Zertifikat benötigt
 ERROR_INTERNET_INVALID_CA←12045                ⍝ Die Zertifizierungsagentur ist ungültig oder fehlerhaft
 ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP←12046     ⍝ Die Client-Authentifikation ist nicht ordnungsgemäß installiert
 ERROR_INTERNET_ASYNC_THREAD_FAILED←12047       ⍝ In einem asynchronen Wininet-Thread ist ein Fehler aufgetreten.
 ERROR_INTERNET_REDIRECT_SCHEME_CHANGE←12048    ⍝ Das Protokollschema wurde während eines Redirect-Vorgangs geändert
 ERROR_INTERNET_DIALOG_PENDING←12049            ⍝ Einige Vorgänge warten auf eine erneute Ausführung
 ERROR_INTERNET_RETRY_DIALOG←12050              ⍝ Der Vorgang muss wiederholt werden
 ERROR_INTERNET_NO_CACHE_CONTAINER←12051        ⍝ Keine weiteren Cachecontainer verfügbar
 ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR←12052   ⍝ Eine Überprüfung der Sicherheitszone hat ergeben, dass der Vorgang wiederholt werden muss.
 ERROR_INTERNET_INSERT_CDROM←12053              ⍝ Legen sie die CD mit der gewünschten Website ein
 ERROR_INTERNET_INVALID_OPERATION←12106         ⍝ Der angeforderte Vorgang ist ungültig
 ERROR_FTP_TRANSFER_IN_PROGRESS←12110           ⍝ Für diese Sitzung liegt bereits eine FTP-Anforderung vor.
 ERROR_FTP_DROPPED←12111                        ⍝ Die FTP-Sitzung wurde beendet.
 ERROR_FTP_NO_PASSIVE_MODE←12112                ⍝ Passiver Modus für FTP ist nicht verfügbar
 ERROR_GOPHER_PROTOCOL_ERROR←12130              ⍝ Im Gopher-Protokoll ist ein Fehler aufgetreten.
 ERROR_GOPHER_NOT_FILE←12131                    ⍝ Der Bezeichner muss sich auf eine Datei beziehen.
 ERROR_GOPHER_DATA_ERROR←12132                  ⍝ Bei der Analyse der Daten wurde ein Fehler festgestellt.
 ERROR_GOPHER_END_OF_DATA←12133                 ⍝ Es sind keine weiteren Daten vorhanden.
 ERROR_GOPHER_INVALID_LOCATOR←12134             ⍝ Der Bezeichner ist ungültig.
 ERROR_GOPHER_INCORRECT_LOCATOR_TYPE←12135      ⍝ Der Bezeichnertyp entspricht nicht dem Vorgang.
 ERROR_GOPHER_NOT_GOPHER_PLUS←12136             ⍝ Die Anforderung muss sich auf ein Gopher+ Objekt beziehen.
 ERROR_GOPHER_ATTRIBUTE_NOT_FOUND←12137         ⍝ Das angeforderte Attribut wurde nicht gefunden.
 ERROR_GOPHER_UNKNOWN_LOCATOR←12138             ⍝ Der Bezeichnertyp wurde nicht erkannt.
 ERROR_HTTP_HEADER_NOT_FOUND←12150              ⍝ Der angeforderte Header wurde nicht gefunden.
 ERROR_HTTP_DOWNLEVEL_SERVER←12151              ⍝ Der Server unterstützt die angeforderte Protokollschicht nicht.
 ERROR_HTTP_INVALID_SERVER_RESPONSE←12152       ⍝ Der Server lieferte eine ungültige oder unbekannte Rückmeldung.
 ERROR_HTTP_INVALID_HEADER←12153                ⍝ Der angegebene HTTP-Header ist ungültig.
 ERROR_HTTP_INVALID_QUERY_REQUEST←12154         ⍝ Die Anforderung eines HTTP-Headers ist ungültig.
 ERROR_HTTP_HEADER_ALREADY_EXISTS←12155         ⍝ Der HTTP-Header ist bereits vorhanden.
 ERROR_HTTP_REDIRECT_FAILED←12156               ⍝ Die HTTP-Redirect-Anforderung konnte nicht ausgeführt werden.
 ERROR_INTERNET_SECURITY_CHANNEL_ERROR←12157    ⍝ Im Support des sicheren Channels ist ein Fehler aufgetreten
 ERROR_INTERNET_UNABLE_TO_CACHE_FILE←12158      ⍝ Die Datei konnte nicht in den Zwischenspeicher geschrieben werden
 ERROR_INTERNET_TCPIP_NOT_INSTALLED←12159       ⍝ Das TCP/IP-Protokoll ist nicht ordnungsgemäß installiert
 ERROR_HTTP_NOT_REDIRECTED←12160                ⍝ Die HTTP-Anforderung wurde nicht umgelenkt.
 ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION←12161     ⍝ Ein Cookie vom Server muss vom Benutzer bestätigt werden
 ERROR_HTTP_COOKIE_DECLINED←12162               ⍝ Die Annahme eines Cookies vom Server wurde verweigert
 ERROR_INTERNET_DISCONNECTED←12163              ⍝ Der Computer ist nicht mit dem Netzwerk verbunden
 ERROR_INTERNET_SERVER_UNREACHABLE←12164        ⍝ Der Server ist nicht erreichbar
 ERROR_INTERNET_PROXY_SERVER_UNREACHABLE←12165  ⍝ Der Proxyserver ist nicht erreichbar
 ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT←12166     ⍝ Das Proxy-Autokonfigurationsskript ist fehlerhaft
 ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT←12167 ⍝ Download des Proxy-Autokonfigurationsskripts ist nicht möglich
 ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION←12168   ⍝ Die HTTP-Redirect-Anforderung muss durch den Benutzer bestätigt werden
 ERROR_INTERNET_SEC_INVALID_CERT←12169          ⍝ Das angegebene Zertifikat ist ungültig
 ERROR_INTERNET_SEC_CERT_REVOKED←12170          ⍝ Das angegebene Zertifikat wurde widerrufen
 ERROR_INTERNET_FAILED_DUETOSECURITYCHECK←12171 ⍝ Das Herstellen der Wählverbindung ist gescheitert...
 ERROR_SUCCESS_CHIPCARD←IntHex'9000' ⍝ Alternative chipcard code for "Operation completed successfully".
 Base←IntHex'80090000'           ⍝ NTE error base
 NTE_BAD_UID←Base+1              ⍝ Bad UID.
 NTE_BAD_HASH←Base+2             ⍝ Bad Hash.
 NTE_BAD_KEY←Base+3              ⍝ Bad Key.
 NTE_BAD_LEN←Base+4              ⍝ Bad Length.
 NTE_BAD_DATA←Base+5             ⍝ Bad Data.
 NTE_BAD_SIGNATURE←Base+6        ⍝ Invalid Signature.
 NTE_BAD_VER←Base+7              ⍝ Bad Version of provider.
 NTE_BAD_ALGID←Base+8            ⍝ Invalid algorithm specified.
 NTE_BAD_FLAGS←Base+9            ⍝ Invalid flags specified.
 NTE_BAD_TYPE←Base+10            ⍝ Invalid type specified.
 NTE_BAD_KEY_STATE←Base+11       ⍝ Key not valid for use in specified state.
 NTE_BAD_HASH_STATE←Base+12      ⍝ Hash not valid for use in specified state.
 NTE_NO_KEY←Base+13              ⍝ Key does not exist.
 NTE_NO_MEMORY←Base+14           ⍝ Insufficient memory available for the operation.
 NTE_EXISTS←Base+15              ⍝ Object already exists.
 NTE_PERM←Base+16                ⍝ Access denied.
 NTE_NOT_FOUND←Base+17           ⍝ Object was not found.
 NTE_DOUBLE_ENCRYPT←Base+18      ⍝ Data already encrypted.
 NTE_BAD_PROVIDER←Base+19        ⍝ Invalid provider specified.
 NTE_BAD_PROV_TYPE←Base+20       ⍝ Invalid provider type specified.
 NTE_BAD_PUBLIC_KEY←Base+21      ⍝ Provider's public key is invalid.
 NTE_BAD_KEYSET←Base+22          ⍝ Keyset does not exist
 NTE_PROV_TYPE_NOT_DEF←Base+23   ⍝ Provider type not defined.
 NTE_PROV_TYPE_ENTRY_BAD←Base+24 ⍝ Provider type as registered is invalid.
 NTE_KEYSET_NOT_DEF←Base+25      ⍝ The keyset is not defined.
 NTE_KEYSET_ENTRY_BAD←Base+26    ⍝ Keyset as registered is invalid.
 NTE_PROV_TYPE_NO_MATCH←Base+27  ⍝ Provider type does not match registered value.
 NTE_SIGNATURE_FILE_BAD←Base+28  ⍝ The digital signature file is corrupt.
 NTE_PROVIDER_DLL_FAIL←Base+29   ⍝ Provider DLL failed to initialize correctly.
 NTE_PROV_DLL_NOT_FOUND←Base+30  ⍝ Provider DLL could not be found.
 NTE_BAD_KEYSET_PARAM←Base+31    ⍝ The Keyset parameter is invalid.
 NTE_FAIL←Base+32                ⍝ An internal error occurred.
 NTE_SYS_ERR←Base+33             ⍝ A base error occurred.
 Base←IntHex'80091000'                    ⍝ Crypt error base 1
 CRYPT_E_MSG_ERROR←Base+1                 ⍝ An error was encountered doing a cryptographic message operation.
 CRYPT_E_UNKNOWN_ALGO←Base+2              ⍝ The cryptographic algorithm is unknown.
 CRYPT_E_OID_FORMAT←Base+3                ⍝ The object identifier is badly formatted.
 CRYPT_E_INVALID_MSG_TYPE←Base+4          ⍝ The message type is invalid.
 CRYPT_E_UNEXPECTED_ENCODING←Base+5       ⍝ The message is not encoded as expected.
 CRYPT_E_AUTH_ATTR_MISSING←Base+6         ⍝ The message does not contain an expected authenticated attribute.
 CRYPT_E_HASH_VALUE←Base+7                ⍝ The hash value is not correct.
 CRYPT_E_INVALID_INDEX←Base+8             ⍝ The index value is not valid.
 CRYPT_E_ALREADY_DECRYPTED←Base+9         ⍝ The message content has already been decrypted.
 CRYPT_E_NOT_DECRYPTED←Base+10            ⍝ The message content has not been decrypted yet.
 CRYPT_E_RECIPIENT_NOT_FOUND←Base+11      ⍝ The enveloped-data message does not contain the specified recipient.
 CRYPT_E_CONTROL_TYPE←Base+12             ⍝ The control type is not valid.
 CRYPT_E_ISSUER_SERIALNUMBER←Base+13      ⍝ The issuer and/or serial number are/is not valid.
 CRYPT_E_SIGNER_NOT_FOUND←Base+14         ⍝ The original signer is not found.
 CRYPT_E_ATTRIBUTES_MISSING←Base+15       ⍝ The message does not contain the requested attributes.
 CRYPT_E_STREAM_MSG_NOT_READY←Base+16     ⍝ The steamed message is note yet able to return the requested data.
 CRYPT_E_STREAM_INSUFFICIENT_DATA←Base+17 ⍝ The streamed message needs more data before the decode can complete.
 Base←IntHex'80092000'                      ⍝ Crypt error base 2
 CRYPT_E_BAD_LEN←Base+1                     ⍝ The length specified for the output data was insufficient.
 CRYPT_E_BAD_ENCODE←Base+2                  ⍝ An error was encountered while encoding or decoding.
 CRYPT_E_FILE_ERROR←Base+3                  ⍝ An error occurred while reading or writing to the file
 CRYPT_E_NOT_FOUND←Base+4                   ⍝ The object or property wasn't found
 CRYPT_E_EXISTS←Base+5                      ⍝ The object or property already exists
 CRYPT_E_NO_PROVIDER←Base+6                 ⍝ No provider was specified for the store or object
 CRYPT_E_SELF_SIGNED←Base+7                 ⍝ The specified certificate is self signed.
 CRYPT_E_DELETED_PREV←Base+8                ⍝ The previous certificate or CRL context was deleted.
 CRYPT_E_NO_MATCH←Base+9                    ⍝ No match when trying to find the object.
 CRYPT_E_UNEXPECTED_MSG_TYPE←Base+10        ⍝ The type of the cryptographic message being decoded is different than what was expected.
 CRYPT_E_NO_KEY_PROPERTY←Base+11            ⍝ The certificate doesn't have a private key property
 CRYPT_E_NO_DECRYPT_CERT←Base+12            ⍝ No certificate was found having a private key property to use for decrypting.
 CRYPT_E_BAD_MSG←Base+13                    ⍝ Either, not a cryptographic message or incorrectly formatted.
 CRYPT_E_NO_SIGNER←Base+14                  ⍝ The signed message doesn't have a signer for the specified signer index
 CRYPT_E_PENDING_CLOSE←Base+15              ⍝ Final closure is pending until additional frees or closes.
 CRYPT_E_REVOKED←Base+16                    ⍝ The certificate or signature has been revoked
 CRYPT_E_NO_REVOCATION_DLL←Base+17          ⍝ No Dll or exported function was found to verify revocation.
 CRYPT_E_NO_REVOCATION_CHECK←Base+18        ⍝ The called function wasn't able to do a revocation check on the certificate or signature.
 CRYPT_E_REVOCATION_OFFLINE←Base+19         ⍝ Revocation server was offline, the called function could not complete the revocation check.
 CRYPT_E_NOT_IN_REVOCATION_DATABASE←Base+20 ⍝ The certificate or signature to be checked was not found in the revocation servers database.
 CRYPT_E_INVALID_NUMERIC_STRING←Base+32     ⍝ The string contains a non-numeric character.
 CRYPT_E_INVALID_PRINTABLE_STRING←Base+33   ⍝ The string contains a non-printable character.
 CRYPT_E_INVALID_IA5_STRING←Base+34         ⍝ The string contains a character not in the 7 bit ASCII character set.
 CRYPT_E_INVALID_X500_STRING←Base+35        ⍝ The string contains an invalid X500 name attribute key, oid, value or delimiter.
 CRYPT_E_NOT_CHAR_STRING←Base+36            ⍝ The dwValueType for the CERT_NAME_VALUE is not one of the character strings.
 CRYPT_E_FILERESIZED←Base+37                ⍝ The Put operation can not continue.  The file needs to be resized.  Signature already present.
 CRYPT_E_SECURITY_SETTINGS←Base+38          ⍝ The cryptography operation has failed due to a local security option setting.
 CRYPT_E_NO_VERIFY_USAGE_DLL←Base+39        ⍝ No DLL or exported function was found to verify subject usage.
 CRYPT_E_NO_VERIFY_USAGE_CHECK←Base+40      ⍝ The called function wasn't able to do a usage check on the subject.
 CRYPT_E_VERIFY_USAGE_OFFLINE←Base+41       ⍝ Since the server was offline, the called function wasn't able to complete the usage check.
 CRYPT_E_NOT_IN_CTL←Base+42                 ⍝ The subject was not found in a Certificate Trust List (CT'.
 CRYPT_E_NO_TRUSTED_SIGNER←Base+43          ⍝ No trusted signer was found to verify the signature of the message or trust list.
 Base←IntHex'80093100'          ⍝ ASN.1 Encoding/Decoding error base (Introduced in Win2000)
 CRYPT_E_ASN1_ERROR←Base+0      ⍝ ASN.1 Certificate encode/decode error code base
 CRYPT_E_ASN1_INTERNAL←Base+1   ⍝ ASN.1 internal encode or decode error
 CRYPT_E_ASN1_EOD←Base+2        ⍝ ASN.1 unexpected end of data
 CRYPT_E_ASN1_CORRUPT←Base+3    ⍝ ASN.1 corrupted data
 CRYPT_E_ASN1_LARGE←Base+4      ⍝ ASN.1 value too large
 CRYPT_E_ASN1_CONSTRAINT←Base+5 ⍝ ASN.1 constraint violated
 CRYPT_E_ASN1_MEMORY←Base+6     ⍝ ASN.1 out of memory
 CRYPT_E_ASN1_OVERFLOW←Base+7   ⍝ ASN.1 buffer overflow
 CRYPT_E_ASN1_BADPDU←Base+8     ⍝ ASN.1 function not supported for this PDU
 CRYPT_E_ASN1_BADARGS←Base+9    ⍝ ASN.1 bad arguments to function call
 CRYPT_E_ASN1_BADREAL←Base+10   ⍝ ASN.1 bad real value
 CRYPT_E_ASN1_BADTAG←Base+11    ⍝ ASN.1 bad tag value met
 CRYPT_E_ASN1_CHOICE←Base+12    ⍝ ASN.1 bad choice value
 CRYPT_E_ASN1_RULE←Base+13      ⍝ ASN.1 bad encoding rule
 CRYPT_E_ASN1_UTF8←Base+14      ⍝ ASN.1 bad Unicode (UTF8)
 CRYPT_E_ASN1_PDU_TYPE←Base+51  ⍝ ASN.1 bad PDU type
 CRYPT_E_ASN1_NYI←Base+52       ⍝ ASN.1 not yet implemented
 CRYPT_E_ASN1_EXTENDED←Base+257 ⍝ ASN.1 skipped unknown extension(s)
 CRYPT_E_ASN1_NOEOD←Base+258    ⍝ ASN.1 end of data expected
 Base←IntHex'80094000'               ⍝ CertSrv error base
 CERTSRV_E_BAD_REQUESTSUBJECT←Base+1 ⍝ The request subject name is invalid or too long.
 CERTSRV_E_NO_REQUEST←Base+2         ⍝ The request does not exist.
 CERTSRV_E_BAD_REQUESTSTATUS←Base+3  ⍝ The request's current status does not allow this operation.
 CERTSRV_E_PROPERTY_EMPTY←Base+4     ⍝ The requested property value is empty.
 Base←IntHex'80095000' ⍝ Jet error code base
 Base←IntHex'80096000'              ⍝ Trust error base
 TRUST_E_SYSTEM_ERROR←Base+1        ⍝ A system-level error occured while verifying trust.
 TRUST_E_NO_SIGNER_CERT←Base+2      ⍝ The certificate for the signer of the message is invalid or not found.
 TRUST_E_COUNTER_SIGNER←Base+3      ⍝ One of the counter signers was invalid.
 TRUST_E_CERT_SIGNATURE←Base+4      ⍝ The signature of the certificate can not be verified.
 TRUST_E_TIME_STAMP←Base+5          ⍝ The time stamp signer and or certificate could not be verified or is malformed.
 TRUST_E_BAD_DIGEST←Base+16         ⍝ The objects digest did not verify.
 TRUST_E_BASIC_CONSTRAINTS←Base+25  ⍝ The cerficates basic constraints are invalid or missing.
 TRUST_E_FINANCIAL_CRITERIA←Base+30 ⍝ The certificate does not meet or contain the Authenticode financial extensions.
 Base←IntHex'800B0000'                 ⍝ Certificate error base
 PERSIST_E_NOTSELFSIZING←Base+11       ⍝ This object does not read and write self-sizing data.
 TRUST_E_NOSIGNATURE←Base+256          ⍝ No signature was present in the subject.
 CERT_E_EXPIRED←Base+257               ⍝ A required certificate is not within its validity period
 CERT_E_VALIDITYPERIODNESTING←Base+258 ⍝ The validity periods of the certification chain do not nest correctly
 CERT_E_ROLE←Base+259                  ⍝ A certificate that can only be used as an end-entity is being used as a CA or visa versa
 CERT_E_PATHLENCONST←Base+260          ⍝ A path length constraint in the certification chain has been violated.
 CERT_E_CRITICAL←Base+261              ⍝ An extension of unknown type that is labeled 'critical' is present in a certificate.
 CERT_E_PURPOSE←Base+262               ⍝ A certificate is being used for a non permitted purpose
 CERT_E_ISSUERCHAINING←Base+263        ⍝ A parent of a given certificate in fact did not issue that child certificate.
 CERT_E_MALFORMED←Base+264             ⍝ A certificate is missing or has an empty value for an important field, such as a subject or issuer name.
 CERT_E_UNTRUSTEDROOT←Base+265         ⍝ A certification chain processed correctly but terminated in a root certificate not trusted by the trust provider
 CERT_E_CHAINING←Base+266              ⍝ A chain of certificates was not correctly created
 TRUST_E_FAIL←Base+267                 ⍝ Generic Trust Failure.
 CERT_E_REVOKED←Base+268               ⍝ A certificate in the chain has been explicitly revoked by its issuer
 CERT_E_UNTRUSTEDTESTROOT←Base+269     ⍝ The root certificate is a testing certificate and policy settings disallow test certificates
 CERT_E_REVOCATION_FAILURE←Base+270    ⍝ The revocation process could not continue, the certificates could not be checked
 CERT_E_CN_NO_MATCH←Base+271           ⍝ The certificate's CN name does not match the passed value
 CERT_E_WRONG_USAGE←Base+272           ⍝ The certificate is not valid for the requested usage
 Base←IntHex'80100000'              ⍝ SCard error base
 SCARD_S_SUCCESS←NO_ERROR
 SCARD_F_INTERNAL_ERROR←Base+1      ⍝ An internal consistency check failed
 SCARD_E_CANCELLED←Base+2           ⍝ The action was cancelled by an SCardCancel request
 SCARD_E_INVALID_HANDLE←Base+3      ⍝ The supplied handle was invalid
 SCARD_E_INVALID_PARAMETER←Base+4   ⍝ One or more of the supplied parameters could not be properly interpreted
 SCARD_E_INVALID_TARGET←Base+5      ⍝ Registry startup information is missing or invalid
 SCARD_E_NO_MEMORY←Base+6           ⍝ Not enough memory available to complete this command
 SCARD_F_WAITED_TOO_LONG←Base+7     ⍝ An internal consistency timer has expired
 SCARD_E_INSUFFICIENT_BUFFER←Base+8 ⍝ The data buffer to receive returned data is too small for the returned data
 SCARD_E_UNKNOWN_READER←Base+9      ⍝ The specified reader name is not recognized
 SCARD_E_TIMEOUT←Base+10            ⍝ The user-specified timeout value has expired
 SCARD_E_SHARING_VIOLATION←Base+11  ⍝ The smart card cannot be accessed because of other connections outstanding
 SCARD_E_NO_SMARTCARD←Base+12       ⍝ The operation requires a Smart Card, but no Smart Card is currently in the device
 SCARD_E_UNKNOWN_CARD←Base+13       ⍝ The specified smart card name is not recognized
 SCARD_E_CANT_DISPOSE←Base+14       ⍝ The system could not dispose of the media in the requested manner
 SCARD_E_PROTO_MISMATCH←Base+15     ⍝ The requested protocols are incompatible with the protocol currently in use with the smart card
 SCARD_E_NOT_READY←Base+16          ⍝ The reader or smart card is not ready to accept commands
 SCARD_E_INVALID_VALUE←Base+17      ⍝ One or more of the supplied parameters values could not be properly interpreted
 SCARD_E_SYSTEM_CANCELLED←Base+18   ⍝ The action was cancelled by the system, presumably to log off or shut down
 SCARD_F_COMM_ERROR←Base+19         ⍝ An internal communications error has been detected
 SCARD_F_UNKNOWN_ERROR←Base+20      ⍝ An internal error has been detected, but the source is unknown
 SCARD_E_INVALID_ATR←Base+21        ⍝ An ATR obtained from the registry is not a valid ATR string
 SCARD_E_NOT_TRANSACTED←Base+22     ⍝ An attempt was made to end a non-existent transaction
 SCARD_E_READER_UNAVAILABLE←Base+23 ⍝ The specified reader is not currently available for use
 SCARD_P_SHUTDOWN←Base+24           ⍝ PRIVATE -- Internal flag to force server termination
 SCARD_E_PCI_TOO_SMALL←Base+25      ⍝ The PCI Receive buffer was too small
 SCARD_E_READER_UNSUPPORTED←Base+26 ⍝ The reader driver does not meet minimal requirements for support
 SCARD_E_DUPLICATE_READER←Base+27   ⍝ The reader driver did not produce a unique reader name
 SCARD_E_CARD_UNSUPPORTED←Base+28   ⍝ The smart card does not meet minimal requirements for support
 SCARD_E_NO_SERVICE←Base+29         ⍝ The Smart card resource manager is not running
 SCARD_E_SERVICE_STOPPED←Base+30    ⍝ The Smart card resource manager has shut down
 SCARD_W_UNSUPPORTED_CARD←Base+101  ⍝ The reader cannot communicate with the smart card, due to ATR configuration conflicts
 SCARD_W_UNRESPONSIVE_CARD←Base+102 ⍝ The smart card is not responding to a reset
 SCARD_W_UNPOWERED_CARD←Base+103    ⍝ Power has been removed from the smart card, so that further communication is not possible
 SCARD_W_RESET_CARD←Base+104        ⍝ The smart card has been reset, so any shared state information is invalid
 SCARD_W_REMOVED_CARD←Base+105      ⍝ The smart card has been removed, so that further communication is not possible
 E_MD5_LEN_64←IntHex'F2000001' ⍝ MD5_W32.DLL: Die Länge der übergebenen Eingabedaten ist kein Vielfaches von 64 Bytes. (KryptoKom)
 S_OK←0
 S_FALSE←1
 ⎕NA'I KERNEL32|GetLastError'
 ⎕NA'KERNEL32|SetLastError I'
∇

∇ InitSysInfos
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ⎕NA'I KERNEL32|GetVersion'
 VER_PLATFORM_WIN32s←0
 VER_PLATFORM_WIN32_WINDOWS←1
 VER_PLATFORM_WIN32_NT←2
 OSVERSIONINFO←148 0 0 0 0(128⍴1⊃⎕AV)
 'GetVersionEx'⎕NA'I KERNEL32|GetVersionExA ={I I I I I T[128]}'
     
 LANG_NEUTRAL←0
 LANG_GERMAN←7
 ⎕NA'U2 KERNEL32|GetSystemDefaultLangID'
     
 SM_CXSCREEN←0                 ⍝ Screen size
 SM_CYSCREEN←1
 SM_CXVSCROLL←2                ⍝ Vertical scroll bar width
 SM_CYVSCROLL←20               ⍝ Vertical scroll bar arrow bitmap height
 SM_CXHSCROLL←21               ⍝ Horizontal scroll bar arrow bitmap width
 SM_CYHSCROLL←3                ⍝ Horizontal scroll bar height
 SM_CYCAPTION←4                ⍝ Window title height of with frame
 SM_CXBORDER←5                 ⍝ 2D window border size
 SM_CYBORDER←6
 SM_CXFIXEDFRAME←7             ⍝ Frame thickness of non sizable window with caption
 SM_CYFIXEDFRAME←8
 SM_CXHTHUMB←10                ⍝ Thumb box width in a horizontal scroll bar
 SM_CYVTHUMB←9                 ⍝ Thumb box height in a vertical scroll bar
 SM_CXICON←11                  ⍝ Def icon size (32x32)
 SM_CYICON←12
 SM_CXCURSOR←13                ⍝ Cursor size
 SM_CYCURSOR←14
 SM_CYMENU←15                  ⍝ Menu bar height
 SM_CXFULLSCREEN←16            ⍝ Client area size of full-screen window
 SM_CYFULLSCREEN←17
 SM_CYKANJIWINDOW←18           ⍝ Kanji window height
 SM_MOUSEPRESENT←19            ⍝ Mouse hardware installed
 SM_DEBUG←22                   ⍝ Windows is debugging version
 SM_SWAPBUTTON←23              ⍝ Mouse buttons swapped
 SM_CXMIN←28                   ⍝ Min window size
 SM_CYMIN←29
 SM_CXSIZE←30                  ⍝ Button size in caption or title bar
 SM_CYSIZE←31
 SM_CXSIZEFRAME←32             ⍝ Border thickness of resizeable window
 SM_CYSIZEFRAME←33
 SM_CXMINTRACK←34              ⍝ Def min size of window with caption and sizing borders
 SM_CYMINTRACK←35
 SM_CXDOUBLECLK←36             ⍝ Double-click rectangle
 SM_CYDOUBLECLK←37
 SM_CXICONSPACING←38           ⍝ Grid cell size in large icon view
 SM_CYICONSPACING←39
 SM_MENUDROPALIGNMENT←40       ⍝ Pop-up menu alignment
 SM_PENWINDOWS←41
 SM_DBCSENABLED←42             ⍝ Double-byte character support
 SM_CMOUSEBUTTONS←43
 SM_SECURE←44                  ⍝ Security present
 SM_CXEDGE←45                  ⍝ 3D window border size
 SM_CYEDGE←46
 SM_CXMINSPACING←47            ⍝ Grid cell size for minimized windows
 SM_CYMINSPACING←48
 SM_CXSMICON←49                ⍝ Def small icon size
 SM_CYSMICON←50
 SM_CYSMCAPTION←51             ⍝ Small caption height
 SM_CXSMSIZE←52                ⍝ Small caption button size
 SM_CYSMSIZE←53
 SM_CXMENUSIZE←54              ⍝ Menu bar button size eg MDI child close
 SM_CYMENUSIZE←55
 SM_ARRANGE←56
 SM_CXMINIMIZED←57             ⍝ Minimized window size
 SM_CYMINIMIZED←58
 SM_CXMAXTRACK←59              ⍝ Def max window size with caption and sizing borders
 SM_CYMAXTRACK←60
 SM_CXMAXIMIZED←61             ⍝ Maximized top-level window size
 SM_CYMAXIMIZED←62
 SM_NETWORK←63                 ⍝ Network present
 SM_CLEANBOOT←67               ⍝ System start type
 SM_CXDRAG←68                  ⍝ Drag operation rectangle
 SM_CYDRAG←69
 SM_SHOWSOUNDS←70              ⍝ Visualize audible information
 SM_CXMENUCHECK←71             ⍝ Menu check-mark bitmap size
 SM_CYMENUCHECK←72
 SM_SLOWMACHINE←73             ⍝ Slow processor flag
 SM_MIDEASTENABLED←74          ⍝ Hebrew/Arabic language flag
 SM_MOUSEWHEELPRESENT←75       ⍝ Mouse wheel flag
 SM_CMETRICS←76
 ⎕NA'I USER32|GetSystemMetrics I'
     
 COLOR_SCROLLBAR←0                    ⍝ Scroll-bar gray area.
 COLOR_BACKGROUND←1                   ⍝ Desktop.
 COLOR_DESKTOP←COLOR_BACKGROUND
 COLOR_ACTIVECAPTION←2                ⍝ Active window title.
 COLOR_INACTIVECAPTION←3              ⍝ Inactive window title.
 COLOR_MENU←4                         ⍝ Menu background.
 COLOR_WINDOW←5                       ⍝ Window background.
 COLOR_WINDOWFRAME←6                  ⍝ Window frame.
 COLOR_MENUTEXT←7                     ⍝ Text in menus.
 COLOR_WINDOWTEXT←8                   ⍝ Text in windows.
 COLOR_CAPTIONTEXT←9                  ⍝ Text in title bar, size button, scroll-bar arrow button.
 COLOR_ACTIVEBORDER←10                ⍝ Active window border.
 COLOR_INACTIVEBORDER←11              ⍝ Inactive window border.
 COLOR_APPWORKSPACE←12                ⍝ Background color of multiple document interface (MDI) applications.
 COLOR_HIGHLIGHT←13                   ⍝ Background of selected item in a control.
 COLOR_HIGHLIGHTTEXT←14               ⍝ Text of selected item in a control.
 COLOR_BTNFACE←15                     ⍝ Face shading on push buttons.
 COLOR_3DFACE←COLOR_BTNFACE           ⍝ Face color for three-dimensional display elements.
 COLOR_BTNSHADOW←16                   ⍝ Edge shading on push buttons.
 COLOR_3DSHADOW←COLOR_BTNSHADOW       ⍝ Shadow color for three-dimensional display elements (for edges facing away from the light source).
 COLOR_GRAYTEXT←17                    ⍝ Grayed (dimmed) text. This color is zero if the current display driver does not support a solid gray color.
 COLOR_BTNTEXT←18                     ⍝ Text on push buttons.
 COLOR_INACTIVECAPTIONTEXT←19         ⍝ Color of text in an inactive title.
 COLOR_BTNHIGHLIGHT←20                ⍝ Selected button in a control.
 COLOR_3DHIGHLIGHT←COLOR_BTNHIGHLIGHT ⍝ Highlight color for three-dimensional display elements (for edges facing the light source.)
 COLOR_3DHILIGHT←COLOR_BTNHIGHLIGHT
 COLOR_BTNHILIGHT←COLOR_BTNHIGHLIGHT
 COLOR_3DDKSHADOW←21                  ⍝ Win40: Dark shadow for three-dimensional display elements.
 COLOR_3DLIGHT←22                     ⍝ Win40: Light color for three-dimensional display elements (for edges facing the light source.)
 COLOR_INFOTEXT←23                    ⍝ Win40: Text color for tooltip controls.
 COLOR_INFOBK←24                      ⍝ Win40: Background color for tooltip controls.
 ⎕NA'I USER32|GetSysColor I'
     
 DRIVERVERSION←0     ⍝ Device driver version
 TECHNOLOGY←2        ⍝ Device classification
 HORZSIZE←4          ⍝ Horizontal size in millimeters
 VERTSIZE←6          ⍝ Vertical size in millimeters
 HORZRES←8           ⍝ Horizontal width in pixels
 VERTRES←10          ⍝ Vertical height in pixels
 BITSPIXEL←12        ⍝ Bits per pixel
 PLANES←14           ⍝ Number of planes
 NUMBRUSHES←16       ⍝ Brushes the device has
 NUMPENS←18          ⍝ Pens the device has
 NUMMARKERS←20       ⍝ Markers the device has
 NUMFONTS←22         ⍝ Fonts the device has
 NUMCOLORS←24        ⍝ Colors the device supports
 PDEVICESIZE←26      ⍝ Size required for device descriptor
 CURVECAPS←28        ⍝ Curve capabilities
 LINECAPS←30         ⍝ Line capabilities
 POLYGONALCAPS←32    ⍝ Polygonal capabilities
 TEXTCAPS←34         ⍝ Text capabilities
 CLIPCAPS←36         ⍝ Clipping capabilities
 RASTERCAPS←38       ⍝ Bitblt capabilities
 ASPECTX←40          ⍝ Length of the X leg
 ASPECTY←42          ⍝ Length of the Y leg
 ASPECTXY←44         ⍝ Length of the hypotenuse
 LOGPIXELSX←88       ⍝ Logical pixels/inch in X
 LOGPIXELSY←90       ⍝ Logical pixels/inch in Y
 SIZEPALETTE←104     ⍝ Entries in physical palette
 NUMRESERVED←106     ⍝ Reserved entries in palette
 COLORRES←108        ⍝ Actual color resolution
                                  ⍝ Printing related DeviceCaps:
 PHYSICALWIDTH←110   ⍝ Physical Width in device units
 PHYSICALHEIGHT←111  ⍝ Physical Height in device units
 PHYSICALOFFSETX←112 ⍝ Physical Printable Area x margin
 PHYSICALOFFSETY←113 ⍝ Physical Printable Area y margin
 SCALINGFACTORX←114  ⍝ Scaling factor x
 SCALINGFACTORY←115  ⍝ Scaling factor y
                                  ⍝ Display driver specific:
 VREFRESH←116        ⍝ Refresh rate of the display device in Hz
 DESKTOPVERTRES←117  ⍝ Desktop width in pixels
 DESKTOPHORZRES←118  ⍝ Desktop height in pixels
 BLTALIGNMENT←119    ⍝ Preferred blt alignment
 SHADEBLENDCAPS←120  ⍝ Shading and blending caps
 COLORMGMTCAPS←121   ⍝ Color Management caps
 ⎕NA'I GDI32|GetDeviceCaps I I'
     
 SPI_GETBEEP←1                ⍝ Indicates whether the warning beeper is on.
 SPI_SETBEEP←2                ⍝ Turns the warning beeper on or off.
 SPI_GETMOUSE←3               ⍝ Retrieves the two mouse threshold values and the mouse speed.
 SPI_SETMOUSE←4               ⍝ Sets the two mouse threshold values and the mouse speed.
 SPI_GETBORDER←5              ⍝ Retrieves the border multiplier factor that determines the width of a window's sizing border.
 SPI_SETBORDER←6              ⍝ Sets the border multiplier factor that determines the width of a window's sizing border.
 SPI_GETKEYBOARDSPEED←10      ⍝ Retrieves the keyboard repeat-speed setting.
 SPI_SETKEYBOARDSPEED←11      ⍝ Sets the keyboard repeat-speed setting to the value of the uiParam parameter.
 SPI_LANGDRIVER←12            ⍝ Not implemented.
 SPI_ICONHORIZONTALSPACING←13 ⍝ Sets the width of an icon cell.
 SPI_GETSCREENSAVETIMEOUT←14  ⍝ Retrieves the screen saver time-out value, in seconds.
 SPI_SETSCREENSAVETIMEOUT←15  ⍝ Sets the screen saver time-out value to the value of the uiParam parameter.
 SPI_GETSCREENSAVEACTIVE←16   ⍝ Determines whether screen saving is enabled.
 SPI_SETSCREENSAVEACTIVE←17   ⍝ Sets the state of the screen saver.
 SPI_GETGRIDGRANULARITY←18    ⍝ Retrieves the current granularity value of the desktop sizing grid.
 SPI_SETGRIDGRANULARITY←19    ⍝ Sets the granularity of the desktop sizing grid to the value of the uiParam parameter.
 SPI_SETDESKWALLPAPER←20      ⍝ Sets the desktop wallpaper.
 SPI_SETDESKPATTERN←21        ⍝ Sets the current desktop pattern by causing Windows to read the Pattern= setting from the WIN.INI file.
 SPI_GETKEYBOARDDELAY←22      ⍝ Retrieves the keyboard repeat-delay setting.
 SPI_SETKEYBOARDDELAY←23      ⍝ Sets the keyboard repeat-delay setting to the value of the uiParam parameter.
 SPI_ICONVERTICALSPACING←24   ⍝ Sets the height of an icon cell.
 SPI_GETICONTITLEWRAP←25      ⍝ Determines whether icon-title wrapping is enabled.
 SPI_SETICONTITLEWRAP←26      ⍝ Turns icon-title wrapping on or off.
 SPI_GETMENUDROPALIGNMENT←27  ⍝ Determines whether pop-up menus are left-aligned or right-aligned, relative to the corresponding menu-bar item.
 SPI_SETMENUDROPALIGNMENT←28  ⍝ Sets the alignment value of pop-up menus.
 SPI_SETDOUBLECLKWIDTH←29     ⍝ Sets the width of the double-click rectangle to the value of the uiParam parameter.
 SPI_SETDOUBLECLKHEIGHT←30    ⍝ Sets the height of the double-click rectangle to the value of the uiParam parameter.
 SPI_GETICONTITLELOGFONT←31   ⍝ Retrieves the logical font information for the current icon-title font.
 SPI_SETICONTITLELOGFONT←34   ⍝ Sets the font that is used for icon titles.
 SPI_SETDOUBLECLICKTIME←32    ⍝ Sets the double-click time for the mouse to the value of the uiParam parameter.
 SPI_SETMOUSEBUTTONSWAP←33    ⍝ Swaps or restores the meaning of the left and right mouse buttons.
 SPI_GETFASTTASKSWITCH←35     ⍝ This flag is obsolete.
 SPI_SETFASTTASKSWITCH←36     ⍝ This flag is obsolete.
 SPI_GETDRAGFULLWINDOWS←38    ⍝ Sets dragging of full windows either on or off.
 SPI_SETDRAGFULLWINDOWS←37    ⍝ Determines whether dragging of full windows is enabled.
 SPI_GETNONCLIENTMETRICS←41   ⍝ Retrieves the metrics associated with the nonclient area of nonminimized windows.
 SPI_SETNONCLIENTMETRICS←42   ⍝ Sets the metrics associated with the nonclient area of nonminimized windows.
 SPI_GETMINIMIZEDMETRICS←43   ⍝ Retrieves the metrics associated with minimized windows.
 SPI_SETMINIMIZEDMETRICS←44   ⍝ Sets the metrics associated with minimized windows.
 SPI_GETICONMETRICS←45        ⍝ Retrieves the metrics associated with icons.
 SPI_SETICONMETRICS←46        ⍝ Sets the metrics associated with icons.
 SPI_GETWORKAREA←48           ⍝ Retrieves the size of the working area.
 SPI_SETWORKAREA←47           ⍝ Sets the size of the work area.
 SPI_SETPENWINDOWS←49         ⍝ Windows 95 only: Specifies that pen windows is being loaded or unloaded.
 SPI_GETFILTERKEYS←50         ⍝ Retrieves information about the FilterKeys accessibility feature.
 SPI_SETFILTERKEYS←51         ⍝ Sets the parameters of the FilterKeys accessibility feature.
 SPI_GETTOGGLEKEYS←52         ⍝ Retrieves information about the ToggleKeys accessibility feature.
 SPI_SETTOGGLEKEYS←53         ⍝ Sets the parameters of the ToggleKeys accessibility feature.
 SPI_GETMOUSEKEYS←54          ⍝ Retrieves information about the MouseKeys accessibility feature.
 SPI_SETMOUSEKEYS←55          ⍝ Sets the parameters of the MouseKeys accessibility feature.
 SPI_GETSHOWSOUNDS←56         ⍝ Determines whether the Show Sounds accessibility flag is on or off.
 SPI_SETSHOWSOUNDS←57         ⍝ Sets the ShowSounds accessibility feature as on or off.
 SPI_GETSTICKYKEYS←58         ⍝ Retrieves information about the StickyKeys accessibility feature.
 SPI_SETSTICKYKEYS←59         ⍝ Sets the parameters of the StickyKeys accessibility feature.
 SPI_GETACCESSTIMEOUT←60      ⍝ Retrieves information about the time-out period associated with the accessibility features.
 SPI_SETACCESSTIMEOUT←61      ⍝ Sets the time-out period associated with the accessibility features.
 SPI_GETSERIALKEYS←62         ⍝ Windows 95 only: Retrieves information about the SerialKeys accessibility feature.
 SPI_SETSERIALKEYS←63         ⍝ Windows 95 only: Sets the parameters of the SerialKeys accessibility feature.
 SPI_GETSOUNDSENTRY←64        ⍝ Retrieves information about the SoundSentry accessibility feature.
 SPI_SETSOUNDSENTRY←65        ⍝ Sets the parameters of the SoundSentry accessibility feature.
 SPI_GETHIGHCONTRAST←66       ⍝ Windows 95 only: Retrieves information about the HighContrast accessibility feature.
 SPI_SETHIGHCONTRAST←67       ⍝ Windows 95 only: Sets the parameters of the HighContrast accessibility feature.
 SPI_GETKEYBOARDPREF←68       ⍝ Determines whether the user relies on the keyboard instead of the mouse, and wants applications to display keyboard interfaces that would otherwise be hidden.
 SPI_SETKEYBOARDPREF←69       ⍝ Windows 95 only: Sets the keyboard preference.
 SPI_GETSCREENREADER←70       ⍝ Windows 95 only: Determines whether a screen reviewer utility is running.
 SPI_SETSCREENREADER←71       ⍝ Windows 95 only: Indicates whether a screen review utility is running.
 SPI_GETANIMATION←72          ⍝ Retrieves the animation effects associated with user actions.
 SPI_SETANIMATION←73          ⍝ Sets the animation effects associated with user actions.
 SPI_GETFONTSMOOTHING←74      ⍝ Indicates whether the font smoothing feature is enabled.
 SPI_SETFONTSMOOTHING←75      ⍝ Enables or disables the font smoothing feature, which uses font anti-aliasing to make font curves appear smoother by painting pixels at different gray levels.
 SPI_SETDRAGWIDTH←76          ⍝ Sets the width, in pixels, of the rectangle used to detect the start of a drag operation.
 SPI_SETDRAGHEIGHT←77         ⍝ Sets the height, in pixels, of the rectangle used to detect the start of a drag operation.
 SPI_SETHANDHELD←78           ⍝ Used internally; applications should not use this value.
 SPI_GETLOWPOWERTIMEOUT←79    ⍝ Windows 95 only: For 16-bit Windows applications, this value retrieves the time-out value for the low-power phase of screen saving.
 SPI_SETLOWPOWERTIMEOUT←81    ⍝ Windows 95 only: Retrieves the time-out value, in seconds, for the low-power phase of screen saving.
 SPI_GETPOWEROFFTIMEOUT←80    ⍝ Windows 95 only: For 16-bit Windows applications, this value retrieves the time-out value for the power-off phase of screen saving.
 SPI_SETPOWEROFFTIMEOUT←82    ⍝ Windows 95 only: Retrieves the time-out value, in seconds, for the power-off phase of screen saving.
 SPI_GETLOWPOWERACTIVE←83     ⍝ Windows 95 only: For 16-bit Windows applications, this value determines whether the low-power phase of screen saving is enabled or not.
 SPI_SETLOWPOWERACTIVE←85     ⍝ Windows 95 only: Activates or deactivates the low-power phase of screen saving.
 SPI_GETPOWEROFFACTIVE←84     ⍝ Windows 95 only: For 16-bit Windows applications, this value determines whether the power-off phase of screen saving is enabled or not.
 SPI_SETPOWEROFFACTIVE←86     ⍝ Windows 95 only: Activates or deactivates the power-off phase of screen saving.
 SPI_SETCURSORS←87            ⍝
 SPI_SETICONS←88              ⍝
 SPI_GETDEFAULTINPUTLANG←89   ⍝ Returns the keyboard layout handle for the system default input language.
 SPI_SETDEFAULTINPUTLANG←90   ⍝ Sets the default input language for the system shell and applications.
 SPI_SETLANGTOGGLE←91         ⍝ Sets the hot key set for switching between input languages.
 SPI_GETWINDOWSEXTENSION←92   ⍝ Windows 95 only: Indicates whether the Windows extension, Windows Plus!, is installed.
 SPI_GETMOUSETRAILS←94        ⍝ Windows 95 only: Indicates whether the Mouse Trails feature is enabled.
 SPI_SETMOUSETRAILS←93        ⍝ Windows 95 only: Enables or disables the Mouse Trails feature.
 SPI_SCREENSAVERRUNNING←97    ⍝ Windows 95 only: Used internally; applications should not use this flag.
 SPI_GETSNAPTODEFBUTTON←95    ⍝ Windows NT only: Determines whether the snap-to-default-button feature is enabled.
 SPI_SETSNAPTODEFBUTTON←96    ⍝ Windows NT only: Enables or disables the snap-to-default-button feature.
 SPI_GETMOUSEHOVERWIDTH←98    ⍝ Windows NT only: Gets the width, in pixels, of the rectangle within which the mouse pointer has to stay for TrackMouseEvent to generate a WM_MOUSEHOVER message.
 SPI_SETMOUSEHOVERWIDTH←99    ⍝ Windows NT only: Sets the width, in pixels, of the rectangle within which the mouse pointer has to stay for TrackMouseEvent to generate a WM_MOUSEHOVER message.
 SPI_GETMOUSEHOVERHEIGHT←100  ⍝ Windows NT only: Gets the height, in pixels, of the rectangle within which the mouse pointer has to stay for TrackMouseEvent to generate a WM_MOUSEHOVER message.
 SPI_SETMOUSEHOVERHEIGHT←101  ⍝ Windows NT only: Sets the height, in pixels, of the rectangle within which the mouse pointer has to stay for TrackMouseEvent to generate a WM_MOUSEHOVER message.
 SPI_GETMOUSEHOVERTIME←102    ⍝ Windows NT only: Gets the time, in milliseconds, that the mouse pointer has to stay in the hover rectangle for TrackMouseEvent to generate a WM_MOUSEHOVER message.
 SPI_SETMOUSEHOVERTIME←103    ⍝ Windows NT only: Sets the time, in milliseconds, that the mouse pointer has to stay in the hover rectangle for TrackMouseEvent to generate a WM_MOUSEHOVER message.
 SPI_GETWHEELSCROLLLINES←104  ⍝ Windows NT only: Gets the number of lines to scroll when the mouse wheel is rotated.
 SPI_SETWHEELSCROLLLINES←105  ⍝ Windows NT only: Sets the number of lines to scroll when the mouse wheel is rotated.
 SPIF_UPDATEINIFILE←1    ⍝ Writes the new system-wide parameter setting to the user profile.
 SPIF_SENDWININICHANGE←2 ⍝ Broadcasts the WM_SETTINGCHANGE message after updating the user profile.
 SPIF_SENDCHANGE←SPIF_SENDWININICHANGE
 'SystemParametersInfoI4'⎕NA'I USER32|SystemParametersInfoA I I =I[] I'
 LOGFONT←0 0 0 0 0 0 0 0 0 0 0 0 0(32⍴↑⎕AV)
 'SystemParametersInfoLogFont'⎕NA'I USER32|SystemParametersInfoA I I ={I I I I I I1 I1 I1 I1 I1 I1 I1 I1 T[32]} I'
 NONCLIENTMETRICS←340 0 0 0 0 0 LOGFONT 0 0 LOGFONT 0 0 LOGFONT LOGFONT LOGFONT
 'SystemParametersInfoNonClientMetrics'⎕NA'I USER32|SystemParametersInfoA I I ={I I I I I I {I I I I I I1 I1 I1 I1 I1 I1 I1 I1 T[32]} I I {I I I I I I1 I1 I1 I1 I1 I1 I1 I1 T[32]} I I {I I I I I I1 I1 I1 I1 I1 I1 I1 I1 T[32]} {I I I I I I1 I1 I1 I1 I1 I1 I1 I1 T[32]} {I I I I I I1 I1 I1 I1 I1 I1 I1 I1 T[32]}} I'
     
 'GetComputerName'⎕NA'I KERNEL32|GetComputerNameA >0T =I'
 'GetUserName'⎕NA'I ADVAPI32|GetUserNameA >0T =I'
 'GetWindowsDirectory'⎕NA'I KERNEL32|GetWindowsDirectoryA >T[] I'
 'GetSystemDirectory'⎕NA'I KERNEL32|GetSystemDirectoryA >T[] I'
∇

 IntBit←{↑323 ⎕DR,⊖4 8⍴0≠¯32↑⍵}

 IntHex←{{⌊⍵+¯4294967296×2147483647<⍵}16⊥(1⌽⍳⍴⍴⍵)⍉16|'123456789ABCDEF0123456789abcdef'⍳⍵}

 IntTxt←{⍺←1 ⋄ 1=⍺:83 ⎕DR ⍵ ⋄ 0.125=⍺:11 ⎕DR ⍵ ⋄ 83 163 0 323 0 0 0 645[⍺]⎕DR(-⍺|↑⌽⍴⍵)↓[⍴⍴⍵]⍵}

 SplitBinStruct←{⍬≡⍺:'' ⋄ (1 2 4 8 0⍳⍺){5>⍺:↑83 163 323 645[⍺]⎕DR ⍵ ⋄ 5<⍺:⍵ ⋄ ''}¨⍵{(×⍵)\(⍵/⍳⍴⍵)⊂⍺{⍵↑⍺,(0⌈⍵-⍴⍺)⍴↑⎕AV}+/⍵}|⍺}

 SplitTxtStruct←{⍬≡⍺:'' ⋄ (1 2 4 8 0⍳⍺){5>⍺:↑83 163 323 645[⍺]⎕DR ⍵ ⋄ 5<⍺:(¯1+⍵⍳↑⎕AV)⍴⍵ ⋄ ''}¨⍵{(×⍵)\(⍵/⍳⍴⍵)⊂⍺{⍵↑⍺,(0⌈⍵-⍴⍺)⍴↑⎕AV}+/⍵}|⍺}

 TxtHex←{TxtInt 16⊥{(1⌽⍳⍴⍴⍵)⍉⍵}{({(¯1↓⍵),(0 2+0 2⊤↑⊖⍵)}⍴⍵)⍴⍵}16|'123456789ABCDEF0123456789abcdef'⍳{2|↑⌽⍴⍵:¯1↓[⍴⍴⍵]⍵ ⋄ ⍵}⍵}

 TxtInt←{⍺←1 ⋄ 0.125=⍺:{(⎕DR'')⎕DR↑(⎕DR ⍵)11 ⎕DR ⍵}(-8|↑⌽⍴⍵)↓[⍴⍴⍵]⍵ ⋄ 83 163 0 323 0 0 0 645[⍺]{(⎕DR'')⎕DR↑(⎕DR ⍵)⍺ ⎕DR ⍵}⍵+¯256 ¯65536 0 ¯4294967296 0 0 0 0[⍺]×127 32767 0 2147483647 0 0 0 0[⍺]<⍵}

 Bitwise←{⍺←+ ⋄ 0≡⍺ 0:IntBit ⍺⍺ BitInt ⍵ ⋄ IntBit(BitInt ⍺)⍺⍺ BitInt ⍵}


:Namespace Atom
⎕IO ⎕ML ⎕WX←1 3 1

∇ Atom←Add String
     ⍝ Add a character string to the local atom table and return an unique atom value
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.INVALID_ATOM≠Atom←##.AddAtom⊂String
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {Atom}←Delete Atom
     ⍝ Decrement the reference count of a local string atom
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.INVALID_ATOM=Atom←##.DeleteAtom Atom
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Atom←Find String
     ⍝ Search the local atom table for the character string and retrieve the atom associated with that string
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.INVALID_ATOM≠Atom←##.FindAtom⊂String
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ String←GetName Atom
     ⍝ Retrieve a copy of the character string associated with the specified local atom
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×↑⍴String←↑↑/##.GetAtomName Atom 255 255
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Atom←GlobalAdd String
     ⍝ Add a character string to the global atom table and returns its unique value
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.INVALID_ATOM≠Atom←##.GlobalAddAtom⊂String
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {Atom}←GlobalDelete Atom
     ⍝ Decrement the reference count of a global string atom
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.INVALID_ATOM=Atom←##.GlobalDeleteAtom Atom
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Atom←GlobalFind String
     ⍝ Search the global atom table for the character string and retrieve the associated global atom
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.INVALID_ATOM≠Atom←##.GlobalFindAtom⊂String
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ String←GlobalGetName Atom
     ⍝ Retrieve a copy of the character string associated with the specified global atom
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×↑⍴String←↑↑/##.GlobalGetAtomName Atom 255 255
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ List←GlobalScanList
     ⍝ Enumerate all atoms currently defined in the system
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 List←{↑¨↑/¨(×↑¨⍵)/⍵}##.GlobalGetAtomName¨(49151+⍳16385),¨⊂255 255
 #.RCode←##.ERROR_SUCCESS
∇

∇ {VOID}←InitTable Size
     ⍝ Initialize the local atom table and set the number of hash buckets to the specified size
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.ZERO≠VOID←##.InitAtomTable Size
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

:EndNamespace 
:Namespace COM
⎕IO ⎕ML ⎕WX←1 3 1

∇ ClassID←CLSIDFromProgID ProgID;_CLSIDFromProgID;sProgID
     ⍝ Look up a CLSID in the registry, given a ProgID
     ⍝
     ⍝ ProgID  = ProgID whose CLSID is requested  Sample: 'MSComCtl2.DTPicker'
     ⍝ ClassID = Retrieved CLSID on return        Sample: '{20DD1B9E-87C4-11D1-8BE3-0000F8754DA1}'
     ⍝
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 '_CLSIDFromProgID'⎕NA'I OLE32|CLSIDFromProgID <T[] >{I U2 U2 U1 U1 U1 U1 U1 U1 U1 U1}'
 sProgID←↑⍴ProgID←##.IntTxt ProgID,↑⎕AV
 sProgID ProgID←##.MultiByteToWideChar #.Win.CP_ACP 0 ProgID sProgID(2×sProgID)sProgID
 ProgID←(2×sProgID)↑ProgID
 :If ##.ERROR_SUCCESS=↑#.RCode ClassID←_CLSIDFromProgID ProgID 1
     ClassID←{'{',⍵,'}'}↑{⍺,'-',⍵}/1 1 1 1 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5⊂∊¯8 ¯4 ¯4 ¯2 ¯2 ¯2 ¯2 ¯2 ¯2 ¯2 ¯2↑¨##.HexInt¨ClassID
 :Else
     ClassID←''
 :EndIf
∇

∇ {ValidFlag}←DllRegisterServer DllFilename;_DllRegisterServer
     ⍝ Instruct an in-process server to create its registry entries for all classes supported in this server module
     ⍝
     ⍝ DllFilename = Name of the DLL or OCX to register
     ⍝ ValidFlag   = #.Win.TRUE or #.Win.FALSE (see #.RCode #.RText)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Trap 0
     '_DllRegisterServer'⎕NA'I ',DllFilename,'|DllRegisterServer'
     :If ValidFlag←##.S_OK=_DllRegisterServer
         #.RCode←0
     :Else
         #.RCode←##.ERROR_INVALID_FUNCTION
     :EndIf
 :Else
     ValidFlag←##.FALSE
     #.RCode←##.ERROR_MOD_NOT_FOUND
 :EndTrap
∇

∇ {ValidFlag}←DllUnregisterServer DllFilename;_DllUnregisterServer
     ⍝ Instruct an in-process server to remove only those entries created through DllRegisterServer
     ⍝
     ⍝ DllFilename = Name of the DLL or OCX to unregister
     ⍝ ValidFlag   = #.Win.TRUE or #.Win.FALSE (see #.RCode #.RText)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Trap 0
     '_DllUnregisterServer'⎕NA'I ',DllFilename,'|DllUnregisterServer'
     :If ValidFlag←##.S_OK=_DllUnregisterServer
         #.RCode←0
     :Else
         #.RCode←##.ERROR_INVALID_FUNCTION
     :EndIf
 :Else
     ValidFlag←##.FALSE
     #.RCode←##.ERROR_MOD_NOT_FOUND
 :EndTrap
∇

∇ ProgID←ProgIDFromCLSID ClassID;_ProgIDFromCLSID;_CoTaskMemFree;pProgID;sProgID;void
     ⍝ Retrieve the ProgID for a given CLSID
     ⍝
     ⍝ ClassID = CLSID for which the ProgID is requested Sample: '{20DD1B9E-87C4-11D1-8BE3-0000F8754DA1}'
     ⍝ ProgID  = Retrieved ProgID string                 Sample: 'MSComCtl2.DTPicker.2'
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 '_ProgIDFromCLSID'⎕NA'I OLE32|ProgIDFromCLSID <{I U2 U2 U1 U1 U1 U1 U1 U1 U1 U1} >I'
 '_CoTaskMemFree'⎕NA'I OLE32|CoTaskMemFree I'
 :If 32≠↑⍴ClassID←ClassID∩'0123456789ABCDEF'
     #.RCode←##.ERROR_INVALID_PARAMETER
     ProgID←''
 :Else
     ClassID←##.IntHex¨(1 1 1 1 1 1 1 1 2 2 2 2 3 3 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11)⊂ClassID
     :If ##.ERROR_SUCCESS=↑#.RCode pProgID←_ProgIDFromCLSID ClassID 1
         sProgID←80
         ProgID←##.IntTxt ##.RtlMoveMemoryR sProgID pProgID sProgID
         void←_CoTaskMemFree pProgID
         ProgID←{(¯1+⍵⍳↑⎕AV)↑⍵}↑↑/##.WideCharToMultiByte ##.CP_ACP 0 ProgID(⌊0.5×sProgID)sProgID sProgID 0 0
     :Else
         ProgID←''
     :EndIf
 :EndIf
∇

:EndNamespace 
:Namespace Cert
⎕IO ⎕ML ⎕WX←1 3 1

:Namespace Context
⎕IO ⎕ML ⎕WX←1 3 1

∇ pContext←Create Parms;EncodedCert;EncodingType
     ⍝ Create Ptr to certificate context from encoded certificate
     ⍝
     ⍝ Parms[1] = EncodedCert   encoded certificate from which the context is to be created
     ⍝ Parms[2] = EncodingType  (opt) Encoding for certificate, both is acceptable (#.Win.X509_ASN_ENCODING+#.Win.PKCS_7_ASN_ENCODING)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 2>≡Parms
     EncodedCert←Parms
     EncodingType←##.##.X509_ASN_ENCODING+##.##.PKCS_7_ASN_ENCODING
 :Else
     EncodedCert EncodingType←2↑Parms
 :EndIf
 EncodedCert←##.##.IntTxt EncodedCert
 :If ##.##.NULL≠pContext←##.##.CertCreateCertificateContext EncodingType EncodedCert(↑⍴EncodedCert)
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

∇ PropIds←EnumProperties pCertContext;PropId
     ⍝ Enumerate the properties for the specified certificate context.
     ⍝
     ⍝ Potential PropIds are:
     ⍝ #.Win.CERT_KEY_PROV_HANDLE_PROP_ID (1)       #.Win.CERT_ACCESS_STATE_PROP_ID (14)
     ⍝ #.Win.CERT_KEY_PROV_INFO_PROP_ID (2)         #.Win.CERT_SIGNATURE_HASH_PROP_ID(15)
     ⍝ #.Win.CERT_SHA1_HASH_PROP_ID (3)             #.Win.CERT_ARCHIVED_PROP_ID (19)
     ⍝ #.Win.CERT_MD5_HASH_PROP_ID (4)              #.Win.CERT_KEY_IDENTIFIER_PROP_ID (20)
     ⍝ #.Win.CERT_KEY_CONTEXT_PROP_ID (5)           #.Win.CERT_AUTO_ENROLL_PROP_ID (21)
     ⍝ #.Win.CERT_KEY_SPEC_PROP_ID (6)              #.Win.CERT_AUTO_ENROLL_PROP_ID (21)
     ⍝ #.Win.CERT_ENHKEY_USAGE_PROP_ID (9)          #.Win.CERT_PUBKEY_ALG_PARA_PROP_ID (22)
     ⍝ #.Win.CERT_NEXT_UPDATE_LOCATION_PROP_ID (10) #.Win.CERT_CROSS_CERT_DIST_POINTS_PROP_ID (23)
     ⍝ #.Win.CERT_FRIENDLY_NAME_PROP_ID (11)        #.Win.CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID (25)
     ⍝ #.Win.CERT_PVK_FILE_PROP_ID (12)             #.Win.CERT_ENROLLMENT_PROP_ID (26)
     ⍝ #.Win.CERT_DESCRIPTION_PROP_ID (13)          #.Win.CERT_DATE_STAMP_PROP_ID (27)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 PropId←0
 PropIds←⍬
 :While 0≠PropId←##.##.CertEnumCertificateContextProperties pCertContext PropId
     PropIds,←PropId
 :EndWhile
 :If ##.##.CERT_KEY_CONTEXT_PROP_ID∊PropIds
     PropIds,←##.##.CERT_KEY_PROV_HANDLE_PROP_ID ##.##.CERT_KEY_SPEC_PROP_ID
     PropIds←PropIds[⍋PropIds]
     #.RCode←##.##.ERROR_SUCCESS
 :ElseIf ⍬≢PropIds
     PropIds←PropIds[⍋PropIds]
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

∇ {VOID}←Free pContext
     ⍝ Free Ptr to certificate context by decrementing its reference count
     ⍝ Always returns TRUE
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 VOID←##.##.CertFreeCertificateContext pContext
∇

∇ CertContext←GetCertContext pCertContext;BlobPtrToTxtString;BitBlobPtrToBitString;StrZPtrToTxtString;TxtStringToOid;FileTimeToQuadTS;CertEncodingType;pbCertEncoded;cbCertEncoded;pCertInfo;hCertStore;Certificate;CertInfo;Extension;Version;SerialNumber;SignatureAlgorithm;Issuer;NotBefore;NotAfter;Subject;SubjectPublicKeyInfo;IssuerUniqueId;SubjectUniqueId;Extensions;ObjId;Parameters;PublicKey;fCritical;Value
     ⍝ Get certificate context from a Ptr to certificate context
     ⍝
     ⍝ CertContext[1]  = Certificate          (Characterstring)
     ⍝ CertContext[2]  = CertEncodingType     (Integer)
     ⍝ CertContext[3]  = Version              (Integer)
     ⍝ CertContext[4]  = SerialNumber         (Characterstring)
     ⍝ CertContext[5]  = SignatureAlgorithm   (ObjId Parameters)
     ⍝ CertContext[6]  = Issuer               (Characterstring)
     ⍝ CertContext[7]  = NotBefore            (⎕TS)
     ⍝ CertContext[8]  = NotAfter             (⎕TS)
     ⍝ CertContext[9]  = Subject              (Characterstring)
     ⍝ CertContext[10] = SubjectPublicKeyInfo (ObjId Parameters PublicKeyBitvector)
     ⍝ CertContext[11] = IssuerUniqueId       (Bitvector)
     ⍝ CertContext[12] = SubjectUniqueId      (Bitvector)
     ⍝ CertContext[13] = Extensions           (ObjId fCritical Value)(ObjId fCritical Value)..
     ⍝ CertContext[14] = hCertStore           (Integer)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 BlobPtrToTxtString←{##.##.RtlMoveMemoryR ⍵[1 2 1]}
 BitBlobPtrToBitString←{(-⍵[3])↓0.125 ##.##.IntTxt ##.##.RtlMoveMemoryR ⍵[1 2 1]}
 StrZPtrToTxtString←{2⊃##.##.lstrcpyPtr(1+##.##.lstrlenPtr ⍵)⍵}
 TxtStringToOid←{⍵{1↓⍎'0 ',⍵\⍵/⍺}⍵∊⎕D}
 FileTimeToQuadTS←{1 1 0 1 1 1 1 1/2⊃##.##.FileTimeToSystemTime(2⊃##.##.FileTimeToLocalFileTime(4294967296|⍵)1)1}
     ⍝
 CertEncodingType pbCertEncoded cbCertEncoded pCertInfo hCertStore←4 ##.##.IntTxt BlobPtrToTxtString 20 pCertContext
 Certificate←BlobPtrToTxtString cbCertEncoded pbCertEncoded
  ⋄ CertInfo←4 ##.##.IntTxt BlobPtrToTxtString 112 pCertInfo
     ⍝ CertInfo[1]                 DWORD                      Version
     ⍝ CertInfo[2 3]               CRYPT_INTEGER_BLOB         SerialNumber         (cbData pbData)
     ⍝ CertInfo[4 5 6]             CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm   (pszObjId  cbParameters pbParameters)
     ⍝ CertInfo[7 8]               CERT_NAME_BLOB             Issuer               (cbData pbData)
     ⍝ CertInfo[9 10]              FILETIME                   NotBefore            (dwLowDateTime dwHighDateTime)
     ⍝ CertInfo[11 12]             FILETIME                   NotAfter             (dwLowDateTime dwHighDateTime)
     ⍝ CertInfo[13 14]             CERT_NAME_BLOB             Subject              (cbData pbData)
     ⍝ CertInfo[15,16 17,18 19 20] CERT_PUBLIC_KEY_INFO       SubjectPublicKeyInfo (pszObjId,cbParameters pbParameters,cbData pbData cUnusedBits)
     ⍝ CertInfo[21 22 23]          CRYPT_BIT_BLOB             IssuerUniqueId       (cbData pbData cUnusedBits)
     ⍝ CertInfo[24 25 26]          CRYPT_BIT_BLOB             SubjectUniqueId      (cbData pbData cUnusedBits)
     ⍝ CertInfo[27]                DWORD                      cExtension
     ⍝ CertInfo[28]                PCERT_EXTENSION            rgExtension
 Version←CertInfo[1]
 SerialNumber←BlobPtrToTxtString CertInfo[2 3]
  ⋄ ObjId←TxtStringToOid StrZPtrToTxtString CertInfo[4]
  ⋄ Parameters←BlobPtrToTxtString CertInfo[5 6]
 SignatureAlgorithm←ObjId Parameters
 Issuer←BlobPtrToTxtString CertInfo[7 8]
 NotBefore←FileTimeToQuadTS CertInfo[9 10]
 NotAfter←FileTimeToQuadTS CertInfo[11 12]
 Subject←BlobPtrToTxtString CertInfo[13 14]
  ⋄ ObjId←TxtStringToOid StrZPtrToTxtString CertInfo[15]
  ⋄ Parameters←BlobPtrToTxtString CertInfo[16 17]
  ⋄ PublicKey←BitBlobPtrToBitString CertInfo[18 19 20]
 SubjectPublicKeyInfo←ObjId Parameters PublicKey
 IssuerUniqueId←BitBlobPtrToBitString CertInfo[21 22 23]
 SubjectUniqueId←BitBlobPtrToBitString CertInfo[24 25 26]
 Extensions←0⍴⊂'' 0 ''
     ⍝ Extension[1]   LPSTR            pszObjId
     ⍝ Extension[2]   BOOL             fCritical
     ⍝ Extension[3 4] CRYPT_OBJID_BLOB Value (cbData pbData)
 :For Extension :In ⊂[2]4 ##.##.IntTxt CertInfo[27]16⍴BlobPtrToTxtString 16 1×CertInfo[27 28]
      ⋄ ObjId←TxtStringToOid StrZPtrToTxtString Extension[1]
      ⋄ fCritical←Extension[2]
      ⋄ Value←BlobPtrToTxtString Extension[3 4]
     Extensions,←⊂ObjId fCritical Value
 :EndFor
 CertContext←Certificate CertEncodingType Version SerialNumber SignatureAlgorithm Issuer NotBefore NotAfter Subject SubjectPublicKeyInfo IssuerUniqueId SubjectUniqueId Extensions hCertStore
∇

∇ Certificate←GetCertificate pCertContext;CertEncodingType;pbCertEncoded;cbCertEncoded
     ⍝ Get Certificate from Ptr to certificate context
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 CertEncodingType pbCertEncoded cbCertEncoded←4 ##.##.IntTxt 12 ##.##.Mem.Read pCertContext
 Certificate←cbCertEncoded ##.##.Mem.Read pbCertEncoded
∇

∇ Property←GetProperty Parms;pCertContext;PropId;Bool;Data;cbData;pvData;pwszContainerName;pwszProvName;ProvType;Flags;cProvParam;rgProvParam;KeySpec;Offset;ContainerName;ProvName;ProvParam;Param;ProvData;cbProvData;ProvFlags;Size;hCryptProv;pbData;RequestID;sCADNSName;CADNSName;sCAName;CAName;sFriendlyName;FriendlyName;LocalFileTime;LocalSystemTime;RCode
     ⍝ Get the property for the specified certificate context.
     ⍝
     ⍝ Parms[1] = pCertContext
     ⍝ Parms[2] = PropId
     ⍝
     ⍝ Potential property IDs are:
     ⍝
     ⍝ #.Win.CERT_KEY_PROV_HANDLE_PROP_ID             (01) HCRYPTPROV provider handle from CERT_KEY_CONTEXT_PROP_ID
     ⍝ #.Win.CERT_KEY_PROV_INFO_PROP_ID               (02) CRYPT_KEY_PROV_INFO (ContainerName ProvName ProvType Flags ProvParam KeySpec)
     ⍝ #.Win.CERT_SHA1_HASH_PROP_ID                   (03) SHA1 hash, computed using CryptHashCertificate
     ⍝ #.Win.CERT_MD5_HASH_PROP_ID                    (04) MD5 hash, computed using CryptHashCertificate
     ⍝ #.Win.CERT_KEY_CONTEXT_PROP_ID                 (05) CERT_KEY_CONTEXT structure.
     ⍝ #.Win.CERT_KEY_SPEC_PROP_ID                    (06) DWORD specifying private key from CERT_KEY_CONTEXT_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID
     ⍝ #.Win.CERT_ENHKEY_USAGE_PROP_ID                (09) ASN.1 encoded CERT_ENHKEY_USAGE
     ⍝ #.Win.CERT_NEXT_UPDATE_LOCATION_PROP_ID        (10) ASN.1 encoded CERT_ALT_NAME_INFO
     ⍝ #.Win.CERT_FRIENDLY_NAME_PROP_ID               (11) NULL-term-UnicodeString friendly name for the certificate
     ⍝ #.Win.CERT_PVK_FILE_PROP_ID                    (12) NULL-term-UnicodeString file name with the certificate's private key
     ⍝ #.Win.CERT_DESCRIPTION_PROP_ID                 (13) Property displayed by the certificate user-described use
     ⍝ #.Win.CERT_ACCESS_STATE_PROP_ID                (14) Indicates whether write operations to the certificate are persisted
     ⍝ #.Win.CERT_SIGNATURE_HASH_PROP_ID              (15) Signature hash, computed with CryptHashToBeSigned
     ⍝ #.Win.CERT_SMART_CARD_DATA_PROP_ID             (16) Indicates the private key is located on a SmartCard
     ⍝ #.Win.CERT_ARCHIVED_PROP_ID                    (19) Indicates the certificate is skipped during enumerations
     ⍝ #.Win.CERT_KEY_IDENTIFIER_PROP_ID              (20) Searches for szOID_SUBJECT_KEY_IDENTIFIER extension or SHA1 on SubjectPublicKeyInfo to produce identifier values
     ⍝ #.Win.CERT_AUTO_ENROLL_PROP_ID                 (21) NULL-term-UnicodeString naming type for which it has been auto enrolled
     ⍝ #.Win.CERT_PUBKEY_ALG_PARA_PROP_ID             (22) ASN.1 encoded PublicKey Algorithm Parameters
     ⍝ #.Win.CERT_CROSS_CERT_DIST_POINTS_PROP_ID      (23) Location of the cross certificates
     ⍝ #.Win.CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID  (24) MD5 hash of public key this certificate was signed with
     ⍝ #.Win.CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID (25) MD5 hash of public key
     ⍝ #.Win.CERT_ENROLLMENT_PROP_ID                  (26) Enrollment information of pending request
     ⍝ #.Win.CERT_DATE_STAMP_PROP_ID                  (27) Time when certificate was added to store
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 pCertContext PropId←2↑Parms
 :If 0=pCertContext
     Property←''
 :ElseIf ##.##.NULL≠pvData←##.##.Mem.Alloc cbData←16384
     :If ↑Bool cbData←##.##.CertGetCertificateContextProperty pCertContext PropId pvData cbData
         Data←cbData ##.##.Mem.Free pvData
         Offset←pvData
         :Select ↑PropId
         :CaseList ##.##.CERT_KEY_PROV_HANDLE_PROP_ID ##.##.CERT_ACCESS_STATE_PROP_ID ##.##.CERT_KEY_SPEC_PROP_ID
             :If 4=↑⍴Data ⍝ Data=DWORD
                 Property←4 ##.##.IntTxt Data
             :Else
                 #.RCode←##.##.ERROR_INVALID_DATA
                 Property←''
             :EndIf
         :Case ##.##.CERT_KEY_PROV_INFO_PROP_ID
             :If 28≤↑⍴Data ⍝ Data=CRYPT_KEY_PROV_INFO
                 pwszContainerName pwszProvName ProvType Flags cProvParam rgProvParam KeySpec←4 ##.##.IntTxt 28↑Data
                 pwszContainerName pwszProvName rgProvParam-←Offset×0≠pwszContainerName pwszProvName rgProvParam
                 cbData←↑0 2⊤⍴ContainerName←##.##.IntTxt pwszContainerName↓Data ⍝ UniCode
                 ContainerName←{(¯1+⍵⍳↑⎕AV)↑⍵}↑↑/##.##.WideCharToMultiByte ##.##.CP_ACP 0 ContainerName cbData cbData cbData 0 0
                 cbData←↑0 2⊤⍴ProvName←##.##.IntTxt pwszProvName↓Data           ⍝ UniCode
                 ProvName←{(¯1+⍵⍳↑⎕AV)↑⍵}↑↑/##.##.WideCharToMultiByte ##.##.CP_ACP 0 ProvName cbData cbData cbData 0 0
                 ProvParam←0⍴⊂0 '' 0
                 :For Param ProvData cbProvData ProvFlags :In 4 ##.##.IntTxt¨(16/⍳cProvParam)⊂(16×cProvParam)↑rgProvParam↓Data
                     ProvData-←Offset×0≠ProvData
                     ProvData←cbProvData↑ProvData↓Data
                     :If 4=↑⍴ProvData
                         ProvData←4 ##.##.IntTxt ProvData
                     :EndIf
                     ProvParam,←⊂Param ProvData ProvFlags
                 :EndFor
                 Property←ContainerName ProvName ProvType Flags ProvParam KeySpec
             :Else
                 #.RCode←##.##.ERROR_INVALID_DATA
                 Property←''
             :EndIf
         :Case ##.##.CERT_KEY_CONTEXT_PROP_ID
             :If 12>↑⍴Data ⍝ Data=CERT_KEY_CONTEXT
             :OrIf 12≠↑⍴↑Size hCryptProv KeySpec←4 ##.##.IntTxt 12↑Data
                 Property←hCryptProv KeySpec
             :Else
                 #.RCode←##.##.ERROR_INVALID_DATA
                 Property←''
             :EndIf
         :CaseList ##.##.CERT_FRIENDLY_NAME_PROP_ID ##.##.CERT_PVK_FILE_PROP_ID ##.##.CERT_DESCRIPTION_PROP_ID ##.##.CERT_AUTO_ENROLL_PROP_ID
             cbData←↑0 2⊤⍴Property←##.##.IntTxt Data ⍝ Data=UniCode
             Property←{(¯1+⍵⍳↑⎕AV)↑⍵}↑↑/##.##.WideCharToMultiByte ##.##.CP_ACP 0 Property cbData cbData cbData 0 0
         :CaseList ##.##.CERT_ARCHIVED_PROP_ID ##.##.CERT_SMART_CARD_DATA_PROP_ID
             Property←##.##.TRUE  ⍝ Data=NULL
         :CaseList ##.##.CERT_CROSS_CERT_DIST_POINTS_PROP_ID ##.##.CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID ##.##.CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID ##.##.CERT_ENROLLMENT_PROP_ID
             :If 8≤↑⍴Data ⍝ Data=CRYPT_DATA_BLOB
                 cbData pbData←4 ##.##.IntTxt 8↑Data
                 pbData-←Offset×0≠pbData
                 Property←cbData↑pbData↓Data
                 :If ##.##.CERT_ENROLLMENT_PROP_ID=↑PropId
                     RequestID sCADNSName←4 ##.##.IntTxt 8↑Property
                     :If 1024>sCADNSName
                         CADNSName←{(¯1+⍵⍳↑⎕AV)↑⍵}sCADNSName↑8↓Property
                     :AndIf 1024>sCAName←↑4 ##.##.IntTxt 4↑(8+sCADNSName)↓Property
                         CAName←{(¯1+⍵⍳↑⎕AV)↑⍵}sCAName↑(12+sCADNSName)↓Property
                     :AndIf 1024>sFriendlyName←↑4 ##.##.IntTxt 4↑(12+sCADNSName+sCAName)↓Property
                         FriendlyName←{(¯1+⍵⍳↑⎕AV)↑⍵}sFriendlyName↑(16+sCADNSName+sCAName)↓Property
                         Property←RequestID CADNSName CAName FriendlyName
                     :Else
                         #.RCode←##.##.ERROR_INVALID_DATA
                         Property←''
                     :EndIf
                 :EndIf
             :Else
                 #.RCode←##.##.ERROR_INVALID_DATA
                 Property←''
             :EndIf
         :CaseList ##.##.CERT_ENHKEY_USAGE_PROP_ID ##.##.CERT_NEXT_UPDATE_LOCATION_PROP_ID ##.##.CERT_PUBKEY_ALG_PARA_PROP_ID
             Property←Data ⍝ Data=ASN.1 String
         :CaseList ##.##.CERT_SHA1_HASH_PROP_ID ##.##.CERT_MD5_HASH_PROP_ID ##.##.CERT_SIGNATURE_HASH_PROP_ID ##.##.CERT_KEY_IDENTIFIER_PROP_ID
             Property←Data ⍝ Data=Hash String
         :Case ##.##.CERT_DATE_STAMP_PROP_ID
             :If 8≤↑⍴Data ⍝ Data=FILETIME
             :AndIf ↑Bool LocalFileTime←##.##.FileTimeToLocalFileTime(4 ##.##.IntTxt 8↑Data)1
             :AndIf ↑Bool LocalSystemTime←##.##.FileTimeToSystemTime LocalFileTime 1
                 Property←1 1 0 1 1 1 1 1/LocalSystemTime
             :Else
                 #.RCode←##.##.ERROR_INVALID_DATA
                 Property←''
             :EndIf
         :Else
             Property←Data ⍝ Data=unknown
         :EndSelect
     :Else
         #.RCode←##.##.GetLastError
         RCode←#.RCode ⋄ ##.##.Mem.Free pvData ⋄ :If RCode≠##.##.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
         Property←''
         :If (↑PropId)∊##.##.CERT_ARCHIVED_PROP_ID ##.##.CERT_SMART_CARD_DATA_PROP_ID
             Property←##.##.FALSE
             #.RCode←##.##.ERROR_SUCCESS
         :EndIf
     :EndIf
 :Else
     #.RCode←##.##.GetLastError
     Property←''
 :EndIf
∇

:EndNamespace 
:Namespace Store
⎕IO ⎕ML ⎕WX←1 3 1

∇ {ValidFlag}←Add Parms;hCertStore;AddDisposition;CertEncoded;EncodingType;pContext
     ⍝ (Create certificate context from an encoded certificate and) Add certificate to certificate store.
     ⍝
     ⍝ Parms[1] = hCertStore      Handle to the certificate store
     ⍝ Parms[2] = AddDisposition  What to do if (link to) a matching certificate exists (#.Win.CERT_STORE_ADD_NEW #.Win.CERT_STORE_ADD_USE_EXISTING #.Win.CERT_STORE_ADD_REPLACE_EXISTING or #.Win.CERT_STORE_ADD_ALWAYS)
     ⍝ Parms[3] = pContext        Ptr to certificate context to be added to store
     ⍝ or
     ⍝ Parms[3] = CertEncoded     Certificate to be added to certificate store
     ⍝ Parms[4] = EncodingType    (opt) Encoding for certificate and message (default: #.Win.X509_ASN_ENCODING+#.Win.PKCS_7_ASN_ENCODING)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 hCertStore AddDisposition CertEncoded EncodingType←4↑Parms
 :If 82=⎕DR CertEncoded
     CertEncoded←##.##.IntTxt CertEncoded
     :If 3=↑⍴Parms
         EncodingType←##.##.X509_ASN_ENCODING+##.##.PKCS_7_ASN_ENCODING
     :EndIf
     ValidFlag←##.##.CertAddEncodedCertificateToStore hCertStore EncodingType CertEncoded(↑⍴CertEncoded)AddDisposition 0
 :Else
     pContext←CertEncoded
     ValidFlag←##.##.CertAddCertificateContextToStore hCertStore pContext AddDisposition 0
 :EndIf
 :If ##.##.FALSE≠ValidFlag
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←Close Parms;hCertStore;Flags
     ⍝ Close a certificate store handle
     ⍝
     ⍝ Parms[1] = hCertStore handle of certificate store to be closed
     ⍝ Parms[2] = Flags      optional: #.Win.CERT_CLOSE_STORE_CHECK_FLAG #.Win.CERT_CLOSE_STORE_FORCE_FLAG
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 hCertStore Flags←2↑Parms
 :If ×4|hCertStore
     ValidFlag←0
     #.RCode←##.##.ERROR_INVALID_HANDLE
 :ElseIf ##.##.TRUE=ValidFlag←##.##.CertCloseStore hCertStore Flags
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←Del Parms;hCertStore;CertEncoded;pCertContext;pPrevCertContext;pContext;CertEncodingType;FindFlags;FindType
     ⍝ (Create certificate context from an encoded certificate and) delete certificate from certificate store.
     ⍝
     ⍝ Parms[1] = pCertContext    Ptr to certificate context structure to be deleted from store
     ⍝ or
     ⍝ Parms[1] = hCertStore      Handle to the certificate store
     ⍝ Parms[2] = CertEncoded     Certificate to be deleted from certificate store
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 1<≡Parms
     hCertStore CertEncoded←2↑Parms
     :If ##.##.NULL≠pContext←##.Context.Create CertEncoded
         CertEncodingType←##.##.X509_ASN_ENCODING+##.##.PKCS_7_ASN_ENCODING
         FindFlags←0
         FindType←##.##.CERT_FIND_EXISTING
         pPrevCertContext←0
         :If ##.##.NULL≠pCertContext←##.##.CertFindCertificateInStore hCertStore CertEncodingType FindFlags FindType pContext pPrevCertContext
             :If ##.##.FALSE≠ValidFlag←##.##.CertDeleteCertificateFromStore pCertContext
                 #.RCode←##.##.ERROR_SUCCESS
             :Else
                 #.RCode←##.##.GetLastError
             :EndIf
         :Else
             #.RCode←##.##.GetLastError
             ValidFlag←##.##.FALSE
         :EndIf
         ##.Context.Free pContext
     :Else
         #.RCode←##.##.GetLastError
         ValidFlag←##.##.FALSE
     :EndIf
 :Else
     pCertContext←↑Parms
     :If ##.##.FALSE≠ValidFlag←##.##.CertDeleteCertificateFromStore pCertContext
         #.RCode←##.##.ERROR_SUCCESS
     :Else
         #.RCode←##.##.GetLastError
     :EndIf
 :EndIf
∇

∇ CertContexts←EnumCertContexts hCertStore;pCertContext
     ⍝ Enumerate all the certificate infos in the store
     ⍝
     ⍝ CertContexts¨[1]  = Certificate          (Characterstring)
     ⍝ CertContexts¨[2]  = CertEncodingType     (Integer)
     ⍝ CertContexts¨[3]  = Version              (Integer)
     ⍝ CertContexts¨[4]  = SerialNumber         (Characterstring)
     ⍝ CertContexts¨[5]  = SignatureAlgorithm   (ObjId Parameters)
     ⍝ CertContexts¨[6]  = Issuer               (Characterstring)
     ⍝ CertContexts¨[7]  = NotBefore            (⎕TS)
     ⍝ CertContexts¨[8]  = NotAfter             (⎕TS)
     ⍝ CertContexts¨[9]  = Subject              (Characterstring)
     ⍝ CertContexts¨[10] = SubjectPublicKeyInfo (ObjId Parameters PublicKeyBitvector)
     ⍝ CertContexts¨[11] = IssuerUniqueId       (Bitvector)
     ⍝ CertContexts¨[12] = SubjectUniqueId      (Bitvector)
     ⍝ CertContexts¨[13] = Extensions           (ObjId fCritical Value)(ObjId fCritical Value)..
     ⍝ CertContexts¨[14] = hCertStore           (Integer)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 CertContexts←0⍴⊂'' 0 0 ''('' '')''(7⍴0)(7⍴0)''('' ''⍬)⍬ ⍬(0⍴⊂'' 0 '')0
 pCertContext←0
 :While ##.##.NULL≠pCertContext←##.##.CertEnumCertificatesInStore hCertStore pCertContext
     CertContexts,←⊂##.Context.GetCertContext pCertContext
 :EndWhile
 :If ×↑⍴CertContexts
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

∇ CertificatePropIds←EnumCertificatePropIds hCertStore;pCertContext
     ⍝ Enumerate all the certificates and its PropertyIDs in the store
     ⍝
     ⍝ CertificatePropIds¨[1]  = Certificate (Characterstring)
     ⍝ CertificatePropIds¨[2]  = PropIds     (Integervector)
     ⍝
     ⍝ Potential PropIds are:
     ⍝ #.Win.CERT_KEY_PROV_HANDLE_PROP_ID (1)       #.Win.CERT_ACCESS_STATE_PROP_ID (14)
     ⍝ #.Win.CERT_KEY_PROV_INFO_PROP_ID (2)         #.Win.CERT_SIGNATURE_HASH_PROP_ID(15)
     ⍝ #.Win.CERT_SHA1_HASH_PROP_ID (3)             #.Win.CERT_ARCHIVED_PROP_ID (19)
     ⍝ #.Win.CERT_MD5_HASH_PROP_ID (4)              #.Win.CERT_KEY_IDENTIFIER_PROP_ID (20)
     ⍝ #.Win.CERT_KEY_CONTEXT_PROP_ID (5)           #.Win.CERT_AUTO_ENROLL_PROP_ID (21)
     ⍝ #.Win.CERT_KEY_SPEC_PROP_ID (6)              #.Win.CERT_AUTO_ENROLL_PROP_ID (21)
     ⍝ #.Win.CERT_ENHKEY_USAGE_PROP_ID (9)          #.Win.CERT_PUBKEY_ALG_PARA_PROP_ID (22)
     ⍝ #.Win.CERT_NEXT_UPDATE_LOCATION_PROP_ID (10) #.Win.CERT_CROSS_CERT_DIST_POINTS_PROP_ID (23)
     ⍝ #.Win.CERT_FRIENDLY_NAME_PROP_ID (11)        #.Win.CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID (25)
     ⍝ #.Win.CERT_PVK_FILE_PROP_ID (12)             #.Win.CERT_ENROLLMENT_PROP_ID (26)
     ⍝ #.Win.CERT_DESCRIPTION_PROP_ID (13)          #.Win.CERT_DATE_STAMP_PROP_ID (27)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 CertificatePropIds←0⍴⊂''⍬
 pCertContext←0
 :While ##.##.NULL≠pCertContext←##.##.CertEnumCertificatesInStore hCertStore pCertContext
     CertificatePropIds,←⊂(##.Context.GetCertificate pCertContext)(##.Context.EnumProperties pCertContext)
 :EndWhile
 :If ×↑⍴CertificatePropIds
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

∇ Certificates←EnumCertificates hCertStore;pCertContext
     ⍝ Enumerate all the certificates in the store
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 Certificates←0⍴⊂''
 pCertContext←0
 :While ##.##.NULL≠pCertContext←##.##.CertEnumCertificatesInStore hCertStore pCertContext
     Certificates,←⊂##.Context.GetCertificate pCertContext
 :EndWhile
 :If ×↑⍴Certificates
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

∇ pCertContext←{pPrevCertContext}Find Parms;hCertStore;FindPara;pPrevCertContext;pvFindPara;CertEncodingType;FindFlags;FindType;RCode
     ⍝ Create certificate context from an encoded certificate.
     ⍝
     ⍝ Parms[1] = hCertStore Handle to the certificate store
     ⍝ Parms[2] = FindType   #.Win.CERT_FIND_ANY
     ⍝
     ⍝ Parms[1] = hCertStore Handle to the certificate store
     ⍝ Parms[2] = FindType   #.Win.CERT_FIND_EXISTING #.Win.CERT_FIND_ISSUER_OF or #.Win.CERT_FIND_SUBJECT_CERT
     ⍝ Parms[3] = FindPara   Certificate or pCertContext
     ⍝
     ⍝ Parms[1] = hCertStore Handle to the certificate store
     ⍝ Parms[2] = FindType   #.Win.CERT_FIND_SHA1_HASH #.Win.CERT_FIND_MD5_HASH #.Win.CERT_FIND_SIGNATURE_HASH or #.Win.CERT_FIND_KEY_IDENTIFIER
     ⍝ Parms[3] = FindPara   Hash String
     ⍝
     ⍝ Parms[1] = hCertStore Handle to the certificate store
     ⍝ Parms[2] = FindType   #.Win.CERT_FIND_SUBJECT_NAME or #.Win.CERT_FIND_ISSUER_NAME
     ⍝ Parms[3] = FindPara   Name String
     ⍝
     ⍝ Parms[1] = hCertStore Handle to the certificate store
     ⍝ Parms[2] = FindType   #.Win.CERT_FIND_PROPERTY or #.Win.CERT_FIND_KEY_SPEC
     ⍝ Parms[3] = FindPara   Property identifier or Matching #.Win.CERT_KEY_SPEC_PROP_ID number
     ⍝
     ⍝ Parms[1] = hCertStore Handle to the certificate store
     ⍝ Parms[2] = FindType   #.Win.CERT_FIND_SUBJECT_STR_A #.Win.CERT_FIND_ISSUER_STR_A
     ⍝ Parms[3] = FindPara   Name String
     ⍝
     ⍝ Parms[1] = hCertStore Handle to the certificate store
     ⍝ Parms[2] = FindType   #.Win.CERT_FIND_ENHKEY_USAGE
     ⍝ Parms[3] = FindPara   Vector of UsageIdentifiers
     ⍝ Parms[4] = FindFlags  #.Win.CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG+#.Win.CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG+#.Win.CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG+#.Win.CERT_FIND_NO_ENHKEY_USAGE_FLAG+#.Win.CERT_FIND_OR_ENHKEY_USAGE_FLAG+#.Win.CERT_FIND_VALID_ENHKEY_USAGE_FLAG
     ⍝
     ⍝ pPrevCertContext    = Last pCertContext returned by this function, NULL on first call. pPrevCertContext is ALWAYS freed by this function.
     ⍝
     ⍝ pCertContext        = Pointer to read-only CERT_CONTEXT structure. Must be freed by #.Win.Cert.Context.Free Certificate or on subsequent call
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 0=⎕NC'pPrevCertContext'
     pPrevCertContext←0
 :EndIf
 hCertStore FindType FindPara FindFlags←4↑Parms
 CertEncodingType←##.##.X509_ASN_ENCODING+##.##.PKCS_7_ASN_ENCODING
 :Select FindType
 :CaseList ##.##.CERT_KEY_SPEC_PROP_ID ##.##.CERT_FIND_PROPERTY
     pvFindPara←↑FindPara
     :If ##.##.NULL≠pCertContext←##.##.CertFindCertificateInStore hCertStore CertEncodingType FindFlags FindType pvFindPara pPrevCertContext
         #.RCode←##.##.ERROR_SUCCESS
     :Else
         #.RCode←##.##.GetLastError
     :EndIf
 :CaseList ##.##.CERT_FIND_SUBJECT_STR_A ##.##.CERT_FIND_ISSUER_STR_A
     pCertContext←0
     #.RCode←##.##.ERROR_CALL_NOT_IMPLEMENTED
 :CaseList ##.##.CERT_FIND_EXISTING ##.##.CERT_FIND_ISSUER_OF ##.##.CERT_FIND_SUBJECT_CERT
     :If ''≡0↑FindPara
         :If ##.##.NULL≠pvFindPara←##.Context.Create FindPara
             :If ##.##.NULL≠pCertContext←##.##.CertFindCertificateInStore hCertStore CertEncodingType FindFlags FindType pvFindPara pPrevCertContext
                 #.RCode←##.##.ERROR_SUCCESS
             :Else
                 #.RCode←##.##.GetLastError
             :EndIf
             ##.Context.Free pvFindPara
         :Else
             #.RCode←##.##.GetLastError
             pCertContext←0
         :EndIf
     :Else
         pvFindPara←↑FindPara
         :If ##.##.NULL≠pCertContext←##.##.CertFindCertificateInStore hCertStore CertEncodingType FindFlags FindType pvFindPara pPrevCertContext
             #.RCode←##.##.ERROR_SUCCESS
         :Else
             #.RCode←##.##.GetLastError
         :EndIf
     :EndIf
 :CaseList ##.##.CERT_FIND_SHA1_HASH ##.##.CERT_FIND_MD5_HASH ##.##.CERT_FIND_SIGNATURE_HASH ##.##.CERT_FIND_KEY_IDENTIFIER ##.##.CERT_FIND_SUBJECT_NAME ##.##.CERT_FIND_ISSUER_NAME
     :If ##.##.NULL≠pvFindPara←##.##.Mem.Alloc(4 ##.TxtInt 2↑⍴FindPara),FindPara
         (4 ##.TxtInt 8+pvFindPara)##.##.Mem.Write 4+pvFindPara
         :If ##.##.NULL≠pCertContext←##.##.CertFindCertificateInStore hCertStore CertEncodingType FindFlags FindType pvFindPara pPrevCertContext
             #.RCode←##.##.ERROR_SUCCESS
         :Else
             #.RCode←##.##.GetLastError
         :EndIf
         RCode←#.RCode ⋄ ##.##.Mem.Free pvFindPara ⋄ :If RCode≠#.Win.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
     :Else
         #.RCode←##.##.GetLastError
         pCertContext←0
     :EndIf
 :CaseList ##.##.CERT_FIND_SUBJECT_ATTR ##.##.CERT_FIND_ISSUER_ATTR ##.##.CERT_FIND_ENHKEY_USAGE
     pCertContext←0
     #.RCode←##.##.ERROR_CALL_NOT_IMPLEMENTED
 :Case ##.##.CERT_FIND_PUBLIC_KEY
     pCertContext←0
     #.RCode←##.##.ERROR_CALL_NOT_IMPLEMENTED
 :Case ##.##.CERT_FIND_CERT_ID
     pCertContext←0
     #.RCode←##.##.ERROR_CALL_NOT_IMPLEMENTED
 :Case ##.##.CERT_FIND_ENHKEY_USAGE
     pCertContext←0
     #.RCode←##.##.ERROR_CALL_NOT_IMPLEMENTED
 :Else
     pCertContext←0
     #.RCode←##.##.ERROR_INVALID_PARAMETER
 :EndSelect
∇

∇ Retrn←{pPrevIssuerContext}GetIssuer Parms;hCertStore;pSubjectContext;pIssuerContext;Flags;EncodingType;SubjectCertificate;Success
     ⍝ Retrieve pCertContext from CertStore for first/next issuer of specified subject certificate
     ⍝
     ⍝ Parms[1] = hCertStore      Handle to the certificate store
     ⍝ Parms[2] = pSubjectContext SubjectCertificate or pCertContext
     ⍝ Parms[3] = Flags           Check signature chain:   #.Win.CERT_STORE_SIGNATURE_FLAG     (1)
     ⍝                            Check validity chain:   +#.Win.CERT_STORE_TIME_VALIDITY_FLAG (2)
     ⍝                            Check revocation list:  +#.Win.CERT_STORE_REVOCATION_FLAG    (4)
     ⍝
     ⍝ pPrevIssuerContext       = Last pCertContext returned by this function, NULL on first call. pPrevCertContext is ALWAYS freed by this function.
     ⍝
     ⍝ Retrn[1] = pIssuerContext  Pointer to read-only CERT_CONTEXT structure. Must be freed by #.Win.Cert.Context.Free or on subsequent call
     ⍝ Retrn[2] = Flags           Set if signature fails:  #.Win.CERT_STORE_SIGNATURE_FLAG     (1)
     ⍝                            Set if validity fails:  +#.Win.CERT_STORE_TIME_VALIDITY_FLAG (2)
     ⍝                            Set if revocated:       +#.Win.CERT_STORE_REVOCATION_FLAG    (4)
     ⍝                            Set if CRL info missed: +#.Win.CERT_STORE_REVOCATION_FLAG+#.Win.CERT_STORE_NO_CRL_FLAG (4+65536)
     ⍝                            Set if no cert found:   +#.Win.CERT_STORE_NO_ISSUER_FLAG     (131072)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 0=⎕NC'pPrevIssuerContext'
     pPrevIssuerContext←0
 :EndIf
 hCertStore pSubjectContext Flags←3↑Parms
 :If ''≡0↑pSubjectContext
     EncodingType←##.##.X509_ASN_ENCODING+##.##.PKCS_7_ASN_ENCODING
     SubjectCertificate←##.##.IntTxt pSubjectContext
     :If ##.##.NULL≠pSubjectContext←##.##.CertCreateCertificateContext EncodingType SubjectCertificate(↑⍴SubjectCertificate)
         :If ##.##.NULL≠↑pIssuerContext Flags←##.##.CertGetIssuerCertificateFromStore hCertStore pSubjectContext pPrevIssuerContext Flags
             #.RCode←##.##.ERROR_SUCCESS
             Retrn←pIssuerContext Flags
         :Else
             #.RCode←##.##.GetLastError
             Retrn←pIssuerContext Flags
         :EndIf
         Success←##.##.CertFreeCertificateContext pSubjectContext
     :Else
         #.RCode←##.##.GetLastError
         Retrn←0 0
     :EndIf
 :ElseIf ##.##.NULL≠↑pIssuerContext Flags←##.##.CertGetIssuerCertificateFromStore hCertStore pSubjectContext pPrevIssuerContext Flags
     #.RCode←##.##.ERROR_SUCCESS
     Retrn←pIssuerContext Flags
 :Else
     #.RCode←##.##.GetLastError
     Retrn←pIssuerContext Flags
 :EndIf
∇

∇ Issuer←{SystemStores}GetIssuerCertificate SubjectCertificate;Flags;FlagMask;Issuers;EncodingType;pSubjectContext;SystemStore;hSystemStore;pIssuerContext;IssuerFlags;ValidFlag;IssuerCertEncodingType;pbIssuerCertEncoded;cbIssuerCertEncoded;pIssuerCertInfo;IssuerCertInfo;IssuerCertNotAfter;IssuerCertificate
     ⍝ Retrieve best fitting issuer certificate for a subject certificate
     ⍝
     ⍝ Issuer[1] = IssuerCertificate
     ⍝ Issuer[2] = IssuerFlags        #.Win.CERT_STORE_SIGNATURE_FLAG+#.Win.CERT_STORE_TIME_VALIDITY_FLAG+#.Win.CERT_STORE_REVOCATION_FLAG+#.Win.CERT_STORE_NO_ISSUER_FLAG
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 0=⎕NC'SystemStores'
     SystemStores←'Root' 'CA' 'My'
 :EndIf
 Flags←##.##.CERT_STORE_SIGNATURE_FLAG+##.##.CERT_STORE_TIME_VALIDITY_FLAG+##.##.CERT_STORE_REVOCATION_FLAG
 FlagMask←##.##.BitInt ##.##.CERT_STORE_REVOCATION_FLAG+##.##.CERT_STORE_NO_CRL_FLAG
 Issuers←0⍴⊂'' 0(7⍴0)
 EncodingType←##.##.X509_ASN_ENCODING+##.##.PKCS_7_ASN_ENCODING
 SubjectCertificate←##.##.IntTxt SubjectCertificate
 :If ##.##.NULL≠pSubjectContext←##.##.CertCreateCertificateContext EncodingType SubjectCertificate(↑⍴SubjectCertificate)
     :For SystemStore :In SystemStores
         :If ##.##.NULL≠hSystemStore←##.##.CertOpenSystemStore ##.##.NULL SystemStore
             pIssuerContext←0
             :While ##.##.NULL≠↑pIssuerContext IssuerFlags←##.##.CertGetIssuerCertificateFromStore hSystemStore pSubjectContext pIssuerContext Flags
                 IssuerFlags←##.##.BitInt IssuerFlags
                 :If FlagMask∧.=FlagMask∧IssuerFlags
                     IssuerFlags←IssuerFlags∧~FlagMask
                 :EndIf
                 IssuerFlags←##.##.IntBit IssuerFlags
                 IssuerCertEncodingType pbIssuerCertEncoded cbIssuerCertEncoded pIssuerCertInfo←4 ##.##.IntTxt 16 ##.##.Mem.Read pIssuerContext
                 IssuerCertificate←cbIssuerCertEncoded ##.##.Mem.Read pbIssuerCertEncoded
                 IssuerCertInfo←4 ##.##.IntTxt 48 ##.##.Mem.Read pIssuerCertInfo
                 IssuerCertNotAfter←1 1 0 1 1 1 1 1/2⊃##.##.FileTimeToSystemTime(4294967296|IssuerCertInfo[11 12])0
                 Issuers,←⊂IssuerCertificate IssuerFlags IssuerCertNotAfter
             :EndWhile
             ValidFlag←##.##.CertCloseStore hSystemStore 0
         :EndIf
     :EndFor
     ValidFlag←##.##.CertFreeCertificateContext pSubjectContext
     :Select ↑⍴Issuers←⊃∪Issuers
     :Case 0
         IssuerCertificate←''
         IssuerFlags←##.##.CERT_STORE_NO_ISSUER_FLAG
     :Case 1
         IssuerCertificate IssuerFlags←2↑↑⊂[2]Issuers
     :Else
         :If 0∨.=Issuers[;2]
             Issuers←(0=Issuers[;2])⌿Issuers
         :EndIf
         :If 1=↑⍴Issuers
             IssuerCertificate IssuerFlags←2↑↑⊂[2]Issuers
         :Else
             :If 1=↑⍴Issuers←(Issuers[1;3]≡¨Issuers[;3])⌿Issuers←Issuers[⍒⊃Issuers[;3];]
                 IssuerCertificate IssuerFlags←2↑↑⊂[2]Issuers
             :Else
                 Issuers←Issuers[⍒↑∘⍴¨Issuers[;1];]
                 IssuerCertificate IssuerFlags←2↑↑⊂[2]Issuers
             :EndIf
         :EndIf
     :EndSelect
     Issuer←IssuerCertificate IssuerFlags
 :Else
     #.RCode←##.##.GetLastError
     Issuer←'' 0
 :EndIf
∇

∇ hCertStore←Open Parms;StoreProvider;EncodingType;hCryptProv;Flags;Para
     ⍝ Open a certificate store using a specified store provider type
     ⍝ Parms[1] = StoreProvider eg #.Win.CERT_STORE_PROV_FILENAME #.Win.CERT_STORE_PROV_REG #.Win.CERT_STORE_PROV_SYSTEM #.Win.CERT_STORE_PROV_FILE
     ⍝ Parms[2] = EncodingType  (0=def) If MSG PKCS7 FILENAME: #.Win.X509_ASN_ENCODING+#.Win.PKCS_7_ASN_ENCODING
     ⍝ Parms[3] = hCryptProv    (0=def) Handle to a cryptographic provider
     ⍝ Parms[4] = Flags         eg #.Win.CERT_SYSTEM_STORE_CURRENT_USER #.Win.CERT_SYSTEM_STORE_LOCAL_MACHINE
     ⍝ Parms[5] = Para          FileName or RegPath('My' 'CA' 'AddressBook' 'Root' 'SPC' 'trust') or hFile
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 StoreProvider EncodingType hCryptProv Flags Para←5↑Parms
 :If 0=EncodingType
 :AndIf StoreProvider∊##.##.CERT_STORE_PROV_MSG ##.##.CERT_STORE_PROV_PKCS7 ##.##.CERT_STORE_PROV_FILENAME
     EncodingType←##.##.X509_ASN_ENCODING+##.##.PKCS_7_ASN_ENCODING
 :EndIf
 :If 82≠⎕DR Para
     hCertStore←##.##.CertOpenStoreI StoreProvider EncodingType hCryptProv Flags Para
 :Else
     hCertStore←##.##.CertOpenStoreT StoreProvider EncodingType hCryptProv Flags Para
 :EndIf
 :If ##.##.NULL≠hCertStore
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
     hCertStore←##.##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ hCertStore←OpenSystem Parms;hProv;SubsystemProtocol
     ⍝ Simplified function to open most common system certificate stores
     ⍝
     ⍝ Parms[1] = hProv             (opt) Handle of a cryptographic service provider (←#.Win.Crypt.AcquireContext) or #.Win.NULL
     ⍝ Parms[2] = SubsystemProtocol (opt) String naming a system store: 'My'(def) 'CA' 'AddressBook' 'Root' 'SPC' or 'trust' ...
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 1<≡Parms
     hProv SubsystemProtocol←2↑Parms
 :ElseIf 82=⎕DR Parms
     hProv←##.##.NULL
     SubsystemProtocol←,Parms
 :Else
     hProv←↑Parms
     SubsystemProtocol←''
 :EndIf
 :If ''≡SubsystemProtocol
     SubsystemProtocol←'My'
 :EndIf
 :If ##.##.NULL≠hCertStore←##.##.CertOpenSystemStore hProv SubsystemProtocol
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
     hCertStore←##.##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ {ValidFlagOrStore}←Save Parms;hCertStore;EncodingType;SaveAs;SaveTo;SaveToPara;FileName;hFile;cbData;pbData
     ⍝ Save certificate store to file or memory BLOB
     ⍝ Parms[1] = hCertStore    handle of certificate store to be saved
     ⍝ Parms[2] = EncodingType  (0=def) If SaveAs=..PKCS7: #.Win.X509_ASN_ENCODING+#.Win.PKCS_7_ASN_ENCODING
     ⍝ Parms[3] = SaveAs        Serialized store with props (#.Win.CERT_STORE_SAVE_AS_STORE) or PKCS #7 signed msg w/o props (#.Win.CERT_STORE_SAVE_AS_PKCS7)
     ⍝ Parms[4] = SaveToPara    (opt) FileName or FileHandle or if omitted, return store in ValidFlagOrStore
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 hCertStore EncodingType SaveAs SaveToPara←4↑Parms
 :If 0=EncodingType
 :AndIf SaveAs∊##.##.CERT_STORE_SAVE_AS_PKCS7
     EncodingType←##.##.X509_ASN_ENCODING+##.##.PKCS_7_ASN_ENCODING
 :EndIf
 :If ''≡0↑SaveToPara
     SaveTo←##.##.CERT_STORE_SAVE_TO_FILENAME_A
     FileName←SaveToPara
     :If ##.##.FALSE≠ValidFlagOrStore←##.##.CertSaveStoreT hCertStore EncodingType SaveAs SaveTo FileName 0
         #.RCode←##.##.ERROR_SUCCESS
     :Else
         #.RCode←##.##.GetLastError
     :EndIf
 :ElseIf 0≠↑SaveToPara
     SaveTo←##.##.CERT_STORE_SAVE_TO_FILE
     hFile←SaveToPara
     :If ##.##.FALSE≠ValidFlagOrStore←##.##.CertSaveStoreI hCertStore EncodingType SaveAs SaveTo hFile 0
         #.RCode←##.##.ERROR_SUCCESS
     :Else
         #.RCode←##.##.GetLastError
     :EndIf
 :Else
     SaveTo←##.##.CERT_STORE_SAVE_TO_MEMORY
     cbData pbData←0
     :If ##.##.FALSE≠↑ValidFlagOrStore(cbData pbData)←¨##.##.CertSaveStoreM hCertStore EncodingType SaveAs SaveTo(cbData pbData)0
     :AndIf ##.##.NULL≠pbData←##.##.Mem.Alloc cbData
     :AndIf ##.##.FALSE≠↑ValidFlagOrStore(cbData pbData)←¨##.##.CertSaveStoreM hCertStore EncodingType SaveAs SaveTo(cbData pbData)0
     :AndIf ##.##.NULL≠↑⍴ValidFlagOrStore←cbData ##.##.Mem.Free pbData
         #.RCode←##.##.ERROR_SUCCESS
     :Else
         ValidFlagOrStore←0
         #.RCode←##.##.GetLastError
     :EndIf
 :EndIf
∇

:Namespace Samples
⎕IO ⎕ML ⎕WX←1 3 1

∇ CertContexts←AllStores;hCertStore;Certs;Store;pkcs7;MyCerts;CACerts;RootCerts;AddressBookCerts;SPCCerts;trustCerts;AllCerts;AllCert;Index
 #.Win.Init
 :If #.Win.INVALID_HANDLE_VALUE≠hCertStore←#.Win.Cert.Store.Open #.Win.CERT_STORE_PROV_SYSTEM 0 0 #.Win.CERT_SYSTEM_STORE_CURRENT_USER'My'
     MyCerts←#.Win.Cert.Store.EnumCertificates hCertStore
     #.Win.Cert.Store.Close hCertStore
 :Else
     MyCerts←0⍴⊂''
 :EndIf
 ⎕←'MyCerts'(⍴MyCerts)
 :If #.Win.INVALID_HANDLE_VALUE≠hCertStore←#.Win.Cert.Store.Open #.Win.CERT_STORE_PROV_SYSTEM 0 0 #.Win.CERT_SYSTEM_STORE_CURRENT_USER'CA'
     CACerts←#.Win.Cert.Store.EnumCertificates hCertStore
     #.Win.Cert.Store.Close hCertStore
 :Else
     CACerts←0⍴⊂''
 :EndIf
 ⎕←'CACerts'(⍴CACerts)
 :If #.Win.INVALID_HANDLE_VALUE≠hCertStore←#.Win.Cert.Store.Open #.Win.CERT_STORE_PROV_SYSTEM 0 0 #.Win.CERT_SYSTEM_STORE_CURRENT_USER'AddressBook'
     AddressBookCerts←#.Win.Cert.Store.EnumCertificates hCertStore
     #.Win.Cert.Store.Close hCertStore
 :Else
     AddressBookCerts←0⍴⊂''
 :EndIf
 ⎕←'AddressBookCerts'(⍴AddressBookCerts)
 :If #.Win.INVALID_HANDLE_VALUE≠hCertStore←#.Win.Cert.Store.Open #.Win.CERT_STORE_PROV_SYSTEM 0 0 #.Win.CERT_SYSTEM_STORE_CURRENT_USER'Root'
     RootCerts←#.Win.Cert.Store.EnumCertificates hCertStore
     #.Win.Cert.Store.Close hCertStore
 :Else
     RootCerts←0⍴⊂''
 :EndIf
 ⎕←'RootCerts'(⍴RootCerts)
 :If #.Win.INVALID_HANDLE_VALUE≠hCertStore←#.Win.Cert.Store.Open #.Win.CERT_STORE_PROV_SYSTEM 0 0 #.Win.CERT_SYSTEM_STORE_CURRENT_USER'SPC'
     SPCCerts←#.Win.Cert.Store.EnumCertificates hCertStore
     #.Win.Cert.Store.Close hCertStore
 :Else
     SPCCerts←0⍴⊂''
 :EndIf
 ⎕←'SPCCerts'(⍴SPCCerts)
 :If #.Win.INVALID_HANDLE_VALUE≠hCertStore←#.Win.Cert.Store.Open #.Win.CERT_STORE_PROV_SYSTEM 0 0 #.Win.CERT_SYSTEM_STORE_CURRENT_USER'trust'
     trustCerts←#.Win.Cert.Store.EnumCertificates hCertStore
     #.Win.Cert.Store.Close hCertStore
 :Else
     trustCerts←0⍴⊂''
 :EndIf
 ⎕←'trustCerts'(⍴trustCerts)
 AllCerts←MyCerts,CACerts,RootCerts,AddressBookCerts,SPCCerts,trustCerts
 ⎕←'AllCerts'(⍴AllCerts)
     
     
 :If #.Win.INVALID_HANDLE_VALUE≠hCertStore←#.Win.Cert.Store.Open #.Win.CERT_STORE_PROV_FILENAME 0 0 #.Win.CERT_STORE_OPEN_EXISTING_FLAG'C:\TestStore.SST'
     ⍴Certs←#.Win.Cert.Store.EnumCertificates hCertStore
     ⍴CertContexts←#.Win.Cert.Store.EnumCertContexts hCertStore
     
     Store←#.Win.Cert.Store.Save hCertStore 0 #.Win.CERT_STORE_SAVE_AS_STORE
     pkcs7←#.Win.Cert.Store.Save hCertStore 0 #.Win.CERT_STORE_SAVE_AS_PKCS7
     
     :For Index :In 1,↑⍴Certs
         Del hCertStore(Index⊃Certs)
         #.RCode #.RText
     :EndFor
     ⍴Certs←#.Win.Cert.Store.EnumCertificates hCertStore
     ⍴CertContexts←#.Win.Cert.Store.EnumCertContexts hCertStore
     
     #.Win.Cert.Store.Save hCertStore 0 #.Win.CERT_STORE_SAVE_AS_STORE'C:\TestStore.SST'
     #.Win.Cert.Store.Save hCertStore 0 #.Win.CERT_STORE_SAVE_AS_PKCS7'C:\TestPkcs7.P7B' ⍝ or '.SPC'
     
     :For AllCert :In AllCerts
         #.Win.Cert.Store.Add hCertStore #.Win.CERT_STORE_ADD_ALWAYS AllCert
     :EndFor
     ⍴Certs←#.Win.Cert.Store.EnumCertificates hCertStore
     ⍴CertContexts←#.Win.Cert.Store.EnumCertContexts hCertStore
     
     :For AllCert :In AllCerts
         #.Win.Cert.Store.Add hCertStore #.Win.CERT_STORE_ADD_ALWAYS AllCert
     :EndFor
     ⍴Certs←#.Win.Cert.Store.EnumCertificates hCertStore
     ⍴CertContexts←#.Win.Cert.Store.EnumCertContexts hCertStore
     
     :For AllCert :In AllCerts
         #.Win.Cert.Store.Add hCertStore #.Win.CERT_STORE_ADD_REPLACE_EXISTING AllCert
     :EndFor
     ⍴Certs←#.Win.Cert.Store.EnumCertificates hCertStore
     ⍴CertContexts←#.Win.Cert.Store.EnumCertContexts hCertStore
     
     #.Win.Cert.Store.Close hCertStore
     
 :EndIf
∇

∇ CertDatas←EnumProperties;hCertStore;MyCerts;MyCertPropIds;CertEncoded;pCertContext;PropIds;PropId;Properties;Property;MyCertProperties
 #.Win.Init
 :If #.Win.INVALID_HANDLE_VALUE≠hCertStore←#.Win.Cert.Store.Open #.Win.CERT_STORE_PROV_SYSTEM 0 0 #.Win.CERT_SYSTEM_STORE_CURRENT_USER'My'
     MyCerts←#.Win.Cert.Store.EnumCertificates hCertStore
     MyCertPropIds←0⍴⊂⍬
     MyCertProperties←0⍴⊂⍬
     :For CertEncoded :In MyCerts
         pCertContext←#.Win.Cert.Store.Find hCertStore #.Win.CERT_FIND_EXISTING CertEncoded
         PropIds←#.Win.Cert.Context.EnumProperties pCertContext
         Properties←0⍴⊂''
         :For PropId :In PropIds
             Property←#.Win.Cert.Context.GetProperty pCertContext PropId
             Properties,←⊂Property
         :EndFor
         MyCertPropIds,←⊂PropIds
         MyCertProperties,←⊂Properties
         #.Win.Cert.Context.Free pCertContext
     :EndFor
     #.Win.Cert.Store.Close hCertStore
 :Else
     MyCerts←0⍴⊂''
 :EndIf
 ⎕←'MyCerts'(⍴MyCerts)
 ⎕←'PropIds'(↑∘⍴¨MyCertPropIds)
 CertDatas←MyCerts MyCertPropIds MyCertProperties
∇

∇ Count←SaveStore;hCertStore;Certs;CertContexts;Store;pkcs7
 #.Win.Init
 :If #.Win.INVALID_HANDLE_VALUE≠hCertStore←#.Win.Cert.Store.Open #.Win.CERT_STORE_PROV_SYSTEM 0 0 #.Win.CERT_SYSTEM_STORE_CURRENT_USER'My'
     Certs←#.Win.Cert.Store.EnumCertificates hCertStore
     CertContexts←#.Win.Cert.Store.EnumCertContexts hCertStore
     Count←↑⍴CertContexts
     
     Store←#.Win.Cert.Store.Save hCertStore 0 #.Win.CERT_STORE_SAVE_AS_STORE
     pkcs7←#.Win.Cert.Store.Save hCertStore(#.Win.X509_ASN_ENCODING+#.Win.PKCS_7_ASN_ENCODING)#.Win.CERT_STORE_SAVE_AS_PKCS7
     
     #.Win.Cert.Store.Save hCertStore 0 #.Win.CERT_STORE_SAVE_AS_STORE'C:\TestStore.SST'
     #.Win.Cert.Store.Save hCertStore(#.Win.X509_ASN_ENCODING+#.Win.PKCS_7_ASN_ENCODING)#.Win.CERT_STORE_SAVE_AS_PKCS7'C:\TestPkcs7.SPC'
     
     #.Win.Cert.Store.Close hCertStore
 :EndIf
∇

:EndNamespace 
:EndNamespace 
:EndNamespace 
:Namespace Char
⎕IO ⎕ML ⎕WX←1 3 1

∇ WideCharStr←{Parms}ByteToWide MultiByteStr;CodePage;Flags;cbMultiByte;cchWideChar
     ⍝ Map a character (def.ANSI) string to a wide-character (Unicode) string
     ⍝
     ⍝ Parms[1] = CodePage (opt.) (#.Win.CP_ACP #.Win.CP_OEMCP #.Win.CP_MACCP #.Win.CP_THREAD_ACP #.Win.CP_SYMBOL #.Win.CP_UTF7 #.Win.CP_UTF8 437 850 852 866 932 936 949 1250 1251 1252 1253 1254 1255 1256 1257 1258 10000 20261 20866 21866 28591 28592 28594 28595 28597 28599)
     ⍝ Parms[2] = Flags    (opt.) (#.Win.MB_PRECOMPOSED #.Win.MB_COMPOSITE #.Win.MB_USEGLYPHCHARS #.Win.MB_ERR_INVALID_CHARS)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×cchWideChar←2×cbMultiByte←↑⍴MultiByteStr←##.IntTxt MultiByteStr
     :If ×⎕NC'Parms'
         CodePage Flags←2↑Parms
         cchWideChar WideCharStr←##.MultiByteToWideChar CodePage Flags MultiByteStr cbMultiByte(2×cchWideChar)cchWideChar
     :Else
         cchWideChar WideCharStr←##.MultiByteToWideChar #.Win.CP_ACP 0 MultiByteStr cbMultiByte(2×cchWideChar)cchWideChar
     :EndIf
     :If ×cchWideChar
         WideCharStr←(2×cchWideChar)↑WideCharStr
         #.RCode←##.ERROR_SUCCESS
     :Else
         WideCharStr←''
         #.RCode←##.GetLastError
     :EndIf
 :Else
     WideCharStr←''
     #.RCode←##.ERROR_SUCCESS
 :EndIf
∇

∇ Bool←IsValidCodePage CodePage
     ⍝ Determine whether a specified code page is valid.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If Bool←##.IsValidCodePage CodePage
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ MultiByteStr←{Parms}WideToByte WideCharStr;CodePage;Flags;cbMultiByte;cchWideChar;DefaultChar
     ⍝ Map a a wide-character (Unicode) string to character (def.ANSI) string
     ⍝
     ⍝ Parms[1] = CodePage    (opt.) (#.Win.CP_ACP #.Win.CP_OEMCP #.Win.CP_MACCP #.Win.CP_THREAD_ACP #.Win.CP_SYMBOL #.Win.CP_UTF7 #.Win.CP_UTF8 437 850 852 866 932 936 949 1250 1251 1252 1253 1254 1255 1256 1257 1258 10000 20261 20866 21866 28591 28592 28594 28595 28597 28599)
     ⍝ Parms[2] = Flags       (opt.) (#.Win.WC_COMPOSITECHECK #.Win.WC_DISCARDNS #.Win.WC_SEPCHARS #.Win.WC_DEFAULTCHAR #.Win.WC_NO_BEST_FIT_CHARS)
     ⍝ Parms[3] = DefaultChar (opt.) default for unmappable characters
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×cbMultiByte←4×cchWideChar←↑0 2⊤⍴WideCharStr←##.IntTxt WideCharStr
     :If ×⎕NC'Parms'
         :If 3=↑⍴Parms
             CodePage Flags DefaultChar←Parms
             DefaultChar←##.IntTxt DefaultChar
             MultiByteStr←↑↑/##.WideCharToMultiByteD CodePage Flags WideCharStr cchWideChar cbMultiByte cbMultiByte DefaultChar 0
         :Else
             CodePage Flags←2↑Parms
             MultiByteStr←↑↑/##.WideCharToMultiByte CodePage Flags WideCharStr cchWideChar cbMultiByte cbMultiByte 0 0
         :EndIf
     :Else
         MultiByteStr←↑↑/##.WideCharToMultiByte #.Win.CP_ACP 0 WideCharStr cchWideChar cbMultiByte cbMultiByte 0 0
     :EndIf
     :If ×↑⍴MultiByteStr
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     MultiByteStr←''
     #.RCode←##.ERROR_SUCCESS
 :EndIf
∇

:EndNamespace 
:Namespace Clipboard
⎕IO ⎕ML ⎕WX←1 3 1

∇ {ValidFlag}←ChangeChain Parms;hWndRemove;hWndNewNext
     ⍝ Remove a specified window from the chain of clipboard viewers
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWndRemove hWndNewNext←Parms
 :If ValidFlag←##.ChangeClipboardChain hWndRemove hWndNewNext
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←Close
     ⍝ Close the clipboard
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.CloseClipboard
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Count←CountFormats
     ⍝ Retrieve the number of different data formats currently on the clipboard
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠Count←##.CountClipboardFormats
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←Empty
     ⍝ Empty and free handles to data in the clipboard. Ownership gets to the window that currently has the clipboard open
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.EmptyClipboard
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Formats←EnumFormats;Format
     ⍝ Enumerate the data formats currently available on the clipboard
     ⍝
     ⍝ Formats = Vector of the following or special formats:
     ⍝
     ⍝ #.Win.CF_TEXT (1)          #.Win.CF_DIF (5)      #.Win.CF_PALETTE (9)   #.Win.CF_UNICODETEXT (13)
     ⍝ #.Win.CF_BITMAP (2)        #.Win.CF_TIFF (6)     #.Win.CF_PENDATA (10)  #.Win.CF_ENHMETAFILE (14)
     ⍝ #.Win.CF_METAFILEPICT (3)  #.Win.CF_OEMTEXT (7)  #.Win.CF_RIFF (11)     #.Win.CF_HDROP (15)
     ⍝ #.Win.CF_SYLK (4)          #.Win.CF_DIB (8)      #.Win.CF_WAVE (12)     #.Win.CF_LOCALE (16)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 Formats←⍬
 Format←0
 :While ##.NULL≠Format←##.EnumClipboardFormats Format
     Formats,←⊂Format
 :EndWhile
 :If ×↑⍴Formats
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hMem←GetData Format
     ⍝ Retrieve data from open clipboard in a specified format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠hMem←##.GetClipboardData Format
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ FormatName←GetFormatName Format;MaxCount
     ⍝ Retrieve from the clipboard the name of the specified registered format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 MaxCount←256
 :If ×↑⍴FormatName←↑↑/##.GetClipboardFormatName Format MaxCount MaxCount
     #.RCode←##.ERROR_SUCCESS
 :ElseIf Format∊⍳17
     FormatName←Format⊃'ANSI Text' 'Bitmap' 'Metafile Picture' 'Symbolic Link' 'DIF' 'TIFF' 'OEM Text' 'Bitmap' 'Palette' 'Pen Data' 'RIFF Audio' 'WAVE Audio' 'Unicode Text' 'Enhanced Metafile' 'HDROP File List' 'Locale Identifier' 'Bitmap V5'
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hWnd←GetOpenWindow
     ⍝ Retrieve the handle to the window that currently has the clipboard open
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWnd←##.GetOpenClipboardWindow
∇

∇ hWnd←GetOwner
     ⍝ Retrieve the window handle of the current owner of the clipboard
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠hWnd←##.GetClipboardOwner
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Format←GetPriorityFormat FormatPriorityList;cFormats
     ⍝ Retrieve the first available clipboard format in the specified list
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 cFormats←↑⍴FormatPriorityList
 :If 0<Format←##.GetPriorityClipboardFormat FormatPriorityList cFormats
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hWnd←GetViewer
     ⍝ Retrieve handle to the first window in the clipboard viewer chain
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠hWnd←##.GetClipboardViewer
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ AvailableFlag←IsFormatAvailable Format
     ⍝ Determine whether the clipboard contains data in the specified format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If AvailableFlag←##.IsClipboardFormatAvailable Format
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←Open hWndNewOwner
     ⍝ Open the clipboard for examination and prevent other applications from modifying the clipboard content
     ⍝
     ⍝ hWndNewOwner = Window handle associated with open clipboard. #.Win.NULL = current task
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.OpenClipboard hWndNewOwner
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Data←ReadData Format;hMem;pMem;cbData;iFile
     ⍝ Retrieve data from open clipboard in a specified format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠hMem←##.GetClipboardData Format
     :If Format=##.CF_HDROP
         Data←0⍴⊂''
         :For iFile :In ¯1+⍳↑##.DragQueryFile hMem ¯1 0 0
             Data,←↑/##.DragQueryFile hMem iFile 1024 1024
         :EndFor
         :If ×↑⍴Data
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
         :EndIf
     :Else
         :If 0≠pMem←##.Mem.Lock hMem
             cbData←##.Mem.Size hMem
             Data←cbData ##.Mem.Read pMem
             ##.Mem.Unlock hMem
             :If Format∊##.CF_TEXT ##.CF_OEMTEXT
                 Data←{(¯1+⍵⍳↑⎕AV)↑⍵}Data
             :ElseIf Format=##.CF_UNICODETEXT
                 Data←∊{(¯1+⍵⍳⊂2⍴↑⎕AV)↑⍵}{((⍴⍵)↑2/⍳↑0 2⊤↑⍴⍵)⊂⍵}Data
             :ElseIf Format=##.CF_LOCALE
             :AndIf 4=↑⍴Data
                 Data←↑4 ##.IntTxt Data
             :EndIf
         :Else
             Data←''
         :EndIf
     :EndIf
     
     
 :Else
     #.RCode←##.GetLastError
     Data←''
 :EndIf
∇

∇ Format←RegisterFormat FormatName
     ⍝ Register a new clipboard format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠Format←##.RegisterClipboardFormat FormatName
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hMem←SetData Parms;Format
     ⍝ Place data on the clipboard in a specified clipboard format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 Format hMem←2↑Parms
 :If 0≠hMem←##.SetClipboardData Format hMem
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hWndNextViewer←SetViewer hWndNewViewer
     ⍝ Add the specified window to the chain of clipboard viewers
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠hWndNextViewer←##.SetClipboardViewer hWndNewViewer
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

:Namespace Samples
⎕IO ⎕ML ⎕WX←1 3 1

∇ ReadTextFormats;Formats;FormatNames;Format
 #.Win.Clipboard.Open 0
 Formats←#.Win.Clipboard.EnumFormats
 FormatNames←#.Win.Clipboard.GetFormatName¨Formats
 ⎕←'Formate in der Zwischenablage:'
 ⎕←⊃(⊂¨⍕¨Formats),¨⊂¨FormatNames
 ⎕←''
 :For Format :In Formats∩#.Win.CF_TEXT #.Win.CF_OEMTEXT #.Win.CF_UNICODETEXT #.Win.CF_HDROP #.Win.CF_LOCALE
     ⎕←'Format: ',#.Win.Clipboard.GetFormatName Format
     ⎕←'Daten:  ',#.Win.Clipboard.ReadData Format
     ⎕←''
 :EndFor
 #.Win.Clipboard.Close
∇

:EndNamespace 
:EndNamespace 
:Namespace Crypt
⎕IO ⎕ML ⎕WX←1 3 1

∇ hProv←AcquireContext Parms;Container;ProvName;ProvType;Flags;VOID
     ⍝ Acquire a handle to a CSP and a key container.
     ⍝
     ⍝ Parms[1] = Container (default: '' = NULL → Username)
     ⍝ Parms[2] = ProvName  (default: '' = NULL     comp. #.Win.Crypt.SetProvider)
     ⍝ Parms[3] = ProvType  (default: PROV_RSA_FULL comp. #.Win.Crypt.SetProvider)
     ⍝ Parms[4] = Flags     (default: NULL) combinations: #.Win.CRYPT_VERIFYCONTEXT+#.Win.CRYPT_NEWKEYSET+#.Win.CRYPT_DELETEKEYSET+#.Win.CRYPT_MACHINE_KEYSET
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     Container←,Parms
     ProvName←''
     ProvType←##.PROV_RSA_FULL
     Flags←0
 :Else
     :Select ↑⍴Parms
     :Case 1
         Container←,↑Parms
         ProvName←''
         ProvType←##.PROV_RSA_FULL
         Flags←0
     :Case 2
         Container ProvName←Parms
         ProvType←##.PROV_RSA_FULL
         Flags←0
     :Case 3
         Container ProvName ProvType←Parms
         Flags←0
     :Else
         Container ProvName ProvType Flags←4↑Parms
     :EndSelect
 :EndIf
 :If 0=ProvType
     ProvType←##.PROV_RSA_FULL
 :EndIf
 :Select ProvName Container∊⊂''
 :Case 0 0
     :If ↑VOID hProv←##.CryptAcquireContextCP 1 Container ProvName ProvType Flags
         #.RCode←##.ERROR_SUCCESS
     :ElseIf (##.BitInt ##.CRYPT_NEWKEYSET)∨.∧##.BitInt Flags←##.IntBit(~##.BitInt ##.CRYPT_DELETEKEYSET)∧##.BitInt Flags
     :AndIf ↑##.CryptAcquireContextCP 1 Container ProvName ProvType(Flags+##.CRYPT_DELETEKEYSET-##.CRYPT_NEWKEYSET)
     :AndIf ↑VOID hProv←##.CryptAcquireContextCP 1 Container ProvName ProvType Flags
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         hProv←##.INVALID_HANDLE_VALUE
     :EndIf
 :Case 0 1
     :If ↑VOID hProv←##.CryptAcquireContextP 1 ##.NULL ProvName ProvType Flags
         #.RCode←##.ERROR_SUCCESS
     :ElseIf (##.BitInt ##.CRYPT_NEWKEYSET)∨.∧##.BitInt Flags←##.IntBit(~##.BitInt ##.CRYPT_DELETEKEYSET)∧##.BitInt Flags
     :AndIf ↑##.CryptAcquireContextP 1 ##.NULL ProvName ProvType(Flags+##.CRYPT_DELETEKEYSET-##.CRYPT_NEWKEYSET)
     :AndIf ↑VOID hProv←##.CryptAcquireContextP 1 ##.NULL ProvName ProvType Flags
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         hProv←##.INVALID_HANDLE_VALUE
     :EndIf
 :Case 1 0
     :If ↑VOID hProv←##.CryptAcquireContextC 1 Container ##.NULL ProvType Flags
         #.RCode←##.ERROR_SUCCESS
     :ElseIf (##.BitInt ##.CRYPT_NEWKEYSET)∨.∧##.BitInt Flags←##.IntBit(~##.BitInt ##.CRYPT_DELETEKEYSET)∧##.BitInt Flags
     :AndIf ↑##.CryptAcquireContextC 1 Container ##.NULL ProvType(Flags+##.CRYPT_DELETEKEYSET-##.CRYPT_NEWKEYSET)
     :AndIf ↑VOID hProv←##.CryptAcquireContextC 1 Container ##.NULL ProvType Flags
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         hProv←##.INVALID_HANDLE_VALUE
     :EndIf
 :Case 1 1
     :If ↑VOID hProv←##.CryptAcquireContext 1 ##.NULL ##.NULL ProvType Flags
         #.RCode←##.ERROR_SUCCESS
     :ElseIf (##.BitInt ##.CRYPT_NEWKEYSET)∨.∧##.BitInt Flags←##.IntBit(~##.BitInt ##.CRYPT_DELETEKEYSET)∧##.BitInt Flags
     :AndIf ↑##.CryptAcquireContext 1 ##.NULL ##.NULL ProvType(Flags+##.CRYPT_DELETEKEYSET-##.CRYPT_NEWKEYSET)
     :AndIf ↑VOID hProv←##.CryptAcquireContext 1 ##.NULL ##.NULL ProvType Flags
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         hProv←##.INVALID_HANDLE_VALUE
     :EndIf
     
 :EndSelect
 :If VOID
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hProv←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ hHash←CreateHash Parms;hProv;Algid;hKey;Flags;VOID
     ⍝ Initiate the hashing of a stream of data
     ⍝
     ⍝ Parms[1] = hProv
     ⍝ Parms[2] = Algid (#.Win.CALG_HMAC #.Win.CALG_MAC #.Win.CALG_MD2 #.Win.CALG_MD5 #.Win.CALG_SHA or #.Win.CALG_SSL3_SHAMD5)
     ⍝ Parms[3] = hKey  If HMAC or MAC: key for the hash, if nonkeyed algorithm: zero
     ⍝ Parms[4] = Flags (res.)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hProv Algid hKey Flags←4↑Parms
 :If ↑VOID hHash←##.CryptCreateHash hProv Algid hKey Flags 1
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hHash←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ Data←Data Decrypt Parms;hKey;hHash;Final;Flags;Data;DataLen;VOID;hRead;hWrite;SizeRead;OffsetRead;OffsetWrite;SizeWritten;hMem;RepeatFinal;Increment;OffsetReadHigh;OffsetReadLow;OffsetWriteHigh;OffsetWriteLow;NumberOfBytesToRead;NumberOfBytesRead;NumberOfBytesToWrite;NumberOfBytesWritten
     ⍝ Decrypt data previously encrypted using #.Win.Crypt.Encrypt function
     ⍝
     ⍝ Parms[1] = hKey  Handle to the key to use for the decryption
     ⍝ Parms[2] = hHash Handle to hash object if data is decrypted and hashed simultaneously (simultaneously decrypting and verifying signature), zero otherwise
     ⍝ Parms[3] = Final TRUE for last or only block, FALSE if there are more blocks to be decrypted
     ⍝ Parms[4] = Flags (res.)
     ⍝
     ⍝ Data     = Characterstring to be decrypted
     ⍝ Data←    = Decrypted characterstring
     ⍝ or
     ⍝ Data[1]  = hRead of source file data to be decrypted
     ⍝ Data[2]  = hWrite of destination file data to be decrypted
     ⍝ Data[3]  = SizeRead of source file data (opt. whole file if omitted)
     ⍝ Data[4]  = OffsetRead in source file (def. 0)
     ⍝ Data[5]  = OffsetWrite in destination file (def. 0)
     ⍝ Data←    = SizeWritten to destination file or ¯1 on error
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hKey hHash Final Flags←4↑Parms
 :If 82=⎕DR Data
     DataLen←↑⍴Data←##.IntTxt Data
     :If ↑VOID Data DataLen←##.CryptDecrypt hKey hHash Final Flags Data DataLen
         #.RCode←##.ERROR_SUCCESS
         Data←##.TxtInt DataLen↑Data
     :Else
         #.RCode←##.GetLastError
         Data←''
     :EndIf
 :Else
     :If 5≤↑⍴Data
         hRead hWrite SizeRead OffsetRead OffsetWrite←5↑Data
         :If 0∨.>SizeRead OffsetRead OffsetWrite
         :OrIf (#.Win.File.Size hRead)<OffsetRead+SizeRead
             :If #.RCode=##.ERROR_SUCCESS
                 #.RCode←##.ERROR_HANDLE_EOF
             :EndIf
             Data←¯1
             :Return
         :EndIf
     :Else
         hRead hWrite←2↑Data
         OffsetRead←0
         OffsetWrite←0
         :If 0>SizeRead←##.File.Size hRead
             Data←¯1
             :Return
         :EndIf
     :EndIf
     :If ##.NULL≠hMem←##.Mem.Alloc NumberOfBytesToRead←SizeRead⌊Increment←⌊2*6⌈17
         Data←0
         :If hRead≠hWrite
             OffsetReadHigh OffsetReadLow←4294967296 4294967296⊤OffsetRead
             OffsetWriteHigh OffsetWriteLow←4294967296 4294967296⊤OffsetWrite
             :If OffsetReadLow≠↑##.SetFilePointer hRead OffsetReadLow OffsetReadHigh ##.FILE_BEGIN
             :OrIf OffsetWriteLow≠↑##.SetFilePointer hWrite OffsetWriteLow OffsetWriteHigh ##.FILE_BEGIN
                 VOID←1
             :Else
                 :Repeat
                     RepeatFinal←Final∧SizeRead≤NumberOfBytesToRead
                 :Until VOID←##.TRUE≠↑VOID NumberOfBytesRead←##.ReadFileM hRead hMem NumberOfBytesToRead 1 0
                 :OrIf VOID←NumberOfBytesRead≠NumberOfBytesToRead
                 :OrIf VOID←##.TRUE≠↑VOID NumberOfBytesToWrite←##.CryptDecryptM hKey hHash RepeatFinal Flags hMem NumberOfBytesToRead
                 :OrIf VOID←##.TRUE≠↑VOID NumberOfBytesWritten←##.WriteFileM hWrite hMem NumberOfBytesToWrite 1 0
                 :OrIf VOID←NumberOfBytesWritten≠Data+←NumberOfBytesToWrite
                 :OrIf 0≥NumberOfBytesToRead←Increment⌊SizeRead←SizeRead-NumberOfBytesToRead
             :EndIf
         :Else
             :Repeat
                 OffsetReadHigh OffsetReadLow←4294967296 4294967296⊤OffsetRead
                 OffsetWriteHigh OffsetWriteLow←4294967296 4294967296⊤OffsetWrite
                 RepeatFinal←Final∧SizeRead≤NumberOfBytesToRead
             :Until VOID←OffsetReadLow≠↑##.SetFilePointer hRead OffsetReadLow OffsetReadHigh ##.FILE_BEGIN
             :OrIf VOID←##.TRUE≠↑VOID NumberOfBytesRead←##.ReadFileM hRead hMem NumberOfBytesToRead 1 0
             :OrIf VOID←NumberOfBytesRead≠OffsetRead+←NumberOfBytesToRead
             :OrIf VOID←##.TRUE≠↑VOID NumberOfBytesToWrite←##.CryptDecryptM hKey hHash RepeatFinal Flags hMem NumberOfBytesToRead
             :OrIf VOID←OffsetWriteLow≠↑##.SetFilePointer hWrite OffsetWriteLow OffsetWriteHigh ##.FILE_BEGIN
             :OrIf VOID←##.TRUE≠↑VOID NumberOfBytesWritten←##.WriteFileM hWrite hMem NumberOfBytesToWrite 1 0
             :OrIf VOID←NumberOfBytesWritten≠OffsetWrite+←Data+←NumberOfBytesToWrite
             :OrIf 0≥NumberOfBytesToRead←Increment⌊SizeRead←SizeRead-NumberOfBytesToRead
         :EndIf
         :If VOID
             #.RCode←##.GetLastError
         :Else
             #.RCode←#.Win.ERROR_SUCCESS
         :EndIf
         RCode←#.RCode ⋄ ##.Mem.Free hMem ⋄ :If RCode≠##.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
         :If #.RCode≠##.ERROR_SUCCESS
             Data←¯1
         :EndIf
     :Else
         Data←¯1
     :EndIf
 :EndIf
∇

∇ hKey←DeriveKey Parms;hProv;Algid;hBaseData;Flags;Bitlen;VOID
     ⍝ Generate cryptographic session keys derived from a base data value
     ⍝
     ⍝ Parms[1] = hProv     Handle of a CSP
     ⍝ Parms[2] = Algid     (#.Win.CALG_DES #.Win.CALG_3DES_112 #.Win.CALG_3DES #.Win.CALG_RC2 #.Win.CALG_RC4 or #.Win.CALG_CYLINK_MEK)
     ⍝ Parms[3] = hBaseData Handle to a hash object that has been fed the exact base data
     ⍝ Parms[4] = Flags     (opt.)
     ⍝ Parms[5] = Bitlen    (opt.)
     ⍝
     ⍝ Valid Flags:
     ⍝ #.Win.CRYPT_EXPORTABLE     If set, key can be exported into a key blob by #.Win.Crypt.ExportKey
     ⍝ #.Win.CRYPT_USER_PROTECTED If set, user is notified by dialog box or else of key usage. Supported since IE4, Win98, WinNT4SP4, WinNT5.
     ⍝ #.Win.CRYPT_CREATE_SALT    If set, key is assigned a random salt value automatically. Retrieve the salt with #.Win.Crypt.GetKeyParam Param=#.Win.KP_SALT.
     ⍝ #.Win.CRYPT_NO_SALT        Specifies that a no salt value gets allocated for a forty-bit symmetric key.
     ⍝ #.Win.CRYPT_PREGEN         Specifies an initial Diffie-Hellman or DSS key generation.
     ⍝ #.Win.CRYPT_UPDATE_KEY     Some CSPs use session keys that are derived from multiple hash values. Microsoft CSPs ignore this flag.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hProv Algid hBaseData Flags Bitlen←5↑Parms
 Flags←⌊65536⊥Bitlen Flags
 :If ↑VOID hKey←##.CryptDeriveKey hProv Algid hBaseData Flags 0
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hKey←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ {VOID}←DestroyHash hHash
     ⍝ Destroy the hash object referenced by the hHash parameter
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If VOID←##.CryptDestroyHash hHash
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {VOID}←DestroyKey hKey
     ⍝ Releases the handle referenced by the hKey parameter
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If VOID←##.CryptDestroyKey hKey
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hHash←DuplicateHash hHash
     ⍝ Make an exact copy of a hash to the point when the duplication is done. The duplicate hash includes the hash's state.
     ⍝
     ⍝ BOOL WINAPI CryptDuplicateHash(
     ⍝ HCRYPTHASH hHash,
     ⍝ DWORD *pdwReserved,
     ⍝ DWORD dwFlags,
     ⍝ HCRYPTHASH *phHash
     ⍝ )
∇

∇ DuplicateKey
     ⍝ Make an exact copy of a key and the key's state.
     ⍝
     ⍝ BOOL WINAPI CryptDuplicateKey(
     ⍝ HCRYPTKEY hKey,
     ⍝ DWORD *pdwReserved,
     ⍝ DWORD dwFlags,
     ⍝ HCRYPTKEY *phKey
     ⍝ )
∇

∇ Data←Data Encrypt Parms;hKey;hHash;Final;Flags;Data;DataLen;BufLen;VOID;hRead;hWrite;SizeRead;OffsetRead;OffsetWrite;SizeWritten;hMem;RepeatFinal;Increment;OffsetReadHigh;OffsetReadLow;OffsetWriteHigh;OffsetWriteLow;NumberOfBytesToRead;NumberOfBytesRead;NumberOfBytesToWrite;NumberOfBytesWritten
     ⍝ Encrypt data, the algorithm used to encrypt the data is designated by the key held by the CSP module and is referenced by hKey
     ⍝
     ⍝ Parms[1] = hKey  Handle to encryption key, it specifies algorithm used
     ⍝ Parms[2] = hHash Handle to hash object if data is hashed and encrypted simultaneously, zero otherwise
     ⍝ Parms[3] = Final TRUE for last or only block, FALSE if there are more blocks to be encrypted
     ⍝ Parms[4] = Flags (PKCS#1v2.0 OptimalAsymmetricEncryptionPadding: #.Win.CRYPT_OAEP)
     ⍝
     ⍝ Data     = Characterstring to be encrypted
     ⍝ Data←    = Encrypted characterstring
     ⍝ or
     ⍝ Data[1]  = hRead of source file data to be encrypted
     ⍝ Data[2]  = hWrite of destination file data to be encrypted
     ⍝ Data[3]  = SizeRead of source file data (opt. whole file if omitted)
     ⍝ Data[4]  = OffsetRead in source file (def. 0)
     ⍝ Data[5]  = OffsetWrite in destination file (def. 0)
     ⍝ Data←    = SizeWritten to destination file or ¯1 on error
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hKey hHash Final Flags←4↑Parms
 :If 82=⎕DR Data
     BufLen←2048+DataLen←↑⍴Data←##.IntTxt Data
     Data←BufLen↑Data
     :If ↑VOID Data DataLen←##.CryptEncrypt hKey hHash Final Flags Data DataLen BufLen
         #.RCode←##.ERROR_SUCCESS
         Data←##.TxtInt DataLen↑Data
     :Else
         #.RCode←##.GetLastError
         Data←''
     :EndIf
 :Else
     :If 5≤↑⍴Data
         hRead hWrite SizeRead OffsetRead OffsetWrite←5↑Data
         :If 0∨.>SizeRead OffsetRead OffsetWrite
         :OrIf (#.Win.File.Size hRead)<OffsetRead+SizeRead
             :If #.RCode=##.ERROR_SUCCESS
                 #.RCode←##.ERROR_HANDLE_EOF
             :EndIf
             Data←¯1
             :Return
         :EndIf
     :Else
         hRead hWrite←2↑Data
         OffsetRead←0
         OffsetWrite←0
         :If 0>SizeRead←##.File.Size hRead
             Data←¯1
             :Return
         :EndIf
     :EndIf
     :If ##.NULL≠hMem←##.Mem.Alloc BufLen←2048+NumberOfBytesToRead←SizeRead⌊Increment←⌊2*6⌈17
         Data←0
         :If hRead≠hWrite
             OffsetReadHigh OffsetReadLow←4294967296 4294967296⊤OffsetRead
             OffsetWriteHigh OffsetWriteLow←4294967296 4294967296⊤OffsetWrite
             :If OffsetReadLow≠↑##.SetFilePointer hRead OffsetReadLow OffsetReadHigh ##.FILE_BEGIN
             :OrIf OffsetWriteLow≠↑##.SetFilePointer hWrite OffsetWriteLow OffsetWriteHigh ##.FILE_BEGIN
                 VOID←1
             :Else
                 :Repeat
                     RepeatFinal←Final∧SizeRead≤NumberOfBytesToRead
                 :Until VOID←##.TRUE≠↑VOID NumberOfBytesRead←##.ReadFileM hRead hMem NumberOfBytesToRead 1 0
                 :OrIf VOID←NumberOfBytesRead≠NumberOfBytesToRead
                 :OrIf VOID←##.TRUE≠↑VOID NumberOfBytesToWrite←##.CryptEncryptM hKey hHash RepeatFinal Flags hMem NumberOfBytesToRead BufLen
                 :OrIf VOID←##.TRUE≠↑VOID NumberOfBytesWritten←##.WriteFileM hWrite hMem NumberOfBytesToWrite 1 0
                 :OrIf VOID←NumberOfBytesWritten≠Data+←NumberOfBytesToWrite
                 :OrIf 0≥NumberOfBytesToRead←Increment⌊SizeRead←SizeRead-NumberOfBytesToRead
             :EndIf
         :Else
             :Repeat
                 OffsetReadHigh OffsetReadLow←4294967296 4294967296⊤OffsetRead
                 OffsetWriteHigh OffsetWriteLow←4294967296 4294967296⊤OffsetWrite
                 RepeatFinal←Final∧SizeRead≤NumberOfBytesToRead
             :Until VOID←OffsetReadLow≠↑##.SetFilePointer hRead OffsetReadLow OffsetReadHigh ##.FILE_BEGIN
             :OrIf VOID←##.TRUE≠↑VOID NumberOfBytesRead←##.ReadFileM hRead hMem NumberOfBytesToRead 1 0
             :OrIf VOID←NumberOfBytesRead≠OffsetRead+←NumberOfBytesToRead
             :OrIf VOID←##.TRUE≠↑VOID NumberOfBytesToWrite←##.CryptEncryptM hKey hHash RepeatFinal Flags hMem NumberOfBytesToRead BufLen
             :OrIf VOID←OffsetWriteLow≠↑##.SetFilePointer hWrite OffsetWriteLow OffsetWriteHigh ##.FILE_BEGIN
             :OrIf VOID←##.TRUE≠↑VOID NumberOfBytesWritten←##.WriteFileM hWrite hMem NumberOfBytesToWrite 1 0
             :OrIf VOID←NumberOfBytesWritten≠OffsetWrite+←Data+←NumberOfBytesToWrite
             :OrIf 0≥NumberOfBytesToRead←Increment⌊SizeRead←SizeRead-NumberOfBytesToRead
         :EndIf
         :If VOID
             #.RCode←##.GetLastError
         :Else
             #.RCode←#.Win.ERROR_SUCCESS
         :EndIf
         RCode←#.RCode ⋄ ##.Mem.Free hMem ⋄ :If RCode≠##.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
         :If #.RCode≠##.ERROR_SUCCESS
             Data←¯1
         :EndIf
     :Else
         Data←¯1
     :EndIf
 :EndIf
∇

∇ ProvNameTypes←EnumProviders;Index;hkProvider;ProvTypes;ProvNames
     ⍝ Enumerates the cryptographic service providers (CSPs) on a computer
     ⍝
     ⍝ ProvNameTypes[;1] = ProvName
     ⍝ ProvNameTypes[;2] = ProvType
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.INVALID_HANDLE_VALUE=hkProvider←##.Reg.OpenKey ##.HKEY_LOCAL_MACHINE'SOFTWARE\Microsoft\Cryptography\Defaults\Provider'##.KEY_READ
     ProvNameTypes←0 2⍴0 ''
 :ElseIf 0≠↑⍴ProvNames←(##.Reg.EnumKeyShort hkProvider)[;2]
     ProvNames←ProvNames[⍋⊃ProvNames]
 :AndIf 3∧.=10|⎕DR¨ProvTypes←↑¨##.Reg.GetValue¨hkProvider,¨(⊂¨ProvNames),¨⊂⊂'Type'
     ProvNameTypes←ProvNames,[1.5]ProvTypes
     ProvNameTypes←ProvNameTypes[⍋ProvTypes;]
     ##.Reg.CloseKey hkProvider
 :Else
     ProvNameTypes←0 2⍴0 ''
     RCode←#.RCode
     ##.Reg.CloseKey hkProvider
     #.RCode←RCode
 :EndIf
     ⍝ NT5 template:
     ⍝ProvNameTypes←0 2⍴0 ''
     ⍝:If ↑VOID ProvType ProvName cbProvName←##.CryptEnumProviders Index 0 0 1 MAXUIDLEN MAXUIDLEN
     ⍝    #.RCode←##.ERROR_SUCCESS
     ⍝    ProvTypeNames⍪←(cbProvName↑ProvName)ProvType
     ⍝:Else
     ⍝    #.RCode←##.GetLastError
     ⍝:EndIf
∇

∇ KeyBlob←ExportKey Parms;hKey;hExpKey;BlobType;Flags;KeyBlobLen;VOID
     ⍝ Export cryptographic keys from a cryptographic service provider (CSP) in a secure manner
     ⍝
     ⍝ Parms[1] = hKey     Handle to the key to be exported
     ⍝ Parms[2] = hExpKey  ZERO or Handle to a cryptographic key of the destination user, the key data within the exported key blob is encrypted using this key
     ⍝ Parms[3] = BlobType (#.Win.OPAQUEKEYBLOB #.Win.PRIVATEKEYBLOB #.Win.PUBLICKEYBLOB #.Win.PUBLICKEYBLOBEX or #.Win.SIMPLEBLOB)
     ⍝ Parms[4] = Flags    (#.Win.CRYPT_OAEP+#.Win.CRYPT_DESTROYKEY+#.Win.CRYPT_SSL2_FALLBACK)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hKey hExpKey BlobType Flags←4↑Parms
 :If ↑VOID KeyBlob KeyBlobLen←##.CryptExportKey hKey hExpKey BlobType Flags 65536 65536
     #.RCode←##.ERROR_SUCCESS
     KeyBlob←KeyBlobLen↑KeyBlob
 :Else
     #.RCode←##.GetLastError
     KeyBlob←''
 :EndIf
∇

∇ hKey←GenKey Parms;hProv;Algid;Flags;Bitlen;VOID
     ⍝ Generate a random cryptographic key.
     ⍝
     ⍝ Parms[1] = hProv
     ⍝ Parms[2] = Algid
     ⍝ Parms[3] = Flags   (opt.)
     ⍝ Parms[4] = Bitlen  (opt.)
     ⍝
     ⍝ Algid for RSA CSP:      #.Win.AT_SIGNATURE or #.Win.AT_KEYEXCHANGE
     ⍝ Algid for a DSS-DH CSP: #.Win.CALG_DH_EPHEM or #.Win.CALG_DH_SF
     ⍝ Algid for session keys: #.Win.CALG_DES #.Win.CALG_3DES_112 #.Win.CALG_3DES #.Win.CALG_RC2 #.Win.CALG_RC4 or #.Win.CALG_CYLINK_MEK
     ⍝
     ⍝ Valid Flags:
     ⍝ #.Win.CRYPT_EXPORTABLE     If set, key can be exported into a key blob by #.Win.Crypt.ExportKey
     ⍝ #.Win.CRYPT_USER_PROTECTED If set, user is notified by dialog box or else of key usage. Supported since IE4, Win98, WinNT4SP4, WinNT5.
     ⍝ #.Win.CRYPT_CREATE_SALT    If set, key is assigned a random salt value automatically. Retrieve the salt with #.Win.Crypt.GetKeyParam Param=#.Win.KP_SALT.
     ⍝ #.Win.CRYPT_NO_SALT        Specifies that a no salt value gets allocated for a forty-bit symmetric key.
     ⍝ #.Win.CRYPT_PREGEN         Specifies an initial Diffie-Hellman or DSS key generation.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hProv Algid Flags Bitlen←4↑Parms
 Flags←⌊65536⊥Bitlen Flags
 :If ↑VOID hKey←##.CryptGenKey hProv Algid Flags 1
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hKey←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ Buffer←Buffer GenRandom hProv;VOID
     ⍝ Fill a buffer with random bytes.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 82≠⎕DR Buffer
     Buffer←⎕AV[?Buffer⍴256]
 :EndIf
 Buffer←##.IntTxt Buffer
 :If ↑VOID Buffer←##.CryptGenRandom hProv(↑⍴Buffer)Buffer
     #.RCode←##.ERROR_SUCCESS
     Buffer←##.TxtInt Buffer
 :Else
     #.RCode←##.GetLastError
     Buffer←''
 :EndIf
∇

∇ Blobs←GetCertificates Parms;Path;Flags;hKey;Keys
     ⍝ Get a blob list of Root Certificates
     ⍝
     ⍝ Parms[1] = Flags: #.Win.CRYPT_MACHINE_DEFAULT (def.) or #.Win.CRYPT_USER_DEFAULT
     ⍝ Parms[2] = Path:  'Root' (def.) 'AddressBook' 'CA' 'My' 'SPC' or 'trust'
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     Flags←↑Parms
     Path←''
 :Else
     Flags Path←2↑Parms
 :EndIf
 :If ×↑⍴Path
     Path←'Software\Microsoft\SystemCertificates\',Path,'\Certificates'
 :Else
     Path←'Software\Microsoft\SystemCertificates\Root\Certificates'
 :EndIf
 hKey←##.HKEY_LOCAL_MACHINE ##.HKEY_CURRENT_USER[1+Flags≡##.CRYPT_USER_DEFAULT]
 :If ×↑⍴Keys←##.Reg.EnumKeyShort hKey Path
     Blobs←↑¨##.Reg.GetValue¨hKey,¨(⊂¨(Path,'\')∘,¨Keys[;2]),¨⊂⊂'Blob'
 :Else
     Blobs←0⍴⊂''
 :EndIf
∇

∇ ProvName←GetDefaultProvider Parms;ProvType;Flags
     ⍝ Find the default cryptographic service provider (CSP) of a specified provider type
     ⍝
     ⍝ Parms[1] = ProvType (#.Win.PROV_RSA_FULL      (def.) or #.Win.PROV_RSA_SIG #.Win.PROV_DSS #.Win.PROV_DSS_DH #.Win.PROV_DH_SCHANNEL #.Win.PROV_FORTEZZA #.Win.PROV_MS_EXCHANGE #.Win.PROV_RSA_SCHANNEL #.Win.PROV_SSL)
     ⍝ Parms[2] = Flags    (#.Win.CRYPT_USER_DEFAULT (def.) or #.Win.CRYPT_MACHINE_DEFAULT)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 ProvType Flags←2↑Parms
 :If 0=ProvType
     ProvType←##.PROV_RSA_FULL
 :EndIf
 :Select 4|Flags
 :CaseList ##.CRYPT_USER_DEFAULT 0
     :If 0∊⍴ProvName←↑##.Reg.GetValue ##.HKEY_CURRENT_USER('Software\Microsoft\Cryptography\Providers\Type ',⎕D[1+10 10 10⊤ProvType])'Name'
         ProvName←↑##.Reg.GetValue ##.HKEY_LOCAL_MACHINE('SOFTWARE\Microsoft\Cryptography\Defaults\Provider Types\Type ',⎕D[1+10 10 10⊤ProvType])'Name'
     :EndIf
 :Case ##.CRYPT_MACHINE_DEFAULT
     ProvName←↑##.Reg.GetValue ##.HKEY_LOCAL_MACHINE('SOFTWARE\Microsoft\Cryptography\Defaults\Provider Types\Type ',⎕D[1+10 10 10⊤ProvType])'Name'
 :Else
     #.RCode←##.ERROR_INVALID_PARAMETER
     ProvName←''
 :EndSelect
∇

∇ Data←GetHashParam Parms;hHash;Param;Flags;DataLen;VOID
     ⍝ Retrieve data that governs the operations of a hash object
     ⍝
     ⍝ Parms[1]: hHash
     ⍝ Parms[2]: Param (#.Win.HP_ALGID=HashAlgorithm #.Win.HP_HASHVAL=HashValue #.Win.HP_HASHSIZE=HashValueSize)
     ⍝ Parms[3]: Flags (res.)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hHash Param Flags←3↑Parms
 :If ↑VOID Data DataLen←##.CryptGetHashParam hHash Param 128 128 Flags
     #.RCode←##.ERROR_SUCCESS
     :If ##.HP_HASHVAL≠Param
     :AndIf 4=DataLen
         Data←↑4 ##.IntTxt 4↑Data
     :Else
         Data←DataLen↑Data
     :EndIf
 :Else
     #.RCode←##.GetLastError
     Data←''
 :EndIf
∇

∇ Data←GetKeyParam Parms;hKey;Param;Flags;DataLen;VOID
     ⍝ Retrieve data that governs the operations of a key.
     ⍝
     ⍝ Parms[1] = hKey
     ⍝ Parms[2] = Param (eg: #.Win.KP_ALGID #.Win.KP_BLOCKLEN #.Win.KP_KEYLEN #.Win.KP_SALT #.Win.KP_PERMISSIONS #.Win.KP_P #.Win.KP_Q #.Win.KP_G #.Win.KP_EFFECTIVE_KEYLEN #.Win.KP_IV #.Win.KP_PADDING #.Win.KP_MODE or #.Win.KP_MODE_BITS)
     ⍝ Parms[3] = Flags   (res.)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hKey Param Flags←3↑Parms
 :If ↑VOID Data DataLen←##.CryptGetKeyParam hKey Param 16384 16384 Flags
     #.RCode←##.ERROR_SUCCESS
     :If 4=DataLen
         Data←↑4 ##.IntTxt 4↑Data
     :Else
         Data←DataLen↑Data
     :EndIf
 :Else
     #.RCode←##.GetLastError
     Data←''
 :EndIf
∇

∇ Data←GetProvParam Parms;hProv;Param;DataLen;Flags;VOID;DataRepeat;DataLenRepeat
     ⍝ Retrieve parameters that govern the operations of a CSP
     ⍝
     ⍝ Parms[1] = hProv
     ⍝ Parms[2] = Param (#.Win.PP_ENUMALGS #.Win.PP_ENUMCONTAINERS #.Win.PP_ENUMALGS_EX #.Win.PP_IMPTYPE #.Win.PP_PROVTYPE #.Win.PP_KEYSTORAGE #.Win.PP_VERSION #.Win.PP_NAME #.Win.PP_CONTAINER #.Win.PP_KEYSET_TYPE)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hProv Param←2↑Parms
 :If Param∊##.PP_ENUMALGS ##.PP_ENUMCONTAINERS ##.PP_ENUMALGS_EX
     Flags←##.CRYPT_FIRST
 :Else
     Flags←##.ZERO
 :EndIf
 :If ↑VOID DataLen←##.CryptGetProvParamI hProv Param 0 0 Flags
     :If Flags=##.ZERO
         :If ↑VOID Data DataLen←##.CryptGetProvParam hProv Param DataLen DataLen Flags
             #.RCode←##.ERROR_SUCCESS
             Data←DataLen↑Data
             :Select Param
             :CaseList ##.PP_IMPTYPE ##.PP_PROVTYPE ##.PP_KEYSTORAGE ##.PP_KEYSET_TYPE
                 :If 4=⍴Data
                     Data←↑4 ##.IntTxt Data
                 :EndIf
             :Case ##.PP_VERSION
                 :If 2≤⍴Data
                     Data←⌽2↑1 ##.IntTxt Data
                 :EndIf
             :CaseList ##.PP_NAME ##.PP_CONTAINER
                 Data←(¯1+Data⍳↑⎕AV)↑Data
             :EndSelect
         :Else
             #.RCode←##.GetLastError
             Data←''
         :EndIf
     :Else
         Data←0⍴⊂''
         :While ↑VOID DataRepeat DataLenRepeat←##.CryptGetProvParam hProv Param DataLen DataLen Flags
             Data,←⊂DataLenRepeat↑DataRepeat
             Flags←##.CRYPT_NEXT
         :EndWhile
         :If ##.ERROR_NO_MORE_ITEMS=#.RCode←##.GetLastError
             #.RCode←##.ERROR_SUCCESS
             :Select Param
             :Case ##.PP_ENUMALGS ⍝ Algid BitLen Name
                 Data←(4 ##.IntTxt 8↑[2]⊃Data),(¯1+4 ##.IntTxt¨4↑¨8↓¨Data)↑¨20↑¨12↓¨Data
             :Case ##.PP_ENUMALGS_EX ⍝ Data: Algid DefaultLen MinLen MaxLen Protocols Name LongName
                 Data←(4 ##.IntTxt 20↑[2]⊃Data),(¯1+4 ##.IntTxt¨⊃[1]4↑¨¨20 44↓¨¨⊂Data)↑¨⊃[1]20 40↑¨¨24 48↓¨¨⊂Data
             :Case ##.PP_ENUMCONTAINERS
                 Data←(¯1+Data⍳¨↑⎕AV)↑¨Data
             :EndSelect
         :Else
             Data←0⍴⊂''
         :EndIf
     :EndIf
 :Else
     #.RCode←##.GetLastError
     Data←''
 :EndIf
∇

∇ hKey←GetUserKey Parms;hProv;KeySpec;VOID
     ⍝ Retrieve a handle of one of a user's public/private key pairs.
     ⍝
     ⍝ Parms[1] = Handle of a CSP (see AcquireContext)
     ⍝ Parms[2] = #.Win.AT_KEYEXCHANGE or #.Win.AT_SIGNATURE
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hProv KeySpec←2↑Parms
 :If ↑VOID hKey←##.CryptGetUserKey hProv KeySpec 1
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hKey←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ {VOID}←Data HashData Parms;hHash;DataLen;Flags;Increment;hFile;Size;Offset;hMem;RCode;OffsetHigh;OffsetLow;NumberOfBytesRead
     ⍝ Add data to a specified hash object
     ⍝
     ⍝ Parms[1] = hHash
     ⍝ Parms[2] = Flags (#.Win.CRYPT_USERDATA: CSP prompts the user to input data directly)
     ⍝
     ⍝ Data     = Characterstring to be hashed
     ⍝ or
     ⍝ Data[1]  = hFile of file data to be hashed
     ⍝ Data[2]  = Size of data (opt. whole file if omitted)
     ⍝ Data[3]  = Offset in file
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hHash Flags←2↑Parms
 :If 82=⎕DR Data
     DataLen←↑⍴Data←#.Win.IntTxt Data
     :If VOID←##.CryptHashData hHash Data DataLen Flags
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     :If 2≤↑⍴Data
         hFile Size Offset←3↑Data
         :If 0∨.>Size Offset
         :OrIf (##.File.Size hFile)<Offset+Size
             :If #.RCode=##.ERROR_SUCCESS
                 #.RCode←##.ERROR_HANDLE_EOF
             :EndIf
             VOID←0
             :Return
         :EndIf
     :Else
         hFile←↑Data
         Offset←0
         :If 0>Size←##.File.Size hFile
             VOID←0
             :Return
         :EndIf
     :EndIf
     :If 0≥Size
         VOID←1
         #.RCode←#.Win.ERROR_SUCCESS
     :ElseIf ##.NULL≠hMem←##.Mem.Alloc DataLen←Size⌊Increment←⌊2*6⌈17
         OffsetHigh OffsetLow←4294967296 4294967296⊤Offset
         :If OffsetLow≠↑##.SetFilePointer hFile OffsetLow OffsetHigh ##.FILE_BEGIN
             VOID←1
         :Else
             :Repeat
             :Until VOID←##.TRUE≠↑VOID NumberOfBytesRead←##.ReadFileM hFile hMem DataLen 1 0
             :OrIf VOID←NumberOfBytesRead≠DataLen
             :OrIf VOID←##.TRUE≠##.CryptHashDataM hHash hMem DataLen Flags
             :OrIf 0≥DataLen←Increment⌊Size←Size-DataLen
         :EndIf
         :If VOID
             #.RCode←##.GetLastError
         :Else
             #.RCode←#.Win.ERROR_SUCCESS
         :EndIf
         RCode←#.RCode ⋄ ##.Mem.Free hMem ⋄ :If RCode≠##.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
         VOID←#.RCode=##.ERROR_SUCCESS
     :Else
         VOID←0
     :EndIf
 :EndIf
∇

∇ {VOID}←HashSessionKey Parms;hHash;hKey;Flags
     ⍝ Compute the cryptographic hash of a key object
     ⍝
     ⍝ Parms[1]: hHash Handle to the hash object
     ⍝ Parms[2]: hKey  Handle to the key object to be hashed
     ⍝ Parms[3]: Flags NULL or #.Win.CRYPT_LITTLE_ENDIAN
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hHash hKey Flags←3↑Parms
 :If VOID←##.CryptHashSessionKey hHash hKey Flags
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ HashValue←Data HashValueFromVar Parms;hProv;Algid;hKey;hHash;RCode
     ⍝ Generates the HashValue from Caracter String Data
     ⍝
     ⍝ Parms[1] = hProv
     ⍝ Parms[2] = Algid (#.Win.CALG_HMAC #.Win.CALG_MAC #.Win.CALG_MD2 #.Win.CALG_MD5 #.Win.CALG_SHA or #.Win.CALG_SSL3_SHAMD5)
     ⍝ Parms[3] = hKey  If HMAC or MAC: key for the hash, if nonkeyed algorithm: zero
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hProv Algid hKey←3↑Parms
 :If ##.CALG_SSL3_SHAMD5=Algid
     :If 16≠↑⍴HashValue←Data HashValueFromVar hProv ##.CALG_MD5
     :OrIf 20≠↑⍴HashValue,←Data HashValueFromVar hProv ##.CALG_SHA1
         HashValue←''
     :EndIf
 :ElseIf ##.INVALID_HANDLE_VALUE=hHash←CreateHash hProv Algid hKey
     HashValue←''
 :ElseIf ##.ZERO=Data HashData hHash
 :OrIf 0∊⍴HashValue←GetHashParam hHash ##.HP_HASHVAL
     RCode←#.RCode ⋄ DestroyHash hHash ⋄ #.RCode←RCode
     HashValue←''
 :ElseIf ##.ZERO=DestroyHash hHash
     HashValue←''
 :EndIf
∇

∇ hKey←KeyBlob ImportKey Parms;hProv;KeyBlobLen;hPubKey;Flags;Count;VOID;WA;RCode
     ⍝ Transfer a cryptographic key from a key blob into a cryptographic service provider (CSP)
     ⍝
     ⍝ Parms[1] = hProv    Handle of a cryptographic service provider (CSP)
     ⍝ Parms[2] = hPubKey  #.Win.ZERO or handle to the key exchange key, or session key or exchange public key if key blob is signed
     ⍝ Parms[3] = Flags    (#.Win.CRYPT_OAEP+#.Win.CRYPT_EXPORTABLE+#.Win.CRYPT_NO_SALT)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hProv hPubKey Flags←3↑Parms
 KeyBlobLen←↑⍴KeyBlob←##.IntTxt KeyBlob
     ⍝:If ↑VOID hKey←##.CryptImportKey hProv KeyBlob KeyBlobLen hPubKey Flags 1 ⍝ **** ORIGINAL ****
     ⍝    #.RCode←##.ERROR_SUCCESS
     ⍝:Else
     ⍝    #.RCode←##.GetLastError
     ⍝    hKey←##.INVALID_HANDLE_VALUE
     ⍝:EndIf
 Count←500                                                                 ⍝ **** WORKAROUND ****
 :While ~↑VOID hKey←##.CryptImportKey hProv KeyBlob KeyBlobLen hPubKey Flags 1
 :AndIf 0<Count←Count-1
 :AndIf ##.NTE_BAD_DATA=##.GetLastError
     RCode←#.RCode ⋄ ##.Proc.Sleep 100<Count ⋄ :If RCode≠##.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
     WA←⎕WA
 :EndWhile
 :If VOID
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hKey←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ {VOID}←ReleaseContext Parms;hProv;Flags;Container;ContainerLen;ContFlags;ContFlagsLen;ProvName;ProvNameLen;ProvType;ProvTypeLen
     ⍝ Release a handle to a CSP and a key container.
     ⍝
     ⍝ Parms[1]: hProv
     ⍝ Parms[2]: Flags (res.)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hProv Flags←2↑Parms
 :If Flags=##.CRYPT_DELETEKEYSET
 :AndIf ↑VOID Container ContainerLen←##.CryptGetProvParam hProv ##.PP_CONTAINER ##.MAX_PATH ##.MAX_PATH ##.ZERO
 :AndIf ↑VOID ProvName ProvNameLen←##.CryptGetProvParam hProv ##.PP_NAME ##.MAX_PATH ##.MAX_PATH ##.ZERO
     Container←(¯1+Container⍳↑⎕AV)↑Container←ContainerLen↑Container
     ProvName←(¯1+ProvName⍳↑⎕AV)↑ProvName←ProvNameLen↑ProvName
     :If ↑VOID ProvType ProvTypeLen←##.CryptGetProvParam hProv ##.PP_PROVTYPE 4 4 ##.ZERO
         ProvType←↑4 ##.IntTxt ProvType
     :Else
         ProvType←##.PROV_RSA_FULL
     :EndIf
     :If ↑VOID ContFlags ContFlagsLen←##.CryptGetProvParam hProv ##.PP_KEYSET_TYPE 4 4 ##.ZERO
         ContFlags←↑4 ##.IntTxt ContFlags
     :Else
         ContFlags←0
     :EndIf
     :If VOID←##.CryptReleaseContext hProv 0
     :AndIf ↑VOID hProv←##.CryptAcquireContextCP 1 Container ProvName ProvType(ContFlags+##.CRYPT_DELETEKEYSET)
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     :If VOID←##.CryptReleaseContext hProv Flags
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :EndIf
∇

∇ {VOID}←ProvName SetDefaultProvider Parms;ProvType;Flags
     ⍝ Specify the current user's default CSP
     ⍝
     ⍝ Parms[1] = ProvType (#.Win.PROV_RSA_FULL      (def.) or #.Win.PROV_RSA_SIG #.Win.PROV_DSS #.Win.PROV_DSS_DH #.Win.PROV_DH_SCHANNEL #.Win.PROV_FORTEZZA #.Win.PROV_MS_EXCHANGE #.Win.PROV_RSA_SCHANNEL #.Win.PROV_SSL)
     ⍝ Parms[2] = Flags    (#.Win.CRYPT_USER_DEFAULT (def.) or #.Win.CRYPT_MACHINE_DEFAULT)
     ⍝
     ⍝ ProvName:                           ProvType:               Source   Description
     ⍝ ----------------------------------- ----------------------- -------- --------------------------------------------------------------------
     ⍝ #.Win.MS_DEF_PROV                   #.Win.PROV_RSA_FULL     NT/OSR2  The Microsoft Base Cryptographic Provider, version 2.0
     ⍝ #.Win.MS_ENHANCED_PROV              #.Win.PROV_RSA_FULL     domestic The Microsoft Enhanced Cryptographic Provider, version 2.0
     ⍝ #.Win.MS_DEF_RSA_SIG_PROV           #.Win.PROV_RSA_SIG               This provider type is a subset of PROV_RSA_FULL
     ⍝ #.Win.MS_DEF_DSS_PROV               #.Win.PROV_DSS          NT/OSR2  The Microsoft DSS Cryptographic Provider, version 1.0
     ⍝ #.Win.MS_DEF_DSS_DH_PROV            #.Win.PROV_DSS_DH       NT/OSR2  The Microsoft Base DSS and Diffie-Hellman Cryptographic Provider, Version 1.0
     ⍝ #.Win.MS_DEF_DH_SCHANNEL_PROV       #.Win.PROV_DH_SCHANNEL  NT5 only The Microsoft DSS and Diffie-Hellman/Schannel Cryptographic Provider, Version 1.0
     ⍝ ''                                  #.Win.PROV_FORTEZZA     ???      The set of cryptographic protocols and algorithms known as Fortezza is
     ⍝                                                                      owned by the National Institute of Standards and Technology (NIST).
     ⍝ ''                                  #.Win.PROV_MS_EXCHANGE  ???      CSPs of this type are designed to cater to the cryptographic needs
     ⍝                                                                      of the Microsoft Exchange mail application, as well as other applications
     ⍝                                                                      that are compatible with Microsoft Mail. This provider type is preliminary.
     ⍝ #.Win.MS_DEF_RSA_SCHANNEL_PROV      #.Win.PROV_RSA_SCHANNEL ???      The Microsoft RSA/Schannel Cryptographic Provider, Version 1.0
     ⍝ #.Win.MS_ENHANCED_RSA_SCHANNEL_PROV #.Win.PROV_RSA_SCHANNEL domestic
     ⍝ ''                                  #.Win.PROV_SSL          ???
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 ProvType Flags←2↑Parms
 :If 0=ProvType
     ProvType←##.PROV_RSA_FULL
 :EndIf
 :Select 4|Flags
 :CaseList ##.CRYPT_USER_DEFAULT 0
     :If VOID←##.CryptSetProvider ProvName ProvType
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Case ##.CRYPT_MACHINE_DEFAULT
     #.RCode←##.NTE_BAD_FLAGS
     VOID←##.FALSE
 :Else
     #.RCode←##.ERROR_INVALID_PARAMETER
     VOID←##.FALSE
 :EndSelect
∇

∇ {VOID}←Data SetHashParam Parms;hHash;Param;Flags;DataLen;HashAlgid;InnerString;OuterString;cbInnerString;cbOuterString;hMem
     ⍝ Customize the operations of a hash object
     ⍝
     ⍝ Parms[1]: hHash
     ⍝ Parms[2]: Param (#.Win.HP_HASHVAL:HashValue or #.Win.HP_HMAC_INFO:HMAC_INFO)
     ⍝ Parms[3]: Flags (res.)
     ⍝
     ⍝ If Param=#.Win.HP_HASHVAL
     ⍝ Data    : HashValue
     ⍝ Return  : 1 if OK, 0 otherwise (see #.RCode)
     ⍝
     ⍝ If Param=#.Win.HP_HMAC_INFO
     ⍝ Data[1] : Hash algorithm (#.Win.CALG_MD2 #.Win.CALG_MD5 or #.Win.CALG_SHA)
     ⍝ Data[2] : Inner string   (64⍴#.Win.TxtHex'36')
     ⍝ Data[3] : Outer string   (64⍴#.Win.TxtHex'5C')
     ⍝ Return  : hMem if OK, 0 otherwise (see #.RCode)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hHash Param Flags←3↑Parms
 :If Param=#.Win.HP_HMAC_INFO
     HashAlgid InnerString OuterString←3↑Data
     cbInnerString cbOuterString←↑∘⍴¨InnerString OuterString
     :If VOID←0≠hMem←##.Mem.Alloc 20+cbInnerString+cbOuterString
         ((4 ##.TxtInt HashAlgid(hMem+20)cbInnerString(hMem+20+cbInnerString)cbOuterString),InnerString,OuterString)##.Mem.Write hMem
     :AndIf VOID←##.CryptSetHashParamI hHash Param hMem Flags
         VOID←hMem
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         :If 0≠hMem
             ##.Mem.Free hMem
         :EndIf
     :EndIf
 :Else
     :If 82=⎕DR Data
         Data←##.IntTxt Data,↑⎕AV
     :Else
         Data←##.IntTxt 4 ##.TxtInt Data,0
     :EndIf
     :If VOID←##.CryptSetHashParam hHash Param Data Flags
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :EndIf
∇

∇ {VOID}←Data SetKeyParam Parms;hKey;Param;Flags;Bitlen
     ⍝ Customize various aspects of a key's operations, used to set session-specific values for symmetric keys
     ⍝
     ⍝ Parms[1] = hKey
     ⍝ Parms[2] = Param (eg: #.Win.KP_ALGID #.Win.KP_BLOCKLEN #.Win.KP_KEYLEN #.Win.KP_SALT #.Win.KP_PERMISSIONS #.Win.KP_P #.Win.KP_Q #.Win.KP_G #.Win.KP_EFFECTIVE_KEYLEN #.Win.KP_IV #.Win.KP_PADDING #.Win.KP_MODE or #.Win.KP_MODE_BITS)
     ⍝ Parms[3] = Flags   (opt.)
     ⍝ Parms[4] = Bitlen  (opt.)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hKey Param Flags Bitlen←4↑Parms
 Flags←⌊65536⊥Bitlen Flags
 :If 82=⎕DR Data
     Data←##.IntTxt Data,↑⎕AV
 :Else
     Data←##.IntTxt 4 ##.TxtInt Data,0
 :EndIf
 :If VOID←##.CryptSetKeyParam hKey Param Data Flags
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {VOID}←Data SetProvParam Parms;hProv;Param;Flags
     ⍝ Customize the operations of a CSP
     ⍝
     ⍝ Parms[1] = hProv Handle of a CSP
     ⍝ Parms[2] = Param (#.Win.PP_CLIENT_HWND or #.Win.PP_KEYSET_SEC_DESCR)
     ⍝ Parms[3] = Flags (#.Win.SECURITY_INFORMATION)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hProv Param Flags←4↑Parms
 :If 82=⎕DR Data
     Data←##.IntTxt Data,↑⎕AV
 :Else
     Data←##.IntTxt 4 ##.TxtInt Data,0
 :EndIf
 :If VOID←##.CryptSetProvParam hProv Param Data Flags
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Signature←SignHash Parms;hHash;KeySpec;Description;Flags;VOID;Signature;SigLen
     ⍝ Sign data, data is first hashed and #.Win.Crypt.SignHash is used to sign the hash
     ⍝
     ⍝ Parms[1]: hHash       Handle to the hash object
     ⍝ Parms[2]: KeySpec     Private key to use: #.Win.AT_KEYEXCHANGE or #.Win.AT_SIGNATURE
     ⍝ Parms[3]: Description Parameter should no longer be used
     ⍝ Parms[4]: Flags       NULL or #.Win.CRYPT_NOHASHOID (NT5)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hHash KeySpec Description Flags←4↑Parms
 Description←(##.IntTxt Description),0
 :If ##.FALSE≠↑VOID Signature SigLen←##.CryptSignHash hHash KeySpec Description Flags 4096 4096
     #.RCode←##.ERROR_SUCCESS
     Signature←⌽SigLen↑Signature
 :Else
     #.RCode←##.GetLastError
     Signature←''
 :EndIf
∇

∇ VOID←VerifySignature Parms;hHash;Signature;SigLen;hPubKey;Description;Flags
     ⍝ Verify the signature of a hash object
     ⍝
     ⍝ Parms[1]: hHash       Handle of the hash object to verify
     ⍝ Parms[2]: Signature   Signature data to be verified
     ⍝ Parms[3]: hPubKey     Handle to the public key to use to authenticate the signature
     ⍝ Parms[4]: Description Parameter should no longer be used
     ⍝ Parms[5]: Flags       NULL or #.Win.CRYPT_NOHASHOID (NT5)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hHash Signature hPubKey Description Flags←5↑Parms
 Description←(##.IntTxt Description),0
 SigLen←↑⍴Signature←⌽##.IntTxt Signature
 :If VOID←##.CryptVerifySignature hHash Signature SigLen hPubKey Description Flags
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

:Namespace KeyBlob
⎕IO ⎕ML ⎕WX←1 3 1

∇ Retrn←Decode KeyBlob;LittleToBigEndian;SIntToUInt;BLOBHEADER;RSAPUBKEY;DSSPUBKEY;DSSSEED;DHPUBKEY;SIMPLEKEY;RSAPUBLICKEY;DSSPUBLICKEY;DHPUBLICKEY;RSAPRIVATEKEY;DSSPRIVATEKEY;DHPRIVATEKEY;bType;bVersion;reserved;aiKeyAlg;algid;encryptedKey;magic;bitlen;publicExponent;modulus;prime1;prime2;exponent1;exponent2;coefficient;privateExponent;p;q;g;y;x;counter;seed;prime;generator;secret;ByteLength;WordLength
 ##.##.Init
 LittleToBigEndian←{1<≡⍵:∇¨⍵ ⋄ 0<↑##.##.IntTxt ¯1↑⍵:⌽⍵ ⋄ ⌽⍵,↑⎕AV}
 SIntToUInt←{0≤⍵:⍵ ⋄ 1=⍺:256|⍵ ⋄ 2=⍺:65536|⍵ ⋄ 4=⍺:4294967296|⍵}
 BLOBHEADER←1 1 2 4 ⍝ bType:BYTE    bVersion:BYTE reserved:WORD        aiKeyAlg:ALG_ID
 RSAPUBKEY←¯4 4 4   ⍝ magic:DWORD   bitlen:DWORD  publicExponent:DWORD
 DSSPUBKEY←¯4 4     ⍝ magic:DWORD   bitlen:DWORD
 DSSSEED←4 ¯20      ⍝ counter:DWORD seed:BYTE[20]
 DHPUBKEY←¯4 4      ⍝ magic:DWORD   bitlen:DWORD
 bType bVersion reserved aiKeyAlg←BLOBHEADER ##.##.SplitBinStruct KeyBlob
 :If 2=bVersion
     :Select bType
     :Case ##.##.SIMPLEBLOB ⍝ Transport (encrypted) session keys
              ⍝ Retrn[1] = bType        BYTE           #.Win.SIMPLEBLOB = 1
              ⍝ Retrn[2] = bVersion     BYTE           Version number of the key blob format = 2
              ⍝ Retrn[3] = reserved     WORD           res., zero
              ⍝ Retrn[4] = aiKeyAlg     UINT           Algorithm identifier of the key blob, eg #.Win.CALG_RC2, #.Win.CALG_RC4, or #.Win.CALG_3DES
              ⍝ Retrn[5] = algid        UINT           Encryption algorithm for the session key data, eg #.Win.CALG_RSA_KEYX
              ⍝ Retrn[6] = encryptedKey BYTE[bitlen/8] Encrypted session key data
         bitlen←8×(↑⍴KeyBlob)-+/|BLOBHEADER,4
         SIMPLEKEY←BLOBHEADER,4,-⌈bitlen÷8
         bType bVersion reserved aiKeyAlg algid encryptedKey←SIMPLEKEY ##.##.SplitBinStruct KeyBlob
         encryptedKey←⌽encryptedKey
         Retrn←bType bVersion reserved aiKeyAlg algid encryptedKey
         #.RCode←##.##.ERROR_SUCCESS
     :Case ##.##.PUBLICKEYBLOB
         bType bVersion reserved aiKeyAlg magic bitlen←(BLOBHEADER,DSSPUBKEY)##.##.SplitBinStruct KeyBlob
         :Select magic
         :Case 'RSA1' ⍝ RSA Public-Key Blob
                  ⍝ Retrn[1] = bType          BYTE           #.Win.PUBLICKEYBLOB = 6
                  ⍝ Retrn[2] = bVersion       BYTE           Version number of the key blob format = 2
                  ⍝ Retrn[3] = reserved       WORD           res., zero
                  ⍝ Retrn[4] = aiKeyAlg       UINT           Algorithm identifier of the key blob, eg #.Win.CALG_RSA_SIGN, #.Win.CALG_RSA_KEYX
                  ⍝ Retrn[5] = magic          DWORD          Magic member 'RSA1' for public keys
                  ⍝ Retrn[6] = bitlen         DWORD          Number of bits in modulus, multiple of eight
                  ⍝ Retrn[7] = publicExponent DWORD          Public exponent
                  ⍝ Retrn[8] = modulus        BYTE[bitlen/8] Modulus. Has a value of "prime1 * prime2" and is known as "n".
             :If (↑⍴KeyBlob)=+/|RSAPUBLICKEY←BLOBHEADER,RSAPUBKEY,-⌈bitlen÷8
                 bType bVersion reserved aiKeyAlg magic bitlen publicExponent modulus←RSAPUBLICKEY ##.##.SplitBinStruct KeyBlob
                 publicExponent←4 SIntToUInt publicExponent
                 modulus←LittleToBigEndian modulus
                 Retrn←bType bVersion reserved aiKeyAlg magic bitlen publicExponent modulus
                 #.RCode←##.##.ERROR_SUCCESS
             :Else
                 Retrn←⊂''
                 #.RCode←##.##.NTE_BAD_LEN
             :EndIf
         :Case 'DSS1' ⍝ DSS Public-Key Blob
                  ⍝ Retrn[1]  = bType    BYTE           #.Win.PUBLICKEYBLOB = 6
                  ⍝ Retrn[2]  = bVersion BYTE           Version number of the key blob format = 2
                  ⍝ Retrn[3]  = reserved WORD           res., zero
                  ⍝ Retrn[4]  = aiKeyAlg UINT           Algorithm identifier of the key blob, eg #.Win.CALG_DSS_SIGN
                  ⍝ Retrn[5]  = magic    DWORD          Magic member 'DSS1' for public keys
                  ⍝ Retrn[6]  = bitlen   DWORD          Number of bits in modulus, multiple of eight
                  ⍝ Retrn[7]  = p        BYTE[bitlen/8] Prime modulus, P
                  ⍝ Retrn[8]  = q        BYTE[20]       Prime, Q - 20 bytes in length
                  ⍝ Retrn[9]  = g        BYTE[bitlen/8] Generator, G
                  ⍝ Retrn[10] = y        BYTE[bitlen/8] Public key, Y
                  ⍝ Retrn[11] = counter  DWORD
                  ⍝ Retrn[12] = seed     BYTE[20]
             :If (↑⍴KeyBlob)=+/|DSSPUBLICKEY←BLOBHEADER,DSSPUBKEY,(-⌈bitlen÷8)¯20(-⌈bitlen÷8)(-⌈bitlen÷8),DSSSEED
                 bType bVersion reserved aiKeyAlg magic bitlen p q g y counter seed←DSSPUBLICKEY ##.##.SplitBinStruct KeyBlob
                 p q g y seed←LittleToBigEndian p q g y seed
                 Retrn←bType bVersion reserved aiKeyAlg magic bitlen p q g y counter seed
                 #.RCode←##.##.ERROR_SUCCESS
             :Else
                 Retrn←⊂''
                 #.RCode←##.##.NTE_BAD_LEN
             :EndIf
         :Case (↑⎕AV),'DH1' ⍝ Diffie-Hellman Public-Key Blob
                  ⍝ Retrn[1] = bType    BYTE           #.Win.PUBLICKEYBLOB = 6
                  ⍝ Retrn[2] = bVersion BYTE           Version number of the key blob format = 2
                  ⍝ Retrn[3] = reserved WORD           res., zero
                  ⍝ Retrn[4] = aiKeyAlg UINT           Algorithm identifier of the key blob, eg #.Win.CALG_DH_SF, #.Win.CALG_DH_EPHEM
                  ⍝ Retrn[5] = magic    DWORD          Magic member (↑⎕AV),'DH1' for public keys
                  ⍝ Retrn[6] = bitlen   DWORD          Number of bits in modulus, multiple of eight
                  ⍝ Retrn[7] = y        BYTE[bitlen/8] Public key, Y = (G∧X) mod P
             :If (↑⍴KeyBlob)=+/|DHPUBLICKEY←BLOBHEADER,DHPUBKEY,-⌈bitlen÷8
                 bType bVersion reserved aiKeyAlg magic bitlen y←DHPUBLICKEY ##.##.SplitBinStruct KeyBlob
                 y←LittleToBigEndian y
                 Retrn←bType bVersion reserved aiKeyAlg magic bitlen y
                 #.RCode←##.##.ERROR_SUCCESS
             :Else
                 Retrn←⊂''
                 #.RCode←##.##.NTE_BAD_LEN
             :EndIf
         :Else
             Retrn←⊂''
             #.RCode←##.##.NTE_BAD_TYPE
         :EndSelect
     
     :Case ##.##.PRIVATEKEYBLOB
         bType bVersion reserved aiKeyAlg magic bitlen←(BLOBHEADER,DSSPUBKEY)##.##.SplitBinStruct KeyBlob
         :Select magic
         :Case 'RSA2' ⍝ RSA Private-Key Blob
                  ⍝ Retrn[1]  = bType           BYTE            #.Win.PRIVATEKEYBLOB = 7
                  ⍝ Retrn[2]  = bVersion        BYTE            Version number of the key blob format = 2
                  ⍝ Retrn[3]  = reserved        WORD            res., zero
                  ⍝ Retrn[4]  = aiKeyAlg        UINT            Algorithm identifier of the key blob, eg #.Win.CALG_RSA_SIGN, #.Win.CALG_RSA_KEYX
                  ⍝ Retrn[5]  = magic           DWORD           Magic member 'RSA2' for private keys
                  ⍝ Retrn[6]  = bitlen          DWORD           Number of bits in the modulus, multiple of eight
                  ⍝ Retrn[7]  = publicExponent  DWORD           Public exponent:  Known as "e"
                  ⍝ Retrn[8]  = modulus         BYTE[bitlen/8]  Modulus:          Has a value of "prime1×prime2" and is known as "p×q=n"
                  ⍝ Retrn[9]  = prime1          BYTE[bitlen/16] Prime number 1:   Known as "p"
                  ⍝ Retrn[10] = prime2          BYTE[bitlen/16] Prime number 2:   Known as "q"
                  ⍝ Retrn[11] = exponent1       BYTE[bitlen/16] Exponent 1:       Has a value of "d mod (p - 1)"
                  ⍝ Retrn[12] = exponent2       BYTE[bitlen/16] Exponent 2:       Has a value of "d mod (q - 1)"
                  ⍝ Retrn[13] = coefficient     BYTE[bitlen/16] Coefficient:      Has a value of "(inverse of q) mod p"
                  ⍝ Retrn[14] = privateExponent BYTE[bitlen/8]  Private exponent: Known as "d"
             :If (↑⍴KeyBlob)=+/|RSAPRIVATEKEY←BLOBHEADER,RSAPUBKEY,-2 1 1 1 1 1 2×⌈bitlen÷16
                 bType bVersion reserved aiKeyAlg magic bitlen publicExponent modulus prime1 prime2 exponent1 exponent2 coefficient privateExponent←RSAPRIVATEKEY ##.##.SplitBinStruct KeyBlob
                 publicExponent←4 SIntToUInt publicExponent
                 modulus prime1 prime2 exponent1 exponent2 coefficient privateExponent←LittleToBigEndian modulus prime1 prime2 exponent1 exponent2 coefficient privateExponent
                 Retrn←bType bVersion reserved aiKeyAlg magic bitlen publicExponent modulus prime1 prime2 exponent1 exponent2 coefficient privateExponent
                 #.RCode←##.##.ERROR_SUCCESS
             :Else
                 Retrn←⊂''
                 #.RCode←##.##.NTE_BAD_LEN
             :EndIf
         :Case 'DSS2' ⍝ DSS Private-Key Blob
                  ⍝ Retrn[1]  = bType    BYTE           #.Win.PRIVATEKEYBLOB = 7
                  ⍝ Retrn[2]  = bVersion BYTE           Version number of the key blob format = 2
                  ⍝ Retrn[3]  = reserved WORD           res., zero
                  ⍝ Retrn[4]  = aiKeyAlg UINT           Algorithm identifier of the key blob, eg #.Win.CALG_DSS_SIGN
                  ⍝ Retrn[5]  = magic    DWORD          Magic member 'DSS2' for private keys
                  ⍝ Retrn[6]  = bitlen   DWORD          Number of bits in the modulus, multiple of eight
                  ⍝ Retrn[7]  = p        BYTE[bitlen/8] Prime modulus, P
                  ⍝ Retrn[8]  = q        BYTE[20]       Prime
                  ⍝ Retrn[9]  = g        BYTE[bitlen/8] Generator, G
                  ⍝ Retrn[10] = x        BYTE[20]       Secret exponent, X
                  ⍝ Retrn[11] = counter  DWORD
                  ⍝ Retrn[12] = seed     BYTE[20]
             :If (↑⍴KeyBlob)=+/|DSSPRIVATEKEY←BLOBHEADER,DSSPUBKEY,(-⌈bitlen÷8)¯20(-⌈bitlen÷8)¯20,DSSSEED
                 bType bVersion reserved aiKeyAlg magic bitlen p q g x counter seed←DSSPRIVATEKEY ##.##.SplitBinStruct KeyBlob
                 p q g x seed←LittleToBigEndian p q g x seed
                 Retrn←bType bVersion reserved aiKeyAlg magic bitlen p q g x counter seed
                 #.RCode←##.##.ERROR_SUCCESS
             :Else
                 Retrn←⊂''
                 #.RCode←##.##.NTE_BAD_LEN
             :EndIf
         :Case (↑⎕AV),'DH2' ⍝ Diffie-Hellman Private-Key Blob
                  ⍝ Retrn[1] = bType     BYTE           #.Win.PRIVATEKEYBLOB = 7
                  ⍝ Retrn[2] = bVersion  BYTE           Version number of the key blob format = 2
                  ⍝ Retrn[3] = reserved  WORD           res., zero
                  ⍝ Retrn[4] = aiKeyAlg  UINT           Algorithm identifier of the key blob, eg #.Win.CALG_DH_SF, #.Win.CALG_DH_EPHEM
                  ⍝ Retrn[5] = magic     DWORD          Magic member (↑⎕AV),'DH2' for private keys
                  ⍝ Retrn[6] = bitlen    DWORD          Number of bits in the modulus, multiple of eight
                  ⍝ Retrn[7] = prime     BYTE[bitlen/8] prime modulus, P
                  ⍝ Retrn[8] = generator BYTE[bitlen/8] Generator, G
                  ⍝ Retrn[9] = secret    BYTE[bitlen/8] Secret exponent, X
             :If (↑⍴KeyBlob)=+/|DHPRIVATEKEY←BLOBHEADER,DHPUBKEY,-⌈bitlen÷8 8 8
                 bType bVersion reserved aiKeyAlg magic bitlen prime generator secret←DHPRIVATEKEY ##.##.SplitBinStruct KeyBlob
                 prime generator secret←LittleToBigEndian prime generator secret
                 Retrn←bType bVersion reserved aiKeyAlg magic bitlen prime generator secret
                 #.RCode←##.##.ERROR_SUCCESS
             :Else
                 Retrn←⊂''
                 #.RCode←##.##.NTE_BAD_LEN
             :EndIf
         :Else
             Retrn←⊂''
             #.RCode←##.##.NTE_BAD_TYPE
         :EndSelect
     :Else
         Retrn←⊂''
         #.RCode←##.##.NTE_BAD_TYPE
     :EndSelect
 :Else
     Retrn←⊂''
     #.RCode←##.##.NTE_BAD_VER
 :EndIf
∇

∇ KeyBlob←Encode Parms;Rnd;BigToLittleEndian;BLOBHEADER;RSAPUBKEY;DSSPUBKEY;DSSSEED;DHPUBKEY;SIMPLEKEY;RSAPUBLICKEY;DSSPUBLICKEY;DHPUBLICKEY;RSAPRIVATEKEY;DSSPRIVATEKEY;DHPRIVATEKEY;bType;bVersion;reserved;aiKeyAlg;algid;encryptedKey;magic;bitlen;publicExponent;modulus;prime1;prime2;exponent1;exponent2;coefficient;privateExponent;p;q;g;y;x;counter;seed;prime;generator;secret
 ##.##.Init
 Rnd←{⍺←1 ⋄ ⍺×⌊0.5+⍵÷⍺}
 BigToLittleEndian←{82=⎕DR ⍵:⌽⍵ ⋄ 4 ##.##.TxtInt ⍵}
 BLOBHEADER←1 1 2 4 ⍝ bType:BYTE bVersion:BYTE reserved:WORD aiKeyAlg:ALG_ID
 RSAPUBKEY←¯4 4 4   ⍝ magic:DWORD bitlen:DWORD publicExponent:DWORD
 DSSPUBKEY←¯4 4     ⍝ magic:DWORD bitlen:DWORD
 DSSSEED←4 ¯20      ⍝ counter:DWORD seed:BYTE[20]
 DHPUBKEY←¯4 4      ⍝ magic:DWORD bitlen:DWORD
 bType bVersion reserved aiKeyAlg←4↑Parms
 :If 2≡bVersion
     :Select bType,↑⍴Parms
     :Case ##.##.SIMPLEBLOB 6 ⍝ Transport (encrypted) session keys
              ⍝ Parms[1] = bType        BYTE           #.Win.SIMPLEBLOB = 1
              ⍝ Parms[2] = bVersion     BYTE           Version number of the key blob format = 2
              ⍝ Parms[3] = reserved     WORD           res., zero
              ⍝ Parms[4] = aiKeyAlg     UINT           Algorithm identifier of the key blob, eg #.Win.CALG_RC2, #.Win.CALG_RC4, or #.Win.CALG_3DES
              ⍝ Parms[5] = algid        UINT           Encryption algorithm for the session key data, eg #.Win.CALG_RSA_KEYX
              ⍝ Parms[6] = encryptedKey BYTE[bitlen/8] Encrypted session key data
         bType bVersion reserved aiKeyAlg algid encryptedKey←Parms
         encryptedKey←⌽encryptedKey
         bitlen←8×↑⍴encryptedKey
         SIMPLEKEY←BLOBHEADER,4,-⌈bitlen÷8
         KeyBlob←SIMPLEKEY ##.##.BuildBinStruct bType bVersion reserved aiKeyAlg algid encryptedKey
         #.RCode←##.##.ERROR_SUCCESS
     :Case ##.##.PUBLICKEYBLOB 8 ⍝ RSA Public-Key Blob
              ⍝ Parms[1] = bType          BYTE           #.Win.PUBLICKEYBLOB = 6
              ⍝ Parms[2] = bVersion       BYTE           Version number of the key blob format = 2
              ⍝ Parms[3] = reserved       WORD           res., zero
              ⍝ Parms[4] = aiKeyAlg       UINT           Algorithm identifier of the key blob, eg #.Win.CALG_RSA_SIGN, #.Win.CALG_RSA_KEYX
              ⍝ Parms[5] = magic          DWORD          Magic member 'RSA1' for public keys
              ⍝ Parms[6] = bitlen         DWORD          Number of bits in modulus, multiple of eight
              ⍝ Parms[7] = publicExponent DWORD          Public exponent
              ⍝ Parms[8] = modulus        BYTE[bitlen/8] Modulus. Has a value of "prime1 * prime2" and is known as "n".
         bType bVersion reserved aiKeyAlg magic bitlen publicExponent modulus←Parms
         :If 0=bitlen
             bitlen←16 Rnd+/∨\0.125 ##.##.IntTxt modulus
         :EndIf
         modulus←BigToLittleEndian modulus
         :If 82=⎕DR publicExponent
             publicExponent←↑4 ##.##.IntTxt 4↑(⌽publicExponent),4⍴↑⎕AV
         :EndIf
         RSAPUBLICKEY←BLOBHEADER,RSAPUBKEY,-⌈bitlen÷8
         :If magic≡'RSA1'
             KeyBlob←RSAPUBLICKEY ##.##.BuildBinStruct bType bVersion reserved aiKeyAlg magic bitlen publicExponent modulus
             #.RCode←##.##.ERROR_SUCCESS
         :Else
             KeyBlob←''
             #.RCode←##.##.NTE_BAD_TYPE
         :EndIf
     :Case ##.##.PUBLICKEYBLOB 12 ⍝ DSS Public-Key Blob
              ⍝ Parms[1]  = bType    BYTE           #.Win.PUBLICKEYBLOB = 6
              ⍝ Parms[2]  = bVersion BYTE           Version number of the key blob format = 2
              ⍝ Parms[3]  = reserved WORD           res., zero
              ⍝ Parms[4]  = aiKeyAlg UINT           Algorithm identifier of the key blob, eg #.Win.CALG_DSS_SIGN
              ⍝ Parms[5]  = magic    DWORD          Magic member 'DSS1' for public keys
              ⍝ Parms[6]  = bitlen   DWORD          Number of bits in modulus, multiple of eight
              ⍝ Parms[7]  = p        BYTE[bitlen/8] Prime modulus, P
              ⍝ Parms[8]  = q        BYTE[20]       Prime, Q - 20 bytes in length
              ⍝ Parms[9]  = g        BYTE[bitlen/8] Generator, G
              ⍝ Parms[10] = y        BYTE[bitlen/8] Public key, Y
              ⍝ Parms[11] = counter  DWORD
              ⍝ Parms[12] = seed     BYTE[20]
         Parms←bType bVersion reserved aiKeyAlg magic bitlen p q g y counter seed←Parms
         :If 0=bitlen
             bitlen←16 Rnd+/∨\0.125 ##.##.IntTxt p
         :EndIf
         p q g y seed←BigToLittleEndian¨p q g y seed
         DSSPUBLICKEY←BLOBHEADER,DSSPUBKEY,(-⌈bitlen÷8)¯20(-⌈bitlen÷8)(-⌈bitlen÷8),DSSSEED
         :If magic≡'DSS1'
             KeyBlob←DSSPUBLICKEY ##.##.BuildBinStruct bType bVersion reserved aiKeyAlg magic bitlen p q g y counter seed
             #.RCode←##.##.ERROR_SUCCESS
         :Else
             KeyBlob←''
             #.RCode←##.##.NTE_BAD_TYPE
         :EndIf
     :Case ##.##.PUBLICKEYBLOB 7 ⍝ Diffie-Hellman Public-Key Blob
              ⍝ Parms[1] = bType    BYTE           #.Win.PUBLICKEYBLOB = 6
              ⍝ Parms[2] = bVersion BYTE           Version number of the key blob format = 2
              ⍝ Parms[3] = reserved WORD           res., zero
              ⍝ Parms[4] = aiKeyAlg UINT           Algorithm identifier of the key blob, eg #.Win.CALG_DH_SF, #.Win.CALG_DH_EPHEM
              ⍝ Parms[5] = magic    DWORD          Magic member (↑⎕AV),'DH1' for public keys
              ⍝ Parms[6] = bitlen   DWORD          Number of bits in modulus, multiple of eight
              ⍝ Parms[7] = y        BYTE[bitlen/8] Public key, Y = (G∧X) mod P
         bType bVersion reserved aiKeyAlg magic bitlen y←Parms
         :If 0=bitlen
             bitlen←16 Rnd+/∨\0.125 ##.##.IntTxt y
         :EndIf
         y←BigToLittleEndian y
         DHPUBLICKEY←BLOBHEADER,DHPUBKEY,-⌈bitlen÷8
         :If magic≡(↑⎕AV),'DH1'
             KeyBlob←DHPUBLICKEY ##.##.BuildBinStruct bType bVersion reserved aiKeyAlg magic bitlen y
             #.RCode←##.##.ERROR_SUCCESS
         :Else
             KeyBlob←''
             #.RCode←##.##.NTE_BAD_TYPE
         :EndIf
     :Case ##.##.PRIVATEKEYBLOB 14 ⍝ RSA Private-Key Blob
              ⍝ Parms[1]  = bType           BYTE            #.Win.PRIVATEKEYBLOB = 7
              ⍝ Parms[2]  = bVersion        BYTE            Version number of the key blob format = 2
              ⍝ Parms[3]  = reserved        WORD            res., zero
              ⍝ Parms[4]  = aiKeyAlg        UINT            Algorithm identifier of the key blob, eg #.Win.CALG_RSA_SIGN, #.Win.CALG_RSA_KEYX
              ⍝ Parms[5]  = magic           DWORD           Magic member 'RSA2' for private keys
              ⍝ Parms[6]  = bitlen          DWORD           Number of bits in the modulus, multiple of eight
              ⍝ Parms[7]  = publicExponent  DWORD           Public exponent:  Known as "e"
              ⍝ Parms[8]  = modulus         BYTE[bitlen/8]  Modulus:          Has a value of "prime1×prime2" and is known as "p×q=n"
              ⍝ Parms[9]  = prime1          BYTE[bitlen/16] Prime number 1:   Known as "p"
              ⍝ Parms[10] = prime2          BYTE[bitlen/16] Prime number 2:   Known as "q"
              ⍝ Parms[11] = exponent1       BYTE[bitlen/16] Exponent 1:       Has a value of "d mod (p - 1)"
              ⍝ Parms[12] = exponent2       BYTE[bitlen/16] Exponent 2:       Has a value of "d mod (q - 1)"
              ⍝ Parms[13] = coefficient     BYTE[bitlen/16] Coefficient:      Has a value of "(inverse of q) mod p"
              ⍝ Parms[14] = privateExponent BYTE[bitlen/8]  Private exponent: Known as "d"
         bType bVersion reserved aiKeyAlg magic bitlen publicExponent modulus prime1 prime2 exponent1 exponent2 coefficient privateExponent←Parms
         :If 0=bitlen
             bitlen←16 Rnd+/∨\0.125 ##.##.IntTxt modulus
         :EndIf
         :If 82=⎕DR publicExponent
             publicExponent←↑4 ##.##.IntTxt 4↑(⌽publicExponent),4⍴↑⎕AV
         :EndIf
         modulus prime1 prime2 exponent1 exponent2 coefficient privateExponent←BigToLittleEndian¨modulus prime1 prime2 exponent1 exponent2 coefficient privateExponent
         RSAPRIVATEKEY←BLOBHEADER,RSAPUBKEY,-2 1 1 1 1 1 2×⌈bitlen÷16
         :If magic≡'RSA2'
             KeyBlob←RSAPRIVATEKEY ##.##.BuildBinStruct bType bVersion reserved aiKeyAlg magic bitlen publicExponent modulus prime1 prime2 exponent1 exponent2 coefficient privateExponent
             #.RCode←##.##.ERROR_SUCCESS
         :Else
             KeyBlob←''
             #.RCode←##.##.NTE_BAD_TYPE
         :EndIf
     :Case ##.##.PRIVATEKEYBLOB 12 ⍝ DSS Private-Key Blob
              ⍝ Parms[1]  = bType    BYTE           #.Win.PRIVATEKEYBLOB = 7
              ⍝ Parms[2]  = bVersion BYTE           Version number of the key blob format = 2
              ⍝ Parms[3]  = reserved WORD           res., zero
              ⍝ Parms[4]  = aiKeyAlg UINT           Algorithm identifier of the key blob, eg #.Win.CALG_DSS_SIGN
              ⍝ Parms[5]  = magic    DWORD          Magic member 'DSS2' for private keys
              ⍝ Parms[6]  = bitlen   DWORD          Number of bits in the modulus, multiple of eight
              ⍝ Parms[7]  = p        BYTE[bitlen/8] Prime modulus, P
              ⍝ Parms[8]  = q        BYTE[20]       Prime
              ⍝ Parms[9]  = g        BYTE[bitlen/8] Generator, G
              ⍝ Parms[10] = x        BYTE[20]       Secret exponent, X
              ⍝ Parms[11] = counter  DWORD
              ⍝ Parms[12] = seed     BYTE[20]
         bType bVersion reserved aiKeyAlg magic bitlen p q g x counter seed←Parms
         :If 0=bitlen
             bitlen←16 Rnd+/∨\0.125 ##.##.IntTxt p
         :EndIf
         p q g x seed←BigToLittleEndian¨p q g x seed
         DSSPRIVATEKEY←BLOBHEADER,DSSPUBKEY,(-⌈bitlen÷8)¯20(-⌈bitlen÷8)¯20,DSSSEED
         :If magic≡'DSS2'
             KeyBlob←DSSPRIVATEKEY ##.##.BuildBinStruct bType bVersion reserved aiKeyAlg magic bitlen p q g x counter seed
             #.RCode←##.##.ERROR_SUCCESS
         :Else
             KeyBlob←''
             #.RCode←##.##.NTE_BAD_TYPE
         :EndIf
     :Case ##.##.PRIVATEKEYBLOB 9 ⍝ Diffie-Hellman Private-Key Blob
              ⍝ Parms[1] = bType     BYTE           #.Win.PRIVATEKEYBLOB = 7
              ⍝ Parms[2] = bVersion  BYTE           Version number of the key blob format = 2
              ⍝ Parms[3] = reserved  WORD           res., zero
              ⍝ Parms[4] = aiKeyAlg  UINT           Algorithm identifier of the key blob, eg #.Win.CALG_DH_SF, #.Win.CALG_DH_EPHEM
              ⍝ Parms[5] = magic     DWORD          Magic member (↑⎕AV),'DH2' for private keys
              ⍝ Parms[6] = bitlen    DWORD          Number of bits in the modulus, multiple of eight
              ⍝ Parms[7] = prime     BYTE[bitlen/8] prime modulus, P
              ⍝ Parms[8] = generator BYTE[bitlen/8] Generator, G
              ⍝ Parms[9] = secret    BYTE[bitlen/8] Secret exponent, X
         bType bVersion reserved aiKeyAlg magic bitlen prime generator secret←Parms
         :If 0=bitlen
             bitlen←16 Rnd+/∨\0.125 ##.##.IntTxt prime
         :EndIf
         prime generator secret←BigToLittleEndian¨prime generator secret
         DHPRIVATEKEY←BLOBHEADER,DHPUBKEY,-⌈bitlen÷8 8 8
         :If magic≡(↑⎕AV),'DH2'
             KeyBlob←DHPRIVATEKEY ##.##.BuildBinStruct bType bVersion reserved aiKeyAlg magic bitlen prime generator secret
             #.RCode←##.##.ERROR_SUCCESS
         :Else
             KeyBlob←''
             #.RCode←##.##.NTE_BAD_TYPE
         :EndIf
     :Else
         KeyBlob←''
         #.RCode←##.##.NTE_BAD_TYPE
     :EndSelect
 :Else
     KeyBlob←''
     #.RCode←##.##.NTE_BAD_VER
 :EndIf
∇

∇ KeyBlob←{Key}Generate Parms;Algid;Bitlen;ExponentOne;CodeFlag;RCode;hProv;hKey;GenAlgid;Type;Version;reserved;KeyAlg;magic;publicExponent;modulus;prime1;prime2;exponent1;exponent2;coefficient;privateExponent
     ⍝ Generate a random cryptographic key.
     ⍝
     ⍝ Parms[1] = Algid
     ⍝ Parms[2] = Bitlen      (opt. default depends on CSP)
     ⍝ Parms[3] = ExponentOne (opt. default #.Win.FALSE for generate true cryptographic key or #.Win.TRUE for dummy blob doing a null crypt)
     ⍝
     ⍝ Algid for RSA CSP:      #.Win.CALG_RSA_SIGN or #.Win.CALG_RSA_KEYX
     ⍝ Optional:               Key[1] = Modulus
     ⍝                         Key[2] = Public Exponent
     ⍝
     ⍝ Algid for session keys: #.Win.CALG_DES #.Win.CALG_3DES_112 #.Win.CALG_3DES #.Win.CALG_RC2 #.Win.CALG_RC4 or #.Win.CALG_CYLINK_MEK
     ⍝ Required:               Key    = Session Key
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 Algid Bitlen ExponentOne←3↑Parms
 :Select Algid
 :CaseList ##.##.CALG_RSA_SIGN ##.##.CALG_RSA_KEYX
     :If 0=Bitlen
     :AndIf ×⎕NC'Key'
         modulus publicExponent←2↑Key
         Bitlen←8×(↑⍴modulus)+1-(modulus=↑⎕AV)⍳0
     :EndIf
     :Select Bitlen×ExponentOne
     :Case 384
         modulus←##.##.TxtHex'00EC21AE7AE5E47FCC6E7D43354955054B8634EB1BD7930D0C9A2C0B8A0DB773EA0FAEAACC39399E141602AF4FBF99D5AB'
         prime1←##.##.TxtHex'00F8AD64F7102D8152F9AC4CBFDAA187FCFCCB666739B38459'
         prime2←##.##.TxtHex'00F315B6A4884EC9D651D83A2E61CF660A65F7AAA610E2F9A3'
         coefficient←##.##.TxtHex'2D0E0328287D8A47C4A98A0715AFF20301835894C01D2E78'
         #.RCode←##.##.ERROR_SUCCESS
     :Case 512
         modulus←##.##.TxtHex'00ECDE89D612D30A24AD692ECC8B36E2F1ABB1964F2EAFC9D6C070983E72B315EA89500A666243C6738AC047F53CA871175DB26BA334F53A95A8D7B5C69B765621'
         prime1←##.##.TxtHex'00FE20FAA7778D682B6C0128118F2E4A4DA581523A8D241E7E9D4A5CDE3E497E73'
         prime2←##.##.TxtHex'00EE9D06A1107A870EB813F311143B079853F6DA9771E84EAB1C09DE683BF2001B'
         coefficient←##.##.TxtHex'0094CC86D9A3529827CD96AC13BAA9501807A93D7DF93F2D57ED1A6CA3D344B6AB'
         #.RCode←##.##.ERROR_SUCCESS
     :Case 1024
         modulus←##.##.TxtHex'00D7C63C3A8C87DB454D0E5190E55EBDC6295FC015432002249249BAC19D8E776CD74BDA66FAC725284D760A5F1A182894E3920375F149C0249E000101692FE6FA450D575610DC086FDFA1A1FFF5CAA19654A42E45D9C038C17FA9DE30F493FA11A8FE7301D967AB455382F34E45AF97A94C23A974AB6D998739996E16047A52C1'
         prime1←##.##.TxtHex'00F9B13349AE0C2D17CAA5566D5C9B9BB0B86ACD612B0207369CED918E1862A42500B238E64D2E052C3581BF801AA0E6815DE0A43D6373A462D20471017E13E711'
         prime2←##.##.TxtHex'00DD39AECE2971A9CBFFE82283DFCA40A1F0CD4E2AA9C1FAFB9E381661E7879F0D8D753C47DBA385B3C0D4FEF8535057A5571368481A33D1A812C13FD7E6DE90B1'
         coefficient←##.##.TxtHex'0A9D05644CFEC10EFFC1D9121D75B01168AF2C0E7F2D81238BCE6430D7CF20E7A003DD62EE44036FD859E67AE8F355D8605C9BE4A1205FCC89B7ABB33CE8AA5D'
         #.RCode←##.##.ERROR_SUCCESS
     :Case 2048
         modulus←##.##.TxtHex'00BCC84E67ACCCB84F2C41C0E48163AD0EE0EE41475A381F9883CE904F4C677051784F3F6C138AB5B860F3B7312ABDE313ED6472788965303FB0FAA660B1051E41BAF385DA3EEC590A21F38F1A85FAEDCBDD65C2CF27376EE86B5FEDAEE19D420AF95F4C7FDCB101B29ACFB003AE96340BD60EF71332AC53D0CC7F055BD415B01B7E323117384FC6D845455A05DC34BBF896E805E871FEE2F5697B8A4C8CF33E7361C16289DA3A77D458121E90E5080CE0735BC2E27B5CF9BF7CDCF44A38007DFCDCFA03240D2355B6147D6FE496F62C6B5561AD7273F8A70946A2009258652C8FA90E8DBBF9CAFD86212D51AAD5F081DE1ACAB11290D1355D45B54CD9376CD2BF'
         prime1←##.##.TxtHex'00E3FF93AE940D05B651B72C3FC69A158D7EE74ACFDC296199FD4197D6408B903F1C1C4071C49605934CDA3A87C76663E595DE0A2BAD7BE62F4E0DCAABA8242357F7FD56A3203C47C89569CFEF938A15C5C889DFC75890D90E88A3BAFF05950F24B63AA9A250F30B2B01D6EB3139F2F9F7320278B330E03091798E0DB70D2F3F05'
         prime2←##.##.TxtHex'00D3F7C139F3C00D1E7D9D0624D33F4BAA58308175190A34D35D2C912F92E04D919275690E6A3AC8D1529BB1CC1872FC47B2A8F7F9FF4F33662D1E19677DE83A413A6F0BC4A3FA398FC9498455AE40D6D39FB061B7C86473B5F37B1C865C5E622DD111B138A3E60E35A3D1072F49087A5CE26915D97703672CE32528605E39CDF3'
         coefficient←##.##.TxtHex'009C5EAA72B656CFCC5B476FFA9C6CFF350A73F740D0389CF7A0992F8C97A617D05735FC93121F017E0406167DC8757C9F268780B97267202D289CEE395CB799E40D279E8E4BF6B448E44C579D89310DB33EE78DEA5E0A766BF4BA9269F67CA879FB6BA8B1A488FAB3CC07EAAEC673EF8CC15CFFC14E079D23F323BA5681C3E4E3'
         #.RCode←##.##.ERROR_SUCCESS
     :Case 4096
         modulus←##.##.TxtHex'00BC110EE936DC289B54FD0765D9B692AC1029C91E956B0B1B596EF3BE45C75853B6019EFE700D51121E9EE86C6869B1934D6E7C4789259F10DD925DD20C302BBFFB852A393F1018817104B0EAB4F463C1EF67D1FD6894E2BA2F6DCFC0DDC231D6DFC9841A9B4C9A037BE9E80681F2B8CBD50AF5BA2CC61DF1C25CD175635FA16C19634C8A7567740A2E5461715E4FC40CB48C177583CA20D5C775EEB8D512871DE2458DBD9D758218EE840228C1D996623DE1A7F87EBCE1BF18E82DD00D539D1FC71A56F9B6D660BE101C17448249DFF6314F96C44AECD4E3B11E4DF03FF597924889A6850252AC649D0FBAB765C8B077B68784E9F4C4363F60A00B727B09E2F5050B7FB38738CCDA5DCFE0CD78BC152D870CFF85F5B4CEF521BB073C6232988043416F971257E43A6D391735231883159FE3B5C1C3B2825C7C9499E6E288DF4B954D214249932F813CEC54BD2AF2E74ACBC4D6D0A42849E0059D3A5F82C1B40056F3EC24E27A221F484D3BC10F338937DC01D7F43F638BA210F147B0824425F03BA96255D57FF05DB0D2D2B083EC96C21ED4999DC63AC3E5422AD88E489D32BB465A1BC6A7358A103A7604057AC56E00F00F21C4F4BFFB0484D98C98028083E80C78459CB8795B2E9FE7A24F913F20DC7466825F83FF6CD14B13E0D01CAD1C73E5965D3E0A38E2472DCA0742972DFF9CA4CB9BE311F5C0613B10CE7218152D21'
         prime1←##.##.TxtHex'00DD31CD20ADFB1FDD84A637C4531713307A08E09400D11A614472FB11E38765D08F52F2F32D5C7FE2AF54E4BE0458C413C93A544FEBCF710CC25C41FB44AC947339604CE6D23ED5C73868EF65D2F60530ABAC61A8C34DC5FF2F5F0724F2D498710528588C44C311A09DBEA92011C5CBE7D9C90A5D0534D994CB64EC5A683F6F323BA8B2D9C9297AC2C65DBB5ACF09B2CF92CBDBD9C95B626988FAEEBE92787D14CC82B13794DBA79B075CC5977606467E53FE2C7140E52FBA1E8E39E59ED2622CED51C4C1E4F4A0BA23285A8A871BF65ED9F3BE86A081A9AC5C1928CAA5C4B9516F18E9E1494FE8314D4B43FA22A36607240454A3427D3BF4F3E3EDE821D4C9A1'
         prime2←##.##.TxtHex'00D9A8CAF16D04A63B5E5FF0F5A3C487F0A146D1C82F3C4FF4735F495B03339C5A28694DE8B7155A8D6D018CFF54B0C9A7665CC5DC3D6123324F992F8DD7C0A456616E5DB6BEF6A348C859D6AC2C345582FA13AC5FDAAE2278426E333E5D8E218EA3624E76CD31F883D5DC340B263407D858FDB956228782E1355DA95D35962562FB111F8620B841181C7AED2DC6D916D0BE8E37467A704A9DB636E5AA3E4C0BFAFB2807FC172C72E892C8E47F21B7418B6A01906402F8ECC1F9ABDDC9C067DEDD1A3D6031273D4A7D49AEECBE61E3DBA08A00C6875610121E37DD37ACA82644981055BBF5F7DC0C1E529037C0FEE4E7057C71F2188CCBDE86367A482D16E0B381'
         coefficient←##.##.TxtHex'2FF7929381E7B3610ACA54578143C8E5426DB98D5DF74769C67FC0DB168778CE33B4BB8764320AE25CAAE241771400F72852A14DD3FED51D681BEFEE5DB5D549042FF790A788B9095851A17AF271476E81474A3CD5447D832FEA7F5573F4593286A43EECBAA1DB80EDF10FDC4E6A5AAD8AE760CFD95216C116E27AAA2EFEC7DE551088D6FAA6ACC646643DDC86E683F8873C370C03D8EE329461EE881E319975D642F8C5E3A2797E372A0067E8324C1E851112E08BABFF87C03F3A5AA20F4166272E693F49D47EF965372ED638F59BF8DD975AB725D8F5424B0838CB64D08553F0F8A37E76BEED496E9B6AAB29DBC767D9D9E89FA3D51E906B7BB91ADE1E22BB'
         #.RCode←##.##.ERROR_SUCCESS
     :Else
         :If ##.##.INVALID_HANDLE_VALUE≠hProv←##.AcquireContext ##.##.Uuid.CreateString''##.##.PROV_RSA_FULL ##.##.CRYPT_NEWKEYSET
             :If 0≠Bitlen
                 GenAlgid←##.##.AT_SIGNATURE
                 CodeFlag←Algid=##.##.CALG_RSA_KEYX
             :Else
                 :If Algid=##.##.CALG_RSA_KEYX
                     GenAlgid←##.##.AT_KEYEXCHANGE
                 :Else
                     GenAlgid←##.##.AT_SIGNATURE
                 :EndIf
                 CodeFlag←0
             :EndIf
             :If ##.##.INVALID_HANDLE_VALUE≠hKey←##.GenKey hProv GenAlgid ##.##.CRYPT_EXPORTABLE Bitlen
                 KeyBlob←##.ExportKey hKey 0 ##.##.PRIVATEKEYBLOB
                 RCode←#.RCode ⋄ ##.DestroyKey hKey ⋄ :If RCode≠##.##.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
             :EndIf
             RCode←#.RCode ⋄ ##.ReleaseContext hProv ##.##.CRYPT_DELETEKEYSET ⋄ :If RCode≠##.##.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
             :If #.RCode=##.##.ERROR_SUCCESS
                 GenAlgid←##.##.AT_SIGNATURE
                 :If ExponentOne
                 :OrIf CodeFlag
                     Type Version reserved KeyAlg magic Bitlen publicExponent modulus prime1 prime2 exponent1 exponent2 coefficient privateExponent←Decode KeyBlob
                 :EndIf
             :EndIf
         :EndIf
     :EndSelect
     :If #.RCode=##.##.ERROR_SUCCESS
         :If ExponentOne
             Type←##.##.PRIVATEKEYBLOB
             Version←2
             reserved←0
             magic←'RSA2'
             :If ×⎕NC'Key'
                 modulus publicExponent←2↑Key
                 publicExponent←##.##.IntTxt publicExponent
             :Else
                 publicExponent←1
             :EndIf
             exponent1←1
             exponent2←1
             privateExponent←1
             CodeFlag←1
         :EndIf
         :If CodeFlag
             KeyBlob←Encode Type Version reserved Algid magic Bitlen publicExponent modulus prime1 prime2 exponent1 exponent2 coefficient privateExponent
         :EndIf
     :Else
         KeyBlob←''
     :EndIf
 :CaseList ##.##.CALG_DES ##.##.CALG_3DES_112 ##.##.CALG_3DES ##.##.CALG_RC2 ##.##.CALG_RC4 ##.##.CALG_CYLINK_MEK
     Type←##.##.SIMPLEBLOB
     Version←2
     reserved←0
     KeyAlg←##.##.CALG_RSA_KEYX
     Key←(#.Win.TxtInt 1 1((⌊Bitlen÷8)-3+↑⍴Key)1/0 2 90 0),Key
     KeyBlob←Encode Type Version reserved Algid KeyAlg Key
 :Else
     #.RCode←##.##.NTE_BAD_ALGID
     KeyBlob←''
 :EndSelect
∇

:EndNamespace 
:Namespace RsaMath
⎕IO ⎕ML ⎕WX←1 3 1

∇ u←u EuclidianAlgorithm v
 :Repeat
     v u←(v|u)v
 :Until 0=v
∇

∇ u←U ExtendedEuclidianAlgorithm V;v
     ⍝ u[1] = coeffU = modular inverse of U with respect to V = (inverse of U) mod V
     ⍝ u[2] = coeffV = modular inverse of V with respect to U = (inverse of V) mod U
     ⍝ u[3] = gcd(U,V)
 v u←(0 1 V)(1 0 U)
 :While 0≠v[3]
     v u←(u-v×⌊u[3]÷v[3])v
 :EndWhile
 u[1 2]←V U|u[1 2]
∇

:EndNamespace 
:Namespace Samples
⎕IO ⎕ML ⎕WX←1 3 1

∇ EnumAlgs;NameType;Provider;ProvType;hProv;Name;Container;Version;Param
 ⎕←''
 ⎕←'*******************************************************************************'
 :For Provider ProvType :In ⌽⊂[2]#.Win.Crypt.EnumProviders
     Container←''
     :If #.Win.INVALID_HANDLE_VALUE≠hProv←#.Win.Crypt.AcquireContext''Provider ProvType #.Win.CRYPT_VERIFYCONTEXT
         Name←#.Win.Crypt.GetProvParam hProv #.Win.PP_NAME
         Container←#.Win.Crypt.GetProvParam hProv #.Win.PP_CONTAINER
         Version←#.Win.Crypt.GetProvParam hProv #.Win.PP_VERSION
         Param←#.Win.Crypt.GetProvParam hProv #.Win.PP_ENUMALGS_EX
         #.Win.Crypt.ReleaseContext hProv
         ⎕←''
         ⎕←'Provider  ',Provider
         ⎕←'Name      ',Name
         ⎕←'Container ',Container
         ⎕←'Version   ',⍕Version
         :If 2=⍴⍴Param
             ⎕←(⍉8 16 512⊤Param[;1]),1↓[2]Param
         :EndIf
     :Else
         ⎕←''
         ⎕←'Provider  ',Provider
         ⎕←'ProvType  ',⍕ProvType
         ⎕←'Status    ',#.RText,' (',(⍕#.RCode),')'
     :EndIf
     ⎕←''
     ⎕←'*******************************************************************************'
 :EndFor
∇

∇ VOID←Data SignVerify Flags;HashAlgid;Bitlen;hProv;hUserKey;hHash;Signature;HashValue;PublicBlob;PrivateBlob;bType;bVersion;reserved;aiKeyAlg;magic;bitlen;publicExponent;modulus;prime1;prime2;exponent1;exponent2;coefficient;privateExponent
 #.Win.Init
 HashAlgid←#.Win.CALG_SHA1
 Bitlen←1024
     
 PrivateBlob←#.Win.Crypt.KeyBlob.Generate #.Win.CALG_RSA_SIGN Bitlen #.Win.TRUE
 bType bVersion reserved aiKeyAlg magic bitlen publicExponent modulus prime1 prime2 exponent1 exponent2 coefficient privateExponent←#.Win.Crypt.KeyBlob.Decode PrivateBlob
 PublicBlob←#.Win.Crypt.KeyBlob.Encode #.Win.PUBLICKEYBLOB 2 0 #.Win.CALG_RSA_SIGN'RSA1'Bitlen publicExponent modulus
     
 :If #.Win.INVALID_HANDLE_VALUE=hProv←#.Win.Crypt.AcquireContext #.Win.Uuid.CreateString #.Win.MS_ENHANCED_PROV #.Win.PROV_RSA_FULL #.Win.CRYPT_NEWKEYSET
     'AcquireContext:'#.RCode #.RText
 :Else
     :If #.Win.INVALID_HANDLE_VALUE=hUserKey←PrivateBlob #.Win.Crypt.ImportKey hProv #.Win.ZERO #.Win.CRYPT_EXPORTABLE
         'ImportPrivateBlob'#.RCode #.RText
     :Else
         :If #.Win.INVALID_HANDLE_VALUE=hHash←#.Win.Crypt.CreateHash hProv HashAlgid
             'CreateHash'#.RCode #.RText
         :Else
             :If ~Data #.Win.Crypt.HashData hHash
                 'HashData'#.RCode #.RText
             :Else
                 :If 0∊⍴Signature←#.Win.Crypt.SignHash hHash #.Win.AT_SIGNATURE 0 Flags
                     'SignHash'#.RCode #.RText
                 :Else
     ⍝                    Signature[⍳93]←↑⎕AV
                     ⎕←{((↑⎕AV),'...',4↓⎕AV)[⎕AV⍳⍵]}Signature
                 :EndIf
             :EndIf
             #.Win.Crypt.DestroyHash hHash
         :EndIf
         #.Win.Crypt.DestroyKey hUserKey
     :EndIf
     #.Win.Crypt.ReleaseContext hProv #.Win.CRYPT_DELETEKEYSET
 :EndIf
     
 :If #.Win.INVALID_HANDLE_VALUE=hProv←#.Win.Crypt.AcquireContext #.Win.Uuid.CreateString #.Win.MS_ENHANCED_PROV #.Win.PROV_RSA_FULL #.Win.CRYPT_NEWKEYSET
     'AcquireContext:'#.RCode #.RText
 :Else
     :If #.Win.INVALID_HANDLE_VALUE=hUserKey←PublicBlob #.Win.Crypt.ImportKey hProv #.Win.ZERO #.Win.CRYPT_EXPORTABLE
         'ImportPrivateBlob'#.RCode #.RText
     :Else
         :If #.Win.INVALID_HANDLE_VALUE=hHash←#.Win.Crypt.CreateHash hProv HashAlgid
             'CreateHash'#.RCode #.RText
         :Else
             :If ~Data #.Win.Crypt.HashData hHash
                 'HashData'#.RCode #.RText
             :Else
                 HashValue←#.Win.Crypt.GetHashParam hHash #.Win.HP_HASHVAL
                 ⎕←{((↑⎕AV),'...',4↓⎕AV)[⎕AV⍳⍵]}HashValue
     ⍝                 #.Win.Crypt.DestroyHash hHash
     ⍝                 hHash←#.Win.Crypt.CreateHash hProv #.Win.CALG_SSL3_SHAMD5
     ⍝                 (¯36↑S)#.Win.Crypt.SetHashParam hHash #.Win.HP_HASHVAL
                 :If #.Win.FALSE=VOID←#.Win.Crypt.VerifySignature hHash Signature hUserKey 0 Flags
                     'SignHash'#.RCode #.RText
                 :Else
                     ⎕←'Signatur OK'
                 :EndIf
             :EndIf
             #.Win.Crypt.DestroyHash hHash
         :EndIf
         #.Win.Crypt.DestroyKey hUserKey
     :EndIf
     #.Win.Crypt.ReleaseContext hProv #.Win.CRYPT_DELETEKEYSET
 :EndIf
∇

∇ TEST Bitlen;VIEW;hProv;hUserKey;hHash;hSessionKey;PIN;LCBytePIN;CRYPT_INITVEC;CRYPT_VALUE;PrivateBlob;SimpleBlob;bType;bVersion;reserved;aiKeyAlg;algid;encryptedKey
     ⍝ Bitlen←1024 ⍝384
 #.Win.Init
 VIEW←{⎕AV[5⌈⎕AV⍳⍵]}
     
 CRYPT_VALUE←#.Win.TxtHex'474C4F42EF1A3CFF'   ⍝ #.SmartCard.LineProtection.GLOB_LP_CRYPT_VALUE
 CRYPT_INITVEC←#.Win.TxtHex'474C4F427894DD5A' ⍝ #.SmartCard.LineProtection.GLOB_LP_CRYPT_INITVEC
 PIN←'57E12738'
 LCBytePIN←(#.Win.TxtInt↑⍴PIN),PIN,(#.Win.TxtHex'80'),(8|-2+↑⍴PIN)⍴↑⎕AV
     
 :If #.Win.INVALID_HANDLE_VALUE≠hProv←#.Win.Crypt.AcquireContext #.Win.Uuid.CreateString #.Win.MS_ENHANCED_PROV #.Win.PROV_RSA_FULL #.Win.CRYPT_NEWKEYSET
     PrivateBlob←#.Win.Crypt.KeyBlob.Generate #.Win.AT_KEYEXCHANGE Bitlen #.Win.TRUE
     :If #.Win.INVALID_HANDLE_VALUE≠hUserKey←PrivateBlob #.Win.Crypt.ImportKey hProv #.Win.ZERO #.Win.CRYPT_EXPORTABLE
         :Select 1
         :Case 1 ⍝ ImportKey
             SimpleBlob←CRYPT_VALUE #.Win.Crypt.KeyBlob.Generate #.Win.CALG_DES Bitlen
             VIEW #.Win.HexTxt SimpleBlob
             hSessionKey←SimpleBlob #.Win.Crypt.ImportKey hProv hUserKey #.Win.CRYPT_EXPORTABLE
         :Case 2 ⍝ GenKey
             hSessionKey←#.Win.Crypt.GenKey hProv #.Win.CALG_DES #.Win.CRYPT_EXPORTABLE
         :Case 3 ⍝ DeriveKey
             :If #.Win.INVALID_HANDLE_VALUE≠hHash←#.Win.Crypt.CreateHash hProv #.Win.CALG_MD5
                 hSessionKey←#.Win.Crypt.DeriveKey hProv #.Win.CALG_DES hHash #.Win.CRYPT_EXPORTABLE
                 #.Win.Crypt.DestroyHash hHash
             :Else
                 'CreateHash'#.RCode #.RText
             :EndIf
         :EndSelect
     
         :If #.Win.INVALID_HANDLE_VALUE≠hSessionKey
             CRYPT_INITVEC #.Win.Crypt.SetKeyParam hSessionKey #.Win.KP_IV
     ⍝                #.Win.CRYPT_MODE_CBC #.Win.Crypt.SetKeyParam hSessionKey #.Win.KP_MODE   ⍝ Set DES Mode CBC
     ⍝                64 #.Win.Crypt.SetKeyParam hSessionKey #.Win.KP_MODE_BITS                ⍝ Set 64 bits
     ⍝                #.Win.PKCS5_PADDING #.Win.Crypt.SetKeyParam hSessionKey #.Win.KP_PADDING ⍝ Set PKCS5 padding
             :If 0
                 'KP_ALGID       ',#.Win.Crypt.GetKeyParam hSessionKey #.Win.KP_ALGID
                 'KP_BLOCKLEN    ',#.Win.Crypt.GetKeyParam hSessionKey #.Win.KP_BLOCKLEN
                 'KP_KEYLEN      ',#.Win.Crypt.GetKeyParam hSessionKey #.Win.KP_KEYLEN
                 'KP_PERMISSIONS ',#.Win.Crypt.GetKeyParam hSessionKey #.Win.KP_PERMISSIONS
                 'KP_IV          ',#.Win.Crypt.GetKeyParam hSessionKey #.Win.KP_IV
                 'KP_PADDING     ',#.Win.Crypt.GetKeyParam hSessionKey #.Win.KP_PADDING
                 'KP_MODE        ',#.Win.Crypt.GetKeyParam hSessionKey #.Win.KP_MODE
                 'KP_MODE_BITS   ',#.Win.Crypt.GetKeyParam hSessionKey #.Win.KP_MODE_BITS
             :EndIf
             LCBytePIN←LCBytePIN #.Win.Crypt.Encrypt hSessionKey #.Win.ZERO #.Win.TRUE
             SimpleBlob←#.Win.Crypt.ExportKey hSessionKey hUserKey #.Win.SIMPLEBLOB
             #.Win.Crypt.DestroyKey hSessionKey
     
             VIEW #.Win.HexTxt SimpleBlob
             bType bVersion reserved aiKeyAlg algid encryptedKey←#.Win.Crypt.KeyBlob.Decode SimpleBlob
     ⍝                 VIEW #.Win.HexTxt encryptedKey
     ⍝                 VIEW'00',#.Win.HexTxt encryptedKey #.Crypt.RSA modulus privateExponent
             :If #.Win.INVALID_HANDLE_VALUE≠hSessionKey←SimpleBlob #.Win.Crypt.ImportKey hProv hUserKey #.Win.CRYPT_EXPORTABLE
                 SimpleBlob←#.Win.Crypt.ExportKey hSessionKey hUserKey #.Win.SIMPLEBLOB
                 #.Win.Crypt.DestroyKey hSessionKey
                 VIEW #.Win.HexTxt SimpleBlob
             :Else
                 'ImportSimpleBlob'#.RCode #.RText
             :EndIf
         :Else
             'ImportSimpleBlob'#.RCode #.RText
         :EndIf
         #.Win.Crypt.DestroyKey hUserKey
     :Else
         'ImportPrivateBlob'#.RCode #.RText
     :EndIf
     #.Win.Crypt.ReleaseContext hProv #.Win.CRYPT_DELETEKEYSET
 :Else
     'AcquireContext:'#.RCode #.RText
 :EndIf
∇

:EndNamespace 
:EndNamespace 
:Namespace Cursor
⎕IO ⎕ML ⎕WX←1 3 1

∇ hCursor←Copy hCursor
     ⍝ Copy the specified cursor
     ⍝
     ⍝ hCursor = Handle to the cursor to be duplicated
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.NULL≠hCursor←##.CopyCursor hCursor
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {VOID}←Destroy hCursor
     ⍝ Destroy a cursor and free any memory the cursor occupied
     ⍝
     ⍝ hCursor = Handle to the cursor to be destroyed
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.ZERO≠VOID←##.DestroyCursor hCursor
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hCursor←Get
     ⍝ Retrieve a handle to the current cursor
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 hCursor←##.GetCursor
∇

∇ Posn←GetPos;VOID
     ⍝ Retrieve the cursor's position, in screen coordinates
     ⍝
     ⍝ Posn = (Y X)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.ZERO≠↑VOID Posn←##.GetCursorPos 2
     #.RCode←##.ERROR_SUCCESS
     Posn←⌽Posn
 :Else
     #.RCode←##.GetLastError
     Posn←0 0
 :EndIf
∇

∇ hCursor←Load Parms;hInstance;FileName
     ⍝ Load the specified cursor resource from the executable (.EXE) file associated with an application instance
     ⍝
     ⍝ Parms[1] = hInstance Handle to an instance of the module whose executable file contains the cursor to be loaded
     ⍝ Parms[2] = FileName  Name of the cursor resource or number of the resource identifier
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hInstance FileName←2↑Parms
 :If 82=⎕DR FileName
     :If ##.NULL≠hCursor←##.LoadCursor hInstance FileName
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :ElseIf 65536>FileName
     :If ##.NULL≠hCursor←##.LoadCursorI hInstance FileName
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     hCursor←##.NULL
     #.RCode←##.ERROR_INVALID_DATA
 :EndIf
∇

∇ hCursor←LoadFromFile FileName
     ⍝ Create a cursor based on data contained in a file
     ⍝
     ⍝ FileName = Name of a file in .CUR/.ANI format or number of a system resource identifier
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 82=⎕DR FileName
     :If ##.NULL≠hCursor←##.LoadCursorFromFile⊂FileName
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :ElseIf 65536>FileName
     :If ##.NULL≠hCursor←##.LoadCursorFromFileI FileName
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     hCursor←##.NULL
     #.RCode←##.ERROR_INVALID_DATA
 :EndIf
∇

∇ hCursor←Set hCursor
     ⍝ Set the cursor shape
     ⍝
     ⍝ hCursor = Handle to the previous/new cursor
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hCursor←##.SetCursor hCursor
∇

∇ {VOID}←SetPos Posn
     ⍝ Move the cursor to the specified screen coordinates
     ⍝
     ⍝ Posn = (Y X)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 Posn←⌽2↑Posn
 :If ##.ZERO≠VOID←##.SetCursorPos Posn
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {VOID}←SetSystem Parms;hCursor;id
     ⍝ Enable an application to customize the system cursors
     ⍝
     ⍝ Parms[1] = hCursor Handle to new cursor
     ⍝ Parms[2] = id      Any of the #.Win.OCR_xxx for a specific cursor type to replace
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hCursor id←2↑Parms
 :If ##.ZERO≠VOID←##.SetSystemCursor hCursor id
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {Counter}←Show bShow
     ⍝ Display or hide the cursor
     ⍝
     ⍝ bShow  #.Win.TRUE: increment display count. #.Win.FALSE: decrement display count
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 Counter←##.ShowCursor bShow
∇

:EndNamespace 
:Namespace Event
⎕IO ⎕ML ⎕WX←1 3 1

∇ {ValidFlag}←DeregisterSource hEventLog
     ⍝ Close a write handle to the specified event log
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.DeregisterEventSource hEventLog
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hEventLog←RegisterSource Parms;UNCServerName;SourceName
     ⍝ Retrieve a registered handle to an event log (to be closed by #.Win.Event.DeregisterSource)
     ⍝
     ⍝ Parms    = SourceName
     ⍝ or
     ⍝ Parms[1] = UNCServerName UNC name of the server on which this operation is to be performed ('' = local computer)
     ⍝ Parms[2] = SourceName    'Application' (def.) 'Security' or 'System' or 'WinApp' (any key under HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\EventLog)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     UNCServerName←''
     SourceName←,Parms
 :ElseIf 1=↑⍴Parms
     UNCServerName←,↑Parms
     SourceName←''
 :Else
     UNCServerName SourceName←2↑Parms
 :EndIf
 :If ''≡UNCServerName
     :If ##.NULL≠hEventLog←##.RegisterEventSourceI 0 SourceName
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         hEventLog←##.INVALID_HANDLE_VALUE
     :EndIf
 :ElseIf ##.NULL≠hEventLog←##.RegisterEventSource UNCServerName SourceName
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hEventLog←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ {ValidFlag}←Report Parms;hEventLog;Type;Category;EventID;UserSid;NumStrings;DataSize;Strings;RawData;lpStrings;RegisterFlag;RCode
     ⍝ Write an entry at the end of the specified event log
     ⍝
     ⍝ Parms[1] = hEventLog Handle to event log or SourceName or (UNCServerName SourceName)
     ⍝ Parms[2] = Type      Event type (#.Win.EVENTLOG_SUCCESS #.Win.EVENTLOG_ERROR_TYPE #.Win.EVENTLOG_WARNING_TYPE #.Win.EVENTLOG_INFORMATION_TYPE #.Win.EVENTLOG_AUDIT_SUCCESS or #.Win.EVENTLOG_AUDIT_FAILURE)
     ⍝ Parms[3] = Category  Event category
     ⍝ Parms[4] = EventID   Event identifier
     ⍝ Parms[5] = UserSid   User security identifier or Username
     ⍝ Parms[6] = Strings   Array of strings to merge
     ⍝ Parms[7] = RawData   Binary data buffer
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hEventLog Type Category EventID UserSid Strings RawData←7↑Parms
 DataSize←↑⍴RawData←##.IntTxt RawData
 :If 0∊⍴UserSid
     UserSid←⎕AN
 :EndIf
 :If ~(↑⎕AV)∊UserSid
     UserSid←↑##.Security.LookupAccountName UserSid
 :EndIf
 :If 2>≡Strings
     Strings←,⊂,Strings
 :EndIf
 :If ×↑⍴Strings
     lpStrings←##.Mem.Alloc¨Strings,¨↑⎕AV
 :Else
     lpStrings←⍬
 :EndIf
 NumStrings←↑⍴lpStrings
 :If RegisterFlag←82=⎕DR hEventLog
 :AndIf ~ValidFlag←##.INVALID_HANDLE_VALUE≠hEventLog←RegisterSource hEventLog
     :Return
 :EndIf
 :If ×↑⍴UserSid
     UserSid←##.IntTxt UserSid
     :If ValidFlag←##.ReportEvent hEventLog Type Category EventID UserSid NumStrings DataSize lpStrings RawData
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :ElseIf ValidFlag←##.ReportEventI hEventLog Type Category EventID ##.NULL NumStrings DataSize lpStrings RawData
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
 :If ×↑⍴Strings
     ##.Mem.Free¨lpStrings
 :EndIf
 :If RegisterFlag
     RCode←#.RCode ⋄ ValidFlag∧←DeregisterSource hEventLog ⋄ :If RCode≠#.Win.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
 :EndIf
∇

∇ ReportRCode;RCode;Stack;RawData
 #.Win.Init
 :If #.RCode≠#.Win.ERROR_SUCCESS
     RCode←#.RCode
     Stack←(⌽(1↓⎕XSI),¨'[',¨(⍕¨1↓⎕LC),¨']'),2↑⎕DM
     RawData←(∊Stack,¨↑⎕AV),↑⎕AV
     Report'Dyalog'#.Win.EVENTLOG_ERROR_TYPE 100 RCode ⎕AN''RawData
     #.RCode←RCode
 :EndIf
∇

:Namespace Log
⎕IO ⎕ML ⎕WX←1 3 1

∇ {ValidFlag}←Backup Parms;hEventLog;BackupFileName
     ⍝ Save the specified event log to a backup file. The function does not clear the event log
     ⍝
     ⍝ Parms[1] = hEventLog      Handle to event log
     ⍝ Parms[2] = BackupFileName Name of backup file
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 hEventLog BackupFileName←2↑Parms
 :If ValidFlag←##.##.BackupEventLog hEventLog BackupFileName
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←Clear Parms;hEventLog;BackupFileName
     ⍝ Clear the specified event log, and optionally saves the current copy of the logfile to a backup file
     ⍝
     ⍝ Parms[1] = hEventLog      Handle to event log
     ⍝ Parms[2] = BackupFileName (opt) Name of backup file
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 2>≡Parms
     hEventLog←↑Parms
     :If ValidFlag←##.##.ClearEventLogI hEventLog 0
         #.RCode←##.##.ERROR_SUCCESS
     :Else
         #.RCode←##.##.GetLastError
     :EndIf
 :Else
     hEventLog BackupFileName←2↑Parms
     :If ValidFlag←##.##.ClearEventLog hEventLog BackupFileName
         #.RCode←##.##.ERROR_SUCCESS
     :Else
         #.RCode←##.##.GetLastError
     :EndIf
 :EndIf
∇

∇ {ValidFlag}←Close hEventLog
     ⍝ Close a read handle to the specified event log
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If ValidFlag←##.##.CloseEventLog hEventLog
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

∇ NumberOfRecords←GetNumberOfRecords hEventLog;ValidFlag
     ⍝ Retrieve the number of records in the specified event log
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If ↑ValidFlag NumberOfRecords←##.##.GetNumberOfEventLogRecords hEventLog 1
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
     NumberOfRecords←¯1
 :EndIf
∇

∇ OldestRecord←GetOldestRecord hEventLog;ValidFlag
     ⍝ Retrieve the absolute record number of the oldest record in the specified event log
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If ↑ValidFlag OldestRecord←##.##.GetOldestEventLogRecord hEventLog 1
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
     OldestRecord←¯1
 :EndIf
∇

∇ {ValidFlag}←NotifyChange Parms;hEventLog;hEvent
     ⍝ Enable an application to receive notification when an event is written to the specified event logfile
     ⍝ When the event is written to the event logfile, the specified event object is set to the signaled state
     ⍝
     ⍝ Parms[1] = hEventLog Handle to event log
     ⍝ Parms[2] = hEvent    Handle to event object
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 hEventLog hEvent←2↑Parms
 :If ValidFlag←##.##.NotifyChangeEventLog hEventLog hEvent
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

∇ hEventLog←Open Parms;UNCServerName;SourceName
     ⍝ Open a handle to an event log
     ⍝
     ⍝ Parms    = SourceName
     ⍝ or
     ⍝ Parms[1] = UNCServerName UNC name of the server on which this operation is to be performed ('' = local computer)
     ⍝ Parms[2] = SourceName    'Application' (def.) 'Security' or 'System' or 'WinApp' (any key under HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\EventLog)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 2>≡Parms
     UNCServerName←''
     SourceName←,Parms
 :ElseIf 1=↑⍴Parms
     UNCServerName←,↑Parms
     SourceName←''
 :Else
     UNCServerName SourceName←2↑Parms
 :EndIf
 :If ''≡UNCServerName
     :If ##.##.NULL≠hEventLog←##.##.OpenEventLogI 0 SourceName
         #.RCode←##.##.ERROR_SUCCESS
     :Else
         #.RCode←##.##.GetLastError
         hEventLog←##.##.INVALID_HANDLE_VALUE
     :EndIf
 :ElseIf ##.##.NULL≠hEventLog←##.##.OpenEventLog UNCServerName SourceName
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
     hEventLog←##.##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ hEventLog←OpenBackup Parms;UNCServerName;FileName
     ⍝ Open a handle to a backup event log. This handle can be used with the BackupEventLog function
     ⍝
     ⍝ Parms    = FileName
     ⍝ or
     ⍝ Parms[1] = UNCServerName UNC name of the server on which this operation is to be performed ('' = local computer)
     ⍝ Parms[2] = FileName      Backup file name
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 2>≡Parms
     UNCServerName←''
     FileName←,Parms
 :ElseIf 1=↑⍴Parms
     UNCServerName←,↑Parms
     FileName←''
 :Else
     UNCServerName FileName←2↑Parms
 :EndIf
 :If ''≡UNCServerName
     :If ##.##.NULL≠hEventLog←##.##.OpenBackupEventLogI 0 FileName
         #.RCode←##.##.ERROR_SUCCESS
     :Else
         #.RCode←##.##.GetLastError
         hEventLog←##.##.INVALID_HANDLE_VALUE
     :EndIf
 :ElseIf ##.##.NULL≠hEventLog←##.##.OpenBackupEventLog UNCServerName FileName
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
     hEventLog←##.##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ Buffer←Read Parms;hEventLog;ReadFlags;RecordOffset;NumberOfBytesToRead;BytesRead;MinNumberOfBytesNeeded;ValidFlag
     ⍝ Read a whole number of entries from the specified event log in chronological or reverse chronological order
     ⍝
     ⍝ Parms[1] = hEventLog           Handle to event log
     ⍝ Parms[2] = ReadFlags           How to read log (#.Win.EVENTLOG_SEEK_READ/#.Win.EVENTLOG_SEQUENTIAL_READ+#.Win.EVENTLOG_FORWARDS_READ/#.Win.EVENTLOG_BACKWARDS_READ)
     ⍝ Parms[3] = RecordOffset        Offset of first record
     ⍝ Parms[4] = NumberOfBytesToRead Bytes to read
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 hEventLog ReadFlags RecordOffset NumberOfBytesToRead←4↑Parms
 Buffer←NumberOfBytesToRead
 BytesRead←1
 MinNumberOfBytesNeeded←1
 :If ↑ValidFlag Buffer BytesRead MinNumberOfBytesNeeded←##.##.ReadEventLog hEventLog ReadFlags RecordOffset Buffer NumberOfBytesToRead BytesRead MinNumberOfBytesNeeded
     Buffer←BytesRead↑Buffer
     #.RCode←##.##.ERROR_SUCCESS
 :ElseIf ##.##.ERROR_INSUFFICIENT_BUFFER=#.RCode←##.##.GetLastError
     Buffer←MinNumberOfBytesNeeded
 :Else
     Buffer←''
 :EndIf
∇

:EndNamespace 
:EndNamespace 
:Namespace File
⎕IO ⎕ML ⎕WX ⎕CT←1 3 1 9.999999999999998E¯15

∇ {FileAttributes}←{FileAttributes}Attrib FileName
     ⍝ Sets and/or Gets file attributes of FileName.
     ⍝ FileAttributes = Vector of 1st Characters: Readonly Hidden System Directory Archive Normal Temporary Compressed Offline
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×⎕NC'FileAttributes'
     FileAttributes←2⊥'EXOCIPTNVADLSHR'∊FileAttributes
     :If ##.SetFileAttributes FileName FileAttributes
     :AndIf ¯1≠FileAttributes←##.GetFileAttributes⊂FileName
         FileAttributes←⌽(2 2 2 2 2 2 2 2 2 2 2 2 2 2 2⊤↑FileAttributes)/'EXOCIPTNVADLSHR'
         #.RCode←##.ERROR_SUCCESS
     :Else
         FileAttributes←''
         #.RCode←##.GetLastError
     :EndIf
 :ElseIf ¯1≠FileAttributes←##.GetFileAttributes⊂FileName
     FileAttributes←⌽(2 2 2 2 2 2 2 2 2 2 2 2 2 2 2⊤↑FileAttributes)/'EXOCIPTNVADLSHR'
     #.RCode←##.ERROR_SUCCESS
 :Else
     FileAttributes←''
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {InvalidFlag}←Close hObject
     ⍝ Closes an open handle to an object such as a file handle.
     ⍝ VOID = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.CloseHandle hObject
     #.RCode←##.ERROR_SUCCESS
     InvalidFlag←0
 :Else
     #.RCode←##.GetLastError
     InvalidFlag←1
 :EndIf
∇

∇ {ValidFlag}←Copy Parms;ExistingFileName;NewFileName;FailIfExists
     ⍝ Copies an existing file to a new file
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Select ↑⍴Parms
 :Case 2
     ExistingFileName NewFileName←Parms
     FailIfExists←##.TRUE
 :Case 3
     ExistingFileName NewFileName FailIfExists←Parms
 :Else
     #.RCode←##.ERROR_INVALID_PARAMETER
     ValidFlag←0
     :Return
 :EndSelect
 :If ValidFlag←##.CopyFile ExistingFileName NewFileName FailIfExists
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hFile←Create Parms;FileName;DesiredAccess;ShareMode;CreationDistribution;FlagsAndAttributes
     ⍝ Create or open a file and return a handle for access
     ⍝
     ⍝ Parms[1] = FileName             Required
     ⍝ Parms[2] = DesiredAccess        (def RW)        #.Win.GENERIC_READ+#.Win.GENERIC_WRITE
     ⍝ Parms[3] = ShareMode            (def RW)        #.Win.FILE_SHARE_NONE+#.Win.FILE_SHARE_READ+#.Win.FILE_SHARE_WRITE+#.Win.FILE_SHARE_DELETE
     ⍝ Parms[4] = CreationDistribution (def CreateNew) #.Win.CREATE_NEW CREATE_ALWAYS #.Win.OPEN_EXISTING #.Win.OPEN_ALWAYS or #.Win.TRUNCATE_EXISTING
     ⍝ Parms[5] = FlagsAndAttributes   (def Normal)    #.Win.FILE_ATTRIBUTE_READONLY+#.Win.FILE_ATTRIBUTE_HIDDEN+#.Win.FILE_ATTRIBUTE_SYSTEM+#.Win.FILE_ATTRIBUTE_DIRECTORY+#.Win.FILE_ATTRIBUTE_ARCHIVE+#.Win.FILE_ATTRIBUTE_NORMAL+#.Win.FILE_ATTRIBUTE_TEMPORARY+#.Win.FILE_ATTRIBUTE_COMPRESSED
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     Parms←,⊂Parms
 :EndIf
 :Select ↑⍴Parms
 :Case 1
     FileName←↑Parms
     DesiredAccess←##.GENERIC_READ+##.GENERIC_WRITE
     ShareMode←##.FILE_SHARE_READ+##.FILE_SHARE_WRITE
     CreationDistribution←##.CREATE_NEW
     FlagsAndAttributes←##.FILE_ATTRIBUTE_NORMAL
 :Case 2
     FileName DesiredAccess←Parms
     ShareMode←##.FILE_SHARE_READ+##.FILE_SHARE_WRITE
     CreationDistribution←##.CREATE_NEW
     FlagsAndAttributes←##.FILE_ATTRIBUTE_NORMAL
 :Case 3
     FileName DesiredAccess ShareMode←Parms
     CreationDistribution←##.CREATE_NEW
     FlagsAndAttributes←##.FILE_ATTRIBUTE_NORMAL
 :Case 4
     FileName DesiredAccess ShareMode CreationDistribution←Parms
     FlagsAndAttributes←##.FILE_ATTRIBUTE_NORMAL
 :Case 5
     FileName DesiredAccess ShareMode CreationDistribution FlagsAndAttributes←Parms
 :EndSelect
 :If ##.INVALID_HANDLE_VALUE≠hFile←##.CreateFile FileName DesiredAccess ShareMode ##.SECURITY_ATTRIBUTES CreationDistribution FlagsAndAttributes ##.NULL
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←CreateDirectory PathName
     ⍝ Creates a new directory
     ⍝ ValidFlag = 0=Fail 1=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.CreateDirectory PathName ##.SECURITY_ATTRIBUTES
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {PathName}←CurrentDirectory PathName
     ⍝ Sets and/or Gets the current default directory of this task.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0∊⍴PathName
     :If 0∊⍴PathName←↑↑/##.GetCurrentDirectory ##.MAX_PATH ##.MAX_PATH
         #.RCode←##.GetLastError
     :Else
         #.RCode←##.ERROR_SUCCESS
     :EndIf
 :ElseIf ~##.SetCurrentDirectory⊂,PathName
 :OrIf 0∊⍴PathName←↑↑/##.GetCurrentDirectory ##.MAX_PATH ##.MAX_PATH
     #.RCode←##.GetLastError
     PathName←''
 :Else
     #.RCode←##.ERROR_SUCCESS
 :EndIf
∇

∇ {ValidFlag}←Delete Parms;FileName;WhipeFlag;hFile;FileSizeLow;FileSizeHigh;FileSize;NumberOfBytesToWrite;Buffer;Full;Last
     ⍝ Deletes a file, optionally whipes out the file contents first
     ⍝
     ⍝ Parms[1] = FileName   File to be deleted
     ⍝ Parms[2] = WhipeFlag  (def 0) When 1, the file is overwritten prior to delete
     ⍝
     ⍝ On error 0 is returned, #.RCode should then be checked
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 1<≡Parms
     FileName WhipeFlag←2↑Parms,0
 :Else
     FileName←,Parms
     WhipeFlag←0
 :EndIf
 :If WhipeFlag
     :If ValidFlag←##.INVALID_HANDLE_VALUE≠hFile←##.CreateFile FileName ##.GENERIC_WRITE ##.FILE_SHARE_NONE ##.SECURITY_ATTRIBUTES ##.OPEN_EXISTING(##.FILE_ATTRIBUTE_NORMAL+##.FILE_FLAG_SEQUENTIAL_SCAN+##.FILE_FLAG_WRITE_THROUGH+##.FILE_FLAG_DELETE_ON_CLOSE)##.NULL
         #.RCode←##.ERROR_SUCCESS
         :If ValidFlag←##.INVALID_FILE_SIZE≠↑FileSizeLow FileSizeHigh←##.GetFileSize hFile 1
         :OrIf ValidFlag←##.ERROR_SUCCESS=#.RCode←##.GetLastError
             FileSize←⌊4294967296⊥FileSizeHigh(4294967296|FileSizeLow)
             NumberOfBytesToWrite←↑⍴Buffer←##.IntTxt ⎕AV[?4096⍴256]
             Full Last←0 NumberOfBytesToWrite⊤FileSize
             :While 0 0≢Full Last
                 :If ¯1=Full←¯1+Full
                     NumberOfBytesToWrite←Last
                 :EndIf
                 :If ValidFlag←1 NumberOfBytesToWrite≡##.WriteFileI1 hFile Buffer NumberOfBytesToWrite 1 0
                 :Else
                     #.RCode←##.GetLastError
                     :Leave
                 :EndIf
             :Until ¯1=Full
         :EndIf
         :If ##.CloseHandle hFile
         :ElseIf ValidFlag
             #.RCode←##.GetLastError
             ValidFlag←0
         :EndIf
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :ElseIf ValidFlag←##.DeleteFile⊂FileName
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {OutBuffer}←{InBuffer}DeviceIoControl Parms;hDevice;IoControlCode;InBufferSize;OutBuffer;OutBufferSize;BytesReturned;Overlapped;VOID
     ⍝ Submits and requests an IO control command to an open object.
     ⍝ Parms[1]  = hDevice
     ⍝ Parms[2]  = IoControlCode
     ⍝ Parms[3]  = OutBufferSize
     ⍝ InBuffer  = Buffer to submit
     ⍝ OutBuffer = Buffer to receive
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hDevice IoControlCode OutBufferSize←3↑Parms
 :If ~×⎕NC'InBuffer'
     InBuffer←''
 :EndIf
 :If 82=⎕DR InBuffer←,InBuffer
     :If 0∊⍴InBuffer
         OutBuffer←(|OutBufferSize)⍴↑⎕AV
         :If ##.TRUE≠↑VOID OutBuffer BytesReturned←##.DeviceIoControlRT hDevice IoControlCode ##.NULL 0 OutBuffer(|OutBufferSize)1 ##.NULL
             #.RCode←##.GetLastError
             :If 0≥OutBufferSize
                 OutBuffer←⍬
             :EndIf
         :ElseIf 0<OutBufferSize
         :AndIf BytesReturned≠OutBufferSize
             #.RCode←##.ERROR_BAD_LENGTH
         :Else
             #.RCode←##.ERROR_SUCCESS
             OutBuffer←BytesReturned↑OutBuffer
         :EndIf
     :ElseIf 0=OutBufferSize
         InBufferSize←↑⍴InBuffer←##.IntTxt InBuffer
         :If ##.TRUE≠↑VOID BytesReturned←##.DeviceIoControlWT hDevice IoControlCode InBuffer InBufferSize ##.NULL 0 1 ##.NULL
             #.RCode←##.GetLastError
             OutBuffer←⍬
         :Else
             #.RCode←##.ERROR_SUCCESS
             OutBuffer←''
         :EndIf
     :Else
         OutBuffer←(|OutBufferSize)↑InBuffer
         InBufferSize←↑⍴InBuffer←##.IntTxt InBuffer
         :If ##.TRUE≠↑VOID OutBuffer BytesReturned←##.DeviceIoControlRWT hDevice IoControlCode InBuffer InBufferSize OutBuffer(|OutBufferSize)1 ##.NULL
             #.RCode←##.GetLastError
             :If 0≥OutBufferSize
                 OutBuffer←⍬
             :EndIf
         :ElseIf 0<OutBufferSize
         :AndIf BytesReturned≠OutBufferSize
             #.RCode←##.ERROR_BAD_LENGTH
         :Else
             #.RCode←##.ERROR_SUCCESS
             OutBuffer←BytesReturned↑OutBuffer
         :EndIf
     :EndIf
 :Else
     :If 0∊⍴InBuffer
         OutBuffer←4 ##.TxtInt(|OutBufferSize)⍴0
         :If ##.TRUE≠↑VOID OutBuffer BytesReturned←##.DeviceIoControlRI hDevice IoControlCode ##.NULL 0 OutBuffer(4×|OutBufferSize)1 ##.NULL
             #.RCode←##.GetLastError
             :If 0≥OutBufferSize
                 OutBuffer←''
             :EndIf
         :ElseIf 0<OutBufferSize
         :AndIf BytesReturned≠4×OutBufferSize
             #.RCode←##.ERROR_BAD_LENGTH
         :Else
             #.RCode←##.ERROR_SUCCESS
             OutBuffer←(⌊0.25×BytesReturned)↑OutBuffer
         :EndIf
     :ElseIf 0=OutBufferSize
         InBufferSize←4×↑⍴InBuffer
         :If ##.TRUE≠↑VOID BytesReturned←##.DeviceIoControlWI hDevice IoControlCode InBuffer InBufferSize ##.NULL 0 1 ##.NULL
             #.RCode←##.GetLastError
             OutBuffer←''
         :Else
             #.RCode←##.ERROR_SUCCESS
             OutBuffer←⍬
         :EndIf
     :Else
         OutBuffer←(|OutBufferSize)↑InBuffer
         InBufferSize←4×↑⍴InBuffer
         :If ##.TRUE≠↑VOID OutBuffer BytesReturned←##.DeviceIoControlRWI hDevice IoControlCode InBuffer InBufferSize OutBuffer(4×|OutBufferSize)1 ##.NULL
             #.RCode←##.GetLastError
             :If 0≥OutBufferSize
                 OutBuffer←''
             :EndIf
         :ElseIf 0<OutBufferSize
         :AndIf BytesReturned≠4×OutBufferSize
             #.RCode←##.ERROR_BAD_LENGTH
         :Else
             #.RCode←##.ERROR_SUCCESS
             OutBuffer←(⌊0.25×BytesReturned)↑OutBuffer
         :EndIf
     :EndIf
 :EndIf
∇

∇ hFile←DeviceOpen DriveNumberNameVxD;FileName;DesiredAccess;ShareMode;CreationDistribution;FlagsAndAttributes
     ⍝ Opens a physical hard disk, partition or VxD(Win95) as a file.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 82≠⎕DR DriveNumberNameVxD
     FileName←'\\.\PHYSICALDRIVE',⍕↑DriveNumberNameVxD  ⍝ Access physical hard disk: 0 1 ... (eg access MBR)
 :Else
     FileName←'\\.\',DriveNumberNameVxD                 ⍝ Access partition: A: C: ... (eg access a boot block)
 :EndIf                                                 ⍝ Or access a Win95 VxD
 DesiredAccess←##.GENERIC_READ+##.GENERIC_WRITE
 ShareMode←##.FILE_SHARE_READ+##.FILE_SHARE_WRITE
 CreationDistribution←##.OPEN_EXISTING
 FlagsAndAttributes←##.FILE_FLAG_DELETE_ON_CLOSE+##.FILE_ATTRIBUTE_NORMAL
 :If ##.INVALID_HANDLE_VALUE≠hFile←##.CreateFile FileName DesiredAccess ShareMode ##.SECURITY_ATTRIBUTES CreationDistribution FlagsAndAttributes ##.NULL
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ FileList←Find FileName;hFindFile;FindFileData;FindFileDatas;ValidFlag
     ⍝ Filds all available files in a directory\wildcard.
     ⍝
     ⍝ FileName     = directory\wildcard   eg 'C:\WINNT\SYSTEM32\*.INI'
     ⍝
     ⍝ FileList[;1] = FileAttributes       Vector of 1st Characters: Readonly Hidden System Directory Archive Normal Temporary Compressed Offline
     ⍝ FileList[;2] = Local CreationTime   Year Month Day Hour Minute Second Milliseconds DayOfWeek
     ⍝ FileList[;3] = Local LastAccessTime Year Month Day Hour Minute Second Milliseconds DayOfWeek
     ⍝ FileList[;4] = Local LastWriteTime  Year Month Day Hour Minute Second Milliseconds DayOfWeek
     ⍝ FileList[;5] = FileSize             Bytes
     ⍝ FileList[;6] = FileName             Long Filename
     ⍝ FileList[;7] = AlternateFileName    Classic 8.3 (filename.ext) Filename Format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.INVALID_HANDLE_VALUE≠↑hFindFile FindFileData←##.FindFirstFile FileName 0
     FindFileDatas←,⊂FindFileData
     :While ↑ValidFlag FindFileData←##.FindNextFile hFindFile 0
         FindFileDatas,←⊂FindFileData
     :EndWhile
     :If ##.ERROR_NO_MORE_FILES=#.RCode←##.GetLastError
         #.RCode←##.ERROR_SUCCESS
         FindFileDatas←⊃FindFileDatas
         FileList←(⌽¨(⊂[1]2 2 2 2 2 2 2 2 2 2 2 2 2 2 2⊤FindFileDatas[;1])/¨⊂'EXOCIPTNVADLSHR'),({⍵[1 2 4 5 6 7 8 3]}¨2⊃¨##.FileTimeToSystemTime¨(1↓¨##.FileTimeToLocalFileTime¨(⊂¨FindFileDatas[;2 3 4]),¨0),¨0),(⌊4294967296⊥⊃[1]FindFileDatas[;5]),{(¯1+⍵⍳¨↑⎕AV)↑¨⍵}FindFileDatas[;8 9]
     :Else
         FileList←0 7⍴(⊂''),(3⍴⊂8⍴0),0 '' ''
     :EndIf
     ValidFlag←##.FindClose hFindFile
 :Else
     #.RCode←##.GetLastError
     FileList←0 7⍴(⊂''),(3⍴⊂8⍴0),0 '' ''
 :EndIf
∇

∇ DriveType←GetDriveType RootPathName
     ⍝ Determine whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.
     ⍝
     ⍝ RootPathName = Root directory of disk to return information about (eg: 'c:\' 'd:\' '\\NS7000\DATEN01\')
     ⍝ DriveType    = One of these: #.Win.DRIVE_UNKNOWN #.Win.DRIVE_NO_ROOT_DIR #.Win.DRIVE_REMOVABLE #.Win.DRIVE_FIXED #.Win.DRIVE_REMOTE #.Win.DRIVE_CDROM #.Win.DRIVE_RAMDISK
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 1<≡RootPathName
     RootPathName←{⍵,¨(⍵∊'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',¨':')/¨'\'}RootPathName
     DriveType←##.GetDriveType¨⊂¨RootPathName
 :Else
     RootPathName←{⍵,((⊂⍵)∊'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',¨':')/'\'}RootPathName
     DriveType←##.GetDriveType⊂RootPathName
 :EndIf
∇

∇ Bytes←GetFreeSpace DirectoryName;VOID;FreeBytesAvailableToCaller;TotalNumberOfBytes;TotalNumberOfFreeBytes;SectorsPerCluster;BytesPerSector;NumberOfFreeClusters;TotalNumberOfClusters;RootPathName
     ⍝ Bytes[1] = Free Bytes on Disk available to the Caller
     ⍝ Bytes[2] = Number of Bytes on Disk
     ⍝ Bytes[3] = Free Bytes on Disk
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 RootPathName←{(((,⍵)⍳':')↑⍵,':'),'\'}DirectoryName
 :If ##.ZERO≠↑VOID FreeBytesAvailableToCaller TotalNumberOfBytes TotalNumberOfFreeBytes←##.GetDiskFreeSpaceEx DirectoryName 2 2 2
     #.RCode←##.ERROR_SUCCESS
     Bytes←⌊4294967296⊥¨⌽¨FreeBytesAvailableToCaller TotalNumberOfBytes TotalNumberOfFreeBytes
 :ElseIf ##.ZERO≠↑VOID SectorsPerCluster BytesPerSector NumberOfFreeClusters TotalNumberOfClusters←##.GetDiskFreeSpace RootPathName 1 1 1 1
     #.RCode←##.ERROR_SUCCESS
     Bytes←3⍴⌊NumberOfFreeClusters TotalNumberOfClusters×SectorsPerCluster×BytesPerSector
 :Else
     #.RCode←##.GetLastError
     Bytes←0 0 0
 :EndIf
∇

∇ PathFileExtension←GetFullPathName FileName;lpBuffer;BufferLength;lpFilePart;FullPathName;PathName;FilePart;lpExtension;Extension;RCode
     ⍝ Gets PathName FileName Extension from a given FileName
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.NULL≠lpBuffer←##.Mem.Alloc BufferLength←1024
 :AndIf ##.ZERO≠↑BufferLength lpFilePart←##.GetFullPathNameI FileName BufferLength lpBuffer 0
     lpFilePart←0⌈lpFilePart-lpBuffer
     FullPathName←BufferLength ##.Mem.Free lpBuffer
     PathName←lpFilePart↑FullPathName
     FilePart←lpFilePart↓FullPathName
     lpExtension←-(↑⍴FilePart)|¯1+(⌽FilePart)⍳'.'
     FileName←FileName,('.'≠¯1↑FileName←lpExtension↓FilePart)⍴'.'
     Extension←lpExtension↑FilePart
 :Else
     :If ##.NULL≠lpBuffer
         :If ##.ERROR_SUCCESS=RCode←##.GetLastError
             RCode←##.ERROR_INVALID_NAME
         :EndIf
         ##.Mem.Free lpBuffer
         #.RCode←RCode
     :EndIf
     PathName←''
     FileName←''
     Extension←''
 :EndIf
 PathFileExtension←PathName FileName Extension
∇

∇ Information←GetInformation hFile;VOID;BY_HANDLE_FILE_INFORMATION
     ⍝ Retreives all available information about a given file handle.
     ⍝ Information[1] = FileAttributes:       Vector of 1st Characters: Readonly Hidden System Directory Archive Normal Temporary Compressed Offline
     ⍝ Information[2] = Local CreationTime:   Year Month Day Hour Minute Second Milliseconds DayOfWeek
     ⍝ Information[3] = Local LastAccessTime: Year Month Day Hour Minute Second Milliseconds DayOfWeek
     ⍝ Information[4] = Local LastWriteTime:  Year Month Day Hour Minute Second Milliseconds DayOfWeek
     ⍝ Information[5] = FileSize:             Bytes
     ⍝ Information[6] = VolumeSerialNumber:   XXXX-XXXX Volume Number of the Volume where the File is located on.
     ⍝ Information[7] = FileIndex             Unique File Identification Number
     ⍝ Information[8] = NumberOfLinks:        Number of Directories this file exists in (95/NT4 always 1)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.ZERO≠↑VOID BY_HANDLE_FILE_INFORMATION←##.GetFileInformationByHandle hFile 0
     #.RCode←##.ERROR_SUCCESS
     Information←(⊂⌽(2 2 2 2 2 2 2 2 2 2 2 2 2 2 2⊤↑BY_HANDLE_FILE_INFORMATION)/'EXOCIPTNVADLSHR'),({⍵[1 2 4 5 6 7 8 3]}¨2⊃¨##.FileTimeToSystemTime¨(1↓¨##.FileTimeToLocalFileTime¨(⊂¨BY_HANDLE_FILE_INFORMATION[2 3 4]),¨0),¨0),(4294967296⊥6⊃BY_HANDLE_FILE_INFORMATION),(⊂('-','0123456789ABCDEF'[1+(8⍴16)⊤5⊃BY_HANDLE_FILE_INFORMATION])[2 3 4 5 1 6 7 8 9]),(⌊4294967296⊥8⊃BY_HANDLE_FILE_INFORMATION),BY_HANDLE_FILE_INFORMATION[7]
 :Else
     #.RCode←##.GetLastError
     Information←'',(3⍴⊂8⍴0),¯1 '0000-0000' 0 0
 :EndIf
∇

∇ DriveStrings←GetLogicalDriveStrings;BufferLength;Buffer
     ⍝ Fill a buffer with strings that specify valid drives in the system.
     ⍝
     ⍝ DriveStrings = Vector of vectors of all availabel drives (eg: 'c:\' 'd:\')
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠↑BufferLength Buffer←##.GetLogicalDriveStrings 4096 4096
     #.RCode←##.ERROR_SUCCESS
     DriveStrings←{(⍵≠↑⎕AV)⊂⍵}BufferLength↑Buffer
 :Else
     #.RCode←##.GetLastError
     DriveStrings←0⍴,⊂''
 :EndIf
∇

∇ FileName←GetTempFileName Parms;PathName;PrefixString;Unique
     ⍝ Create name for a temporary file
     ⍝
     ⍝ Parms[1] = PathName     (def %TEMP%) Directory path for FileName
     ⍝ Parms[2] = PrefixString (def 'APL') Use first three chars as prefix of FileName
     ⍝ Parms[3] = Unique       (def 0) ≠0:  Append as hex string to PrefixString, then do not create and test whether unique
     ⍝
     ⍝ FileName = Concatenation of PathName, PrefixString, hex string from Unique, and .tmp extension
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 1<≡Parms
     :Select ↑⍴,Parms
     :Case 1
         PathName PrefixString Unique←Parms,'' 0
     :Case 2
         PathName PrefixString Unique←Parms,0
     :Else
         PathName PrefixString Unique←3↑Parms
     :EndSelect
 :Else
     PathName PrefixString Unique←Parms'' 0
 :EndIf
 :If 0∊⍴PrefixString
     PrefixString←'APL'
 :EndIf
 :If 0∊⍴PathName
 :AndIf 0∊⍴PathName←↑↑/##.GetTempPath ##.MAX_PATH ##.MAX_PATH
     #.RCode←##.GetLastError
     FileName←''
 :ElseIf 0=↑Unique FileName←##.GetTempFileName PathName PrefixString Unique ##.MAX_PATH
     #.RCode←##.GetLastError
     FileName←''
 :Else
     #.RCode←##.ERROR_SUCCESS
 :EndIf
∇

∇ PathName←GetTempPath
     ⍝ Retrieve path of directory designated for temporary files
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×↑⍴PathName←↑↑/##.GetTempPath ##.MAX_PATH ##.MAX_PATH
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Information←GetVolumeInformation RootPathName;VolumeName;VolumeSerialNumber;MaximumComponentLength;FileSystemFlags;FileSystemName;ValidFlag
     ⍝ Retreives all available information about a volume.
     ⍝ Information[1] = VolumeName
     ⍝ Information[2] = VolumeSerialNumber
     ⍝ Information[3] = MaximumComponentLength
     ⍝ Information[4] = FileSystemFlags: S=CaseSensitive P=CasePreserved U=Unicode A=ACLS F=FileCompression V=VolumeCompressed
     ⍝ Information[5] = FileSystemName   eg: FAT NTFS CDFS NWCompat
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 RootPathName←{⍵,((⊂⍵)∊'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',¨':')/'\'}RootPathName
 :If ↑ValidFlag VolumeName VolumeSerialNumber MaximumComponentLength FileSystemFlags FileSystemName←##.GetVolumeInformation RootPathName ##.MAX_PATH ##.MAX_PATH 0 0 0 ##.MAX_PATH ##.MAX_PATH
     #.RCode←##.ERROR_SUCCESS
     Information←VolumeName(('-','0123456789ABCDEF'[1+(8⍴16)⊤VolumeSerialNumber])[2 3 4 5 1 6 7 8 9])MaximumComponentLength(⌽(2 2048 2 2 2 2⊤FileSystemFlags)/'VFAUPS')FileSystemName
 :Else
     #.RCode←##.GetLastError
     Information←'' '0000-0000' 0 '' ''
 :EndIf
∇

∇ Buffer←Load FileName;hFile;FileSize;FileSizeLow;FileSizeHigh;NumberOfBytesRead;ValidFlag
     ⍝ Load a complete file as a character vector
     ⍝
     ⍝ On error Buffer is an empty character vector
     ⍝ and the #.RCode should be checked.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.INVALID_HANDLE_VALUE≠hFile←##.CreateFile FileName ##.GENERIC_READ(##.FILE_SHARE_READ+##.FILE_SHARE_WRITE)##.SECURITY_ATTRIBUTES ##.OPEN_EXISTING ##.FILE_ATTRIBUTE_NORMAL ##.NULL
     :If ##.INVALID_FILE_SIZE≠↑FileSizeLow FileSizeHigh←##.GetFileSize hFile 1
     :OrIf ##.ERROR_SUCCESS=#.RCode←##.GetLastError
         FileSize←⌊4294967296⊥FileSizeHigh(4294967296|FileSizeLow)
         :Trap 0
             :If ↑ValidFlag Buffer NumberOfBytesRead←##.ReadFileT hFile FileSize FileSize 1 ##.NULL
                 #.RCode←##.ERROR_SUCCESS
             :Else
                 #.RCode←##.GetLastError
                 Buffer←''
             :EndIf
         :Else
             #.RCode←##.ERROR_NOT_ENOUGH_MEMORY
             Buffer←''
         :EndTrap
     :Else
         Buffer←''
     :EndIf
     :If ##.CloseHandle hFile
     :ElseIf #.RCode=##.ERROR_SUCCESS
         #.RCode←##.GetLastError
         Buffer←''
     :EndIf
 :Else
     #.RCode←##.GetLastError
     Buffer←''
 :EndIf
∇

∇ {ValidFlag}←MediaEject Drive;hDevice;EAX;EBX;ECX;EDX;ESI;EDI;EFlags;RCode
     ⍝ Ejects a medium in the Drive.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 :Select 4⊃##.Sys.GetVersion
 :Case ##.VER_PLATFORM_WIN32_WINDOWS
     :If ValidFlag←(⊂Drive)∊⎕A,¨':'
         :If ValidFlag←##.INVALID_HANDLE_VALUE≠hDevice←DeviceOpen'VWIN32'
             EAX←256⊥68 13
             EBX←256⊥⎕A⍳↑Drive
             ECX←256⊥8 73
             EDX←0
             ESI←0
             EDI←0
             EFlags←2⊥1 0 0 1 0 0 0 1 1 0
             EBX EDX ECX EAX EDI ESI EFlags←EBX EDX ECX EAX EDI ESI EFlags DeviceIoControl hDevice ##.VWIN32_DIOC_DOS_IOCTL 7
             :If ValidFlag←#.RCode=##.ERROR_SUCCESS
                 :If ValidFlag←~2⊤EFlags
                     Close hDevice
                 :Else
                     #.RCode←(1 177 178 181⍳65536⊤EAX)⊃##.ERROR_INVALID_FUNCTION ##.ERROR_NOT_READY ##.ERROR_ACCESS_DENIED ##.ERROR_NOT_READY ##.ERROR_INVALID_FUNCTION
                     RCode←#.RCode ⋄ Close hDevice ⋄ #.RCode←RCode
                 :EndIf
             :Else
                 RCode←#.RCode ⋄ Close hDevice ⋄ #.RCode←RCode
             :EndIf
         :EndIf
     :Else
         #.RCode←##.ERROR_INVALID_DRIVE
     :EndIf
 :Case ##.VER_PLATFORM_WIN32_NT
     :If ValidFlag←##.INVALID_HANDLE_VALUE≠hDevice←DeviceOpen Drive
         :If ValidFlag←''≢⍬ DeviceIoControl hDevice ##.IOCTL_STORAGE_EJECT_MEDIA 0
             Close hDevice
         :Else
             RCode←#.RCode ⋄ Close hDevice ⋄ #.RCode←RCode
         :EndIf
     :EndIf
 :EndSelect
∇

∇ {ValidFlag}←MediaLoad Drive;hDevice;RCode
     ⍝ Loads a medium into the Drive (WinNT only).
     ⍝ ValidFlag = 0=Fail 1=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Select 4⊃##.Sys.GetVersion
 :Case ##.VER_PLATFORM_WIN32_WINDOWS
     #.RCode←##.ERROR_INVALID_FUNCTION
     ValidFlag←0
 :Case ##.VER_PLATFORM_WIN32_NT
     :If ValidFlag←##.INVALID_HANDLE_VALUE≠hDevice←DeviceOpen Drive
         :If ValidFlag←''≢⍬ DeviceIoControl hDevice ##.IOCTL_STORAGE_LOAD_MEDIA 0
             ValidFlag←Close hDevice
         :Else
             RCode←#.RCode ⋄ Close hDevice ⋄ #.RCode←RCode
         :EndIf
     :EndIf
 :EndSelect
∇

∇ {ValidFlag}←Move Parms;ExistingFileName;NewFileName;Flags
     ⍝ Renames an existing file or directory
     ⍝
     ⍝ Parms[1] = ExistingFileName
     ⍝ Parms[2] = NewFileName      Opt. at NT: Omit to delelet file when #.Win.MOVEFILE_DELAY_UNTIL_REBOOT is specified
     ⍝ Parms[3] = Flags            NT only:    #.Win.MOVEFILE_COPY_ALLOWED #.Win.MOVEFILE_CREATE_HARDLINK #.Win.MOVEFILE_DELAY_UNTIL_REBOOT #.Win.MOVEFILE_FAIL_IF_NOT_TRACKABLE #.Win.MOVEFILE_REPLACE_EXISTING #.Win.MOVEFILE_WRITE_THROUGH
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Select ↑⍴Parms
 :Case 2
     ExistingFileName NewFileName←Parms
     :If 82=⎕DR NewFileName
         :If 0>##.GetVersion ⍝ Win95
             :If ValidFlag←##.MoveFile ExistingFileName NewFileName
                 #.RCode←##.ERROR_SUCCESS
             :Else
                 #.RCode←##.GetLastError
             :EndIf
         :ElseIf ValidFlag←##.MoveFileEx ExistingFileName NewFileName ##.MOVEFILE_COPY_ALLOWED
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
         :EndIf
     :Else
         Flags←NewFileName
         :If ValidFlag←##.MoveFileExI ExistingFileName 0 Flags
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
         :EndIf
     :EndIf
 :Case 3
     ExistingFileName NewFileName Flags←Parms
     :If ValidFlag←##.MoveFileEx ExistingFileName NewFileName Flags
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     #.RCode←##.ERROR_INVALID_PARAMETER
     ValidFlag←0
 :EndSelect
∇

∇ hFile←{ReadWrite}Open FileName;DesiredAccess;ShareMode;CreationDistribution;FlagsAndAttributes
     ⍝ Opens a file for (default)Read(0 Y), Write(1 Y) or ReadWrite(2 Y) access,
     ⍝ permitting others to Read(X 0), Write(X 1) or (default)ReadWrite(X 2).
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×⎕NC'ReadWrite'
     :Select ↑ReadWrite
     :Case ##.OF_READ
         DesiredAccess←##.GENERIC_READ
         ShareMode←##.FILE_SHARE_READ+##.FILE_SHARE_WRITE
     :Case ##.OF_WRITE
         DesiredAccess←##.GENERIC_WRITE
         ShareMode←##.FILE_SHARE_READ
     :Case ##.OF_READWRITE
         DesiredAccess←##.GENERIC_READ+##.GENERIC_WRITE
         ShareMode←##.FILE_SHARE_READ
     :EndSelect
     :If 2=↑⍴ReadWrite
         :Select 2⊃ReadWrite
         :Case ##.OF_READ
             ShareMode←##.FILE_SHARE_READ
         :Case ##.OF_WRITE
             ShareMode←##.FILE_SHARE_WRITE
         :Case ##.OF_READWRITE
             ShareMode←##.FILE_SHARE_READ+##.FILE_SHARE_WRITE
         :EndSelect
     :EndIf
 :Else
     DesiredAccess←##.GENERIC_READ
     ShareMode←##.FILE_SHARE_READ+##.FILE_SHARE_WRITE
 :EndIf
 CreationDistribution←##.OPEN_EXISTING
 FlagsAndAttributes←##.FILE_ATTRIBUTE_NORMAL+##.FILE_FLAG_RANDOM_ACCESS ⍝ +##.FILE_FLAG_BACKUP_SEMANTICS
 :If ##.INVALID_HANDLE_VALUE≠hFile←##.CreateFile FileName DesiredAccess ShareMode ##.SECURITY_ATTRIBUTES CreationDistribution FlagsAndAttributes ##.NULL
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Buffer←Read Parms;hFile;Offset;NumberOfBytesToRead;Mode;Overlapped;ValidFlag;NumberOfBytesRead;OffsetLow;OffsetHigh
     ⍝ Read from an open file/device.
     ⍝ Parms[1] = hFile
     ⍝ Parms[2] = Mode: 82=Text 83=8-Bit-Integer 163=16-Bit-Integer 323=32-Bit-Integer 645=64-Bit-Real
     ⍝ Parms[3] = NumberOfBytesToRead
     ⍝ Parms[4] = Offset
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hFile Mode NumberOfBytesToRead Offset←4↑Parms
 OffsetHigh OffsetLow←4294967296 4294967296⊤Offset
 :If 0>##.GetVersion
     :If OffsetLow=↑##.SetFilePointer hFile OffsetLow OffsetHigh ##.FILE_BEGIN
         :Select Mode
         :Case 82
             :If ↑ValidFlag Buffer NumberOfBytesRead←##.ReadFileT hFile NumberOfBytesToRead NumberOfBytesToRead 1 0
                 #.RCode←##.ERROR_SUCCESS
                 Buffer←NumberOfBytesRead↑Buffer
             :Else
                 #.RCode←##.GetLastError
                 Buffer←''
             :EndIf
         :Case 83
             :If ↑ValidFlag Buffer NumberOfBytesRead←##.ReadFileI1 hFile NumberOfBytesToRead NumberOfBytesToRead 1 0
                 #.RCode←##.ERROR_SUCCESS
                 Buffer←NumberOfBytesRead↑Buffer
             :Else
                 #.RCode←##.GetLastError
                 Buffer←⍬
             :EndIf
         :Case 163
             :If ↑ValidFlag Buffer NumberOfBytesRead←##.ReadFileI2 hFile NumberOfBytesToRead(2×NumberOfBytesToRead)1 0
                 #.RCode←##.ERROR_SUCCESS
                 Buffer←(⌊0.5×NumberOfBytesRead)↑Buffer
             :Else
                 #.RCode←##.GetLastError
                 Buffer←⍬
             :EndIf
         :Case 323
             :If ↑ValidFlag Buffer NumberOfBytesRead←##.ReadFileI4 hFile NumberOfBytesToRead(4×NumberOfBytesToRead)1 0
                 #.RCode←##.ERROR_SUCCESS
                 Buffer←(⌊0.25×NumberOfBytesRead)↑Buffer
             :Else
                 #.RCode←##.GetLastError
                 Buffer←⍬
             :EndIf
         :Case 645
             :If ↑ValidFlag Buffer NumberOfBytesRead←##.ReadFileF8 hFile NumberOfBytesToRead(8×NumberOfBytesToRead)1 0
                 #.RCode←##.ERROR_SUCCESS
                 Buffer←(⌊0.125×NumberOfBytesRead)↑Buffer
             :Else
                 #.RCode←##.GetLastError
                 Buffer←⍬
             :EndIf
         :Else
             #.RCode←##.ERROR_INVALID_FUNCTION
             Buffer←''
         :EndSelect
     :Else
         #.RCode←##.GetLastError
         Buffer←''
     :EndIf
 :Else
     Overlapped←##.OVERLAPPED
     Overlapped[3 4]←OffsetLow OffsetHigh
     :Select Mode
     :Case 82
         :If ↑ValidFlag Buffer NumberOfBytesRead←##.ReadFileOverlappedT hFile NumberOfBytesToRead NumberOfBytesToRead 1 Overlapped
             #.RCode←##.ERROR_SUCCESS
             Buffer←NumberOfBytesRead↑Buffer
         :Else
             #.RCode←##.GetLastError
             Buffer←''
         :EndIf
     :Case 83
         :If ↑ValidFlag Buffer NumberOfBytesRead←##.ReadFileOverlappedI1 hFile NumberOfBytesToRead NumberOfBytesToRead 1 Overlapped
             #.RCode←##.ERROR_SUCCESS
             Buffer←NumberOfBytesRead↑Buffer
         :Else
             #.RCode←##.GetLastError
             Buffer←⍬
         :EndIf
     :Case 163
         :If ↑ValidFlag Buffer NumberOfBytesRead←##.ReadFileOverlappedI2 hFile NumberOfBytesToRead(2×NumberOfBytesToRead)1 Overlapped
             #.RCode←##.ERROR_SUCCESS
             Buffer←(⌊0.5×NumberOfBytesRead)↑Buffer
         :Else
             #.RCode←##.GetLastError
             Buffer←⍬
         :EndIf
     :Case 323
         :If ↑ValidFlag Buffer NumberOfBytesRead←##.ReadFileOverlappedI4 hFile NumberOfBytesToRead(4×NumberOfBytesToRead)1 Overlapped
             #.RCode←##.ERROR_SUCCESS
             Buffer←(⌊0.25×NumberOfBytesRead)↑Buffer
         :Else
             #.RCode←##.GetLastError
             Buffer←⍬
         :EndIf
     :Case 645
         :If ↑ValidFlag Buffer NumberOfBytesRead←##.ReadFileOverlappedF8 hFile NumberOfBytesToRead(8×NumberOfBytesToRead)1 Overlapped
             #.RCode←##.ERROR_SUCCESS
             Buffer←(⌊0.125×NumberOfBytesRead)↑Buffer
         :Else
             #.RCode←##.GetLastError
             Buffer←⍬
         :EndIf
     :Else
         #.RCode←##.ERROR_INVALID_FUNCTION
         Buffer←''
     :EndSelect
 :EndIf
∇

∇ {ValidFlag}←RemoveDirectory Parms;DirectoryName;RecursiveFlag;hFindFile;FindFileData;FileAttributes;CreationTime;LastAccessTime;LastWriteTime;FileSize;Reserved0;Reserved1;FileName;AlternateFileName;DirectoryAttribute;OtherAttributes;ReadonlyAttribute
     ⍝ Removes an existing directory.
     ⍝
     ⍝ Parms[1] = DirectoryName Name of the directory to remove
     ⍝ Parms[2] = RecursiveFlag (def=0) Additionaly delete all files in the directory and all subdirectories - USE WITH CARE
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     DirectoryName←,Parms
     RecursiveFlag←0
 :Else
     DirectoryName RecursiveFlag←2↑Parms
 :EndIf
 :If RecursiveFlag
     :If 0∊⍴DirectoryName
     :OrIf ':'=↑⌽DirectoryName
         DirectoryName,←'.\'
     :ElseIf '\'≠↑⌽DirectoryName
         DirectoryName,←'\'
     :EndIf
     :If ##.INVALID_HANDLE_VALUE≠↑hFindFile FindFileData←##.FindFirstFile(DirectoryName,'*')0
         :Repeat
             FileAttributes CreationTime LastAccessTime LastWriteTime FileSize Reserved0 Reserved1 FileName AlternateFileName←FindFileData
             FileName←{(¯1+⍵⍳↑⎕AV)↑⍵}FileName
             :If ValidFlag←(⊂FileName)∊(,'.')'..'
             :Else
                 FileName←DirectoryName,FileName
                 DirectoryAttribute OtherAttributes ReadonlyAttribute←2 8 2⊤FileAttributes
                 :If ValidFlag←~ReadonlyAttribute
                 :OrIf ValidFlag←##.SetFileAttributes FileName(FileAttributes-##.FILE_ATTRIBUTE_READONLY)
                     :If DirectoryAttribute
                         ValidFlag←RemoveDirectory FileName RecursiveFlag
                     :Else
                         ValidFlag←##.DeleteFile⊂FileName
                     :EndIf
                 :EndIf
             :EndIf
         :Until ~ValidFlag
         :OrIf ~↑ValidFlag FindFileData←##.FindNextFile hFindFile 0
         :If ValidFlag←##.ERROR_NO_MORE_FILES=#.RCode←##.GetLastError
             #.RCode←##.ERROR_SUCCESS
         :EndIf
         {}##.FindClose hFindFile
     :ElseIf ValidFlag←##.ERROR_FILE_NOT_FOUND=#.RCode←##.GetLastError
         #.RCode←##.ERROR_SUCCESS
     :EndIf
 :Else
     ValidFlag←1
 :EndIf
 :If ValidFlag
     :If ValidFlag←##.RemoveDirectory⊂DirectoryName
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :EndIf
∇

∇ {ValidFlag}←Buffer Save FileName;hFile;NumberOfBytesToWrite
     ⍝ Save a character vector directly into a file
     ⍝
     ⍝ On error 0 is returned, #.RCode should then be checked
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 1<≡Buffer
 :OrIf 1<⍴⍴Buffer
     #.RCode←##.ERROR_INVALID_DATA
     ValidFlag←0
 :ElseIf ##.INVALID_HANDLE_VALUE=hFile←##.CreateFile FileName ##.GENERIC_WRITE ##.FILE_SHARE_READ ##.SECURITY_ATTRIBUTES ##.CREATE_ALWAYS ##.FILE_ATTRIBUTE_NORMAL ##.NULL
     #.RCode←##.GetLastError
     ValidFlag←0
 :Else
     NumberOfBytesToWrite←↑⍴Buffer←##.IntTxt Buffer
     :If ValidFlag←1 NumberOfBytesToWrite≡##.WriteFileI1 hFile Buffer NumberOfBytesToWrite 1 0
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
     :If ##.CloseHandle hFile
     :ElseIf #.RCode=##.ERROR_SUCCESS
         #.RCode←##.GetLastError
         ValidFlag←0
     :EndIf
 :EndIf
∇

∇ Buffer←SearchPath FileName;BufferLength;Buffer;lpFilePart
     ⍝ Search for the specified file in ApplicationDirectory,CurrentDirectory,SystemDirectory,WindowsDirectory,%PATH%
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×↑⍴Buffer←↑↑/2↑BufferLength Buffer lpFilePart←##.SearchPathI 0 FileName 0 1024 1024 1
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {FileSize}←{FileSize}Size hFile;FileSizeLow;FileSizeHigh
     ⍝ Sets and/or Gets the size of the file referenced by hFile.
     ⍝ Returns ¯1 on error.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×⎕NC'FileSize'
 :AndIf 0≤FileSize
     FileSizeHigh FileSizeLow←4294967296 4294967296⊤FileSize
     :If ##.INVALID_FILE_SIZE=↑FileSizeLow FileSizeHigh←##.SetFilePointer hFile FileSizeLow FileSizeHigh ##.FILE_BEGIN
     :AndIf ##.ERROR_SUCCESS≠#.RCode←##.GetLastError
         FileSize←¯1
     :ElseIf ##.SetEndOfFile hFile
         #.RCode←##.ERROR_SUCCESS
         FileSize←⌊4294967296⊥FileSizeHigh(4294967296|FileSizeLow)
     :Else
         #.RCode←##.GetLastError
         FileSize←¯1
     :EndIf
 :ElseIf ##.INVALID_FILE_SIZE=↑FileSizeLow FileSizeHigh←##.GetFileSize hFile 1
 :AndIf ##.ERROR_SUCCESS≠#.RCode←##.GetLastError
     FileSize←¯1
 :Else
     #.RCode←##.ERROR_SUCCESS
     FileSize←⌊4294967296⊥FileSizeHigh(4294967296|FileSizeLow)
 :EndIf
∇

∇ {Times}←{Times}Time hFile;CreationTime;LastAccessTime;LastWriteTime;CreationFlag;LastAccessFlag;LastWriteFlag;ValidFlag
     ⍝ Sets and/or Gets the times of the file referenced by hFile.
     ⍝ Times[1] = Local CreationTime:   Year Month Day Hour Minute Second Milliseconds DayOfWeek
     ⍝ Times[2] = Local LastAccessTime: Year Month Day Hour Minute Second Milliseconds DayOfWeek
     ⍝ Times[3] = Local LastWriteTime:  Year Month Day Hour Minute Second Milliseconds DayOfWeek
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×⎕NC'Times'
     :If 2>≡Times
         Times←,⊂,Times
     :EndIf
     CreationTime LastAccessTime LastWriteTime←(⊂1 1 0 1 1 1 1 1)\¨7↑¨3↑Times,3⍴⊂7⍴0
     :If 1601 1 0 1 0 0 0 0∧.≤CreationTime
     :AndIf 2100 12 7 31 23 59 59 999∧.≥CreationTime
     :AndIf ↑ValidFlag CreationTime←##.SystemTimeToFileTime CreationTime 0
     :AndIf ↑ValidFlag CreationTime←##.LocalFileTimeToFileTime CreationTime 0
         CreationFlag←1
     :Else
         CreationFlag←0
     :EndIf
     :If 1601 1 0 1 0 0 0 0∧.≤LastAccessTime
     :AndIf 2100 12 7 31 23 59 59 999∧.≥LastAccessTime
     :AndIf ↑ValidFlag LastAccessTime←##.SystemTimeToFileTime LastAccessTime 0
     :AndIf ↑ValidFlag LastAccessTime←##.LocalFileTimeToFileTime LastAccessTime 0
         LastAccessFlag←1
     :Else
         LastAccessFlag←0
     :EndIf
     :If 1601 1 0 1 0 0 0 0∧.≤LastWriteTime
     :AndIf 2100 12 7 31 23 59 59 999∧.≥LastWriteTime
     :AndIf ↑ValidFlag LastWriteTime←##.SystemTimeToFileTime LastWriteTime 0
     :AndIf ↑ValidFlag LastWriteTime←##.LocalFileTimeToFileTime LastWriteTime 0
         LastWriteFlag←1
     :Else
         LastWriteFlag←0
     :EndIf
     :If CreationFlag
         :If LastAccessFlag
             :If LastWriteFlag
                 ValidFlag←##.SetFileTimeCAW hFile CreationTime LastAccessTime LastWriteTime
             :Else
                 ValidFlag←##.SetFileTimeCA hFile CreationTime LastAccessTime 0
             :EndIf
         :Else
             :If LastWriteFlag
                 ValidFlag←##.SetFileTimeCW hFile CreationTime 0 LastWriteTime
             :Else
                 ValidFlag←##.SetFileTimeC hFile CreationTime 0 0
             :EndIf
         :EndIf
     :Else
         :If LastAccessFlag
             :If LastWriteFlag
                 ValidFlag←##.SetFileTimeAW hFile 0 LastAccessTime LastWriteTime
             :Else
                 ValidFlag←##.SetFileTimeA hFile 0 LastAccessTime 0
             :EndIf
         :Else
             :If LastWriteFlag
                 ValidFlag←##.SetFileTimeW hFile 0 0 LastWriteTime
             :Else
                 ValidFlag←1
             :EndIf
         :EndIf
     :EndIf
     :If ValidFlag
     :AndIf ↑ValidFlag CreationTime LastAccessTime LastWriteTime←##.GetFileTime hFile 1 1 1
         Times←{⍵[1 2 4 5 6 7 8 3]}¨2⊃¨##.FileTimeToSystemTime¨(1↓¨##.FileTimeToLocalFileTime¨(⊂¨CreationTime LastAccessTime LastWriteTime),¨0),¨0
     :Else
         #.RCode←##.GetLastError
         Times←3⍴⊂8⍴0
     :EndIf
 :ElseIf ↑ValidFlag CreationTime LastAccessTime LastWriteTime←##.GetFileTime hFile 1 1 1
     Times←{⍵[1 2 4 5 6 7 8 3]}¨2⊃¨##.FileTimeToSystemTime¨(1↓¨##.FileTimeToLocalFileTime¨(⊂¨CreationTime LastAccessTime LastWriteTime),¨0),¨0
 :Else
     #.RCode←##.GetLastError
     Times←3⍴⊂8⍴0
 :EndIf
∇

∇ {Offset}←Buffer Write Parms;hFile;Mode;NumberOfBytesToWrite;Overlapped;ValidFlag;NumberOfBytesWritten;OffsetLow;OffsetHigh
     ⍝ Writes to an open file/device.
     ⍝ Parms[1] = hFile
     ⍝ Parms[2] = Offset in Bytes
     ⍝ Parms[3] = Mode: 82=Text 83=8-Bit-Integer 163=16-Bit-Integer 323=32-Bit-Integer 645=64-Bit-Real or 0(default)=Buffer's Data Type
     ⍝ Offset   = New Offset for sequential write
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hFile Offset Mode←3↑Parms
 OffsetHigh OffsetLow←4294967296 4294967296⊤Offset
 :If 0=Mode
     Mode←⎕DR Buffer
 :EndIf
 :If 0>##.GetVersion
     :If OffsetLow=↑##.SetFilePointer hFile OffsetLow OffsetHigh ##.FILE_BEGIN
         :Select Mode
         :Case 82
             NumberOfBytesToWrite←↑⍴Buffer←##.IntTxt Buffer
             :If ↑ValidFlag NumberOfBytesWritten←##.WriteFileI1 hFile Buffer NumberOfBytesToWrite 1 0
                 #.RCode←##.ERROR_SUCCESS
                 Offset+←NumberOfBytesWritten
             :Else
                 #.RCode←##.GetLastError
                 Offset←¯1
             :EndIf
         :Case 83
             NumberOfBytesToWrite←↑⍴Buffer←,Buffer
             :If ↑ValidFlag NumberOfBytesWritten←##.WriteFileI1 hFile Buffer NumberOfBytesToWrite 1 0
                 #.RCode←##.ERROR_SUCCESS
                 Offset+←NumberOfBytesWritten
             :Else
                 #.RCode←##.GetLastError
                 Offset←¯1
             :EndIf
         :Case 163
             NumberOfBytesToWrite←2×↑⍴Buffer←,Buffer
             :If ↑ValidFlag NumberOfBytesWritten←##.WriteFileI2 hFile Buffer NumberOfBytesToWrite 1 0
                 #.RCode←##.ERROR_SUCCESS
                 Offset+←NumberOfBytesWritten
             :Else
                 #.RCode←##.GetLastError
                 Offset←¯1
             :EndIf
         :Case 323
             NumberOfBytesToWrite←4×↑⍴Buffer←,Buffer
             :If ↑ValidFlag NumberOfBytesWritten←##.WriteFileI4 hFile Buffer NumberOfBytesToWrite 1 0
                 #.RCode←##.ERROR_SUCCESS
                 Offset+←NumberOfBytesWritten
             :Else
                 #.RCode←##.GetLastError
                 Offset←¯1
             :EndIf
         :Case 645
             NumberOfBytesToWrite←8×↑⍴Buffer←,Buffer
             :If ↑ValidFlag NumberOfBytesWritten←##.WriteFileF8 hFile Buffer NumberOfBytesToWrite 1 0
                 #.RCode←##.ERROR_SUCCESS
                 Offset+←NumberOfBytesWritten
             :Else
                 #.RCode←##.GetLastError
                 Offset←¯1
             :EndIf
         :Else
             #.RCode←##.ERROR_INVALID_FUNCTION
             Offset←¯1
         :EndSelect
     :Else
         #.RCode←##.GetLastError
         Buffer←''
     :EndIf
 :Else
     Overlapped←##.OVERLAPPED
     Overlapped[3 4]←OffsetLow OffsetHigh
     :Select Mode
     :Case 82
         NumberOfBytesToWrite←↑⍴Buffer←##.IntTxt Buffer
         :If ↑ValidFlag NumberOfBytesWritten←##.WriteFileOverlappedI1 hFile Buffer NumberOfBytesToWrite 1 Overlapped
             #.RCode←##.ERROR_SUCCESS
             Offset+←NumberOfBytesWritten
         :Else
             #.RCode←##.GetLastError
             Offset←¯1
         :EndIf
     :Case 83
         NumberOfBytesToWrite←↑⍴Buffer←,Buffer
         :If ↑ValidFlag NumberOfBytesWritten←##.WriteFileOverlappedI1 hFile Buffer NumberOfBytesToWrite 1 Overlapped
             #.RCode←##.ERROR_SUCCESS
             Offset+←NumberOfBytesWritten
         :Else
             #.RCode←##.GetLastError
             Offset←¯1
         :EndIf
     :Case 163
         NumberOfBytesToWrite←2×↑⍴Buffer←,Buffer
         :If ↑ValidFlag NumberOfBytesWritten←##.WriteFileOverlappedI2 hFile Buffer NumberOfBytesToWrite 1 Overlapped
             #.RCode←##.ERROR_SUCCESS
             Offset+←NumberOfBytesWritten
         :Else
             #.RCode←##.GetLastError
             Offset←¯1
         :EndIf
     :Case 323
         NumberOfBytesToWrite←4×↑⍴Buffer←,Buffer
         :If ↑ValidFlag NumberOfBytesWritten←##.WriteFileOverlappedI4 hFile Buffer NumberOfBytesToWrite 1 Overlapped
             #.RCode←##.ERROR_SUCCESS
             Offset+←NumberOfBytesWritten
         :Else
             #.RCode←##.GetLastError
             Offset←¯1
         :EndIf
     :Case 645
         NumberOfBytesToWrite←8×↑⍴Buffer←,Buffer
         :If ↑ValidFlag NumberOfBytesWritten←##.WriteFileOverlappedF8 hFile Buffer NumberOfBytesToWrite 1 Overlapped
             #.RCode←##.ERROR_SUCCESS
             Offset+←NumberOfBytesWritten
         :Else
             #.RCode←##.GetLastError
             Offset←¯1
         :EndIf
     :Else
         #.RCode←##.ERROR_INVALID_FUNCTION
         Offset←¯1
     :EndSelect
 :EndIf
∇

:Namespace Attachment
⎕IO ⎕ML ⎕WX ⎕CT←1 3 1 9.999999999999998E¯15

∇ Offset←Alloc Parms;EndOfData;EndOfFile;hFile;Name;NameSize;Data;DataSize;AllocSize;FileSize;FirstTime;Offsets
     ⍝ Allocates a memory area in the attachment area of an open file.
     ⍝
     ⍝ Parms[1] = hFile
     ⍝ Parms[2] = Name or (Name1 Name2 .. NameN)                         : Name of DataAllocation(s)
     ⍝ Parms[3] = Data(Size) or (Data(Size)1 Data(Size)2 .. Data(Size)N) : (Size of) DataAllocation(s)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 hFile Name Data←3↑Parms
 EndOfData←1706509    ⍝ String CR,LF,CtrlZ,NULL
 EndOfFile←1181697316 ⍝ String '$EoF'
 :If 0≤FileSize←##.Size hFile
 :AndIf 0≤Offset←FileSize-8
 :AndIf EndOfData EndOfFile≡##.Read hFile 323 2 Offset
     FirstTime←0
     :While 0<Offset
         :If 0≤Offset←Offset-8
         :AndIf 2=↑⍴AllocSize NameSize←##.Read hFile 323 2 Offset
         :AndIf 0∧.≤AllocSize NameSize
         :AndIf 0≤Offset←Offset-4+NameSize
         :AndIf EndOfData=↑##.Read hFile 323 1 Offset
         :AndIf 0≤Offset←Offset-AllocSize
         :ElseIf #.RCode=##.##.ERROR_SUCCESS
             FirstTime←1
             :Leave
         :Else
             Offset←¯1
             :Return
         :EndIf
     :EndWhile
 :ElseIf #.RCode=##.##.ERROR_SUCCESS
     FirstTime←1
 :Else
     Offset←¯1
     :Return
 :EndIf
 :If FirstTime
     :If 0≤FileSize
     :AndIf 0>EndOfData FileSize 0 ##.Write hFile FileSize 323
         Offset←¯1
         :Return
     :EndIf
     Offset←12+FileSize
 :Else
     Offset←FileSize-8
     :If 0>0 0 ##.Write hFile Offset 323
         Offset←¯1
         :Return
     :EndIf
 :EndIf
 :If 2>≡Name
     NameSize←↑⍴Name
     :Select ⎕DR Data
     :Case 82
         DataSize←↑⍴Data
         :If 0>(Data,(4 ##.##.TxtInt EndOfData),Name,4 ##.##.TxtInt DataSize NameSize EndOfData EndOfFile)##.Write hFile Offset 82
             Offset←¯1
         :EndIf
     :CaseList 11 83 163 323 645
         :If 0>DataSize←↑Data
         :OrIf 0>((4 ##.##.TxtInt EndOfData),Name,4 ##.##.TxtInt DataSize NameSize EndOfData EndOfFile)##.Write hFile(Offset+DataSize)82
             Offset←¯1
         :EndIf
     :Else
         Offset←¯1
     :EndSelect
 :Else
     Offsets←⍬
     :For Name Data :In ⊂[1]⊃Name Data
         NameSize←↑⍴Name
         Offsets,←Offset
         :Select ⎕DR Data
         :Case 82
             DataSize←↑⍴Data
             :If 0>Offset←(Data,(4 ##.##.TxtInt EndOfData),Name,4 ##.##.TxtInt DataSize NameSize)##.Write hFile Offset 82
                 :Return
             :EndIf
         :CaseList 11 83 163 323 645
             :If 0>DataSize←↑Data
             :OrIf 0>Offset←((4 ##.##.TxtInt EndOfData),Name,4 ##.##.TxtInt DataSize NameSize)##.Write hFile(Offset+DataSize)82
                 :Return
             :EndIf
         :Else
             Offset←¯1
             :Return
         :EndSelect
     :EndFor
     :If 0>EndOfData EndOfFile ##.Write hFile Offset 323
         Offset←¯1
     :Else
         Offset←Offsets
     :EndIf
 :EndIf
∇

∇ List←List hFile;EndOfData;EndOfFile;Name;DataSize;NameSize;FileSize;Offset
     ⍝ Lists all allocationes applied to the attachment area of an open file.
     ⍝ List[;1] = Name
     ⍝ List[;2] = DataSize
     ⍝ List[;3] = Offset
     ⍝
     ⍝ FileFormat: Data1,EndOfData,''   ,DataSize1,0        ,
     ⍝             Data2,EndOfData,Name2,DataSize2,NameSize2,
     ⍝             DataN,EndOfData,NameN,DataSizeN,NameSizeN,
     ⍝             EndOfData,EndOfFile
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 EndOfData←1706509    ⍝ String CR,LF,CtrlZ,NULL
 EndOfFile←1181697316 ⍝ String '$EoF'
 :If 0≤FileSize←##.Size hFile
 :AndIf 0≤Offset←FileSize-8
 :AndIf EndOfData EndOfFile≡##.Read hFile 323 2 Offset
     List←0 3⍴'' 0 0
     :While 0<Offset
         :If 0≤Offset←Offset-8
         :AndIf 2=↑⍴DataSize NameSize←##.Read hFile 323 2 Offset
         :AndIf 0∧.≤DataSize NameSize
         :AndIf 0≤Offset←Offset-NameSize
         :AndIf NameSize=↑⍴Name←##.Read hFile 82 NameSize Offset
         :AndIf 0≤Offset←Offset-4
         :AndIf EndOfData=↑##.Read hFile 323 1 Offset
         :AndIf 0≤Offset←Offset-DataSize
             List⍪←Name DataSize Offset
         :ElseIf #.RCode=##.##.ERROR_SUCCESS
             List←1 3⍴''FileSize 0
             Offset←0
         :Else
             List←0 3⍴'' 0 0
             Offset←0
         :EndIf
     :EndWhile
     List←⊖List
 :ElseIf #.RCode=##.##.ERROR_SUCCESS
     List←1 3⍴''FileSize 0
 :Else
     List←0 3⍴'' 0 0
 :EndIf
∇

:EndNamespace 
:Namespace Mapping
⎕IO ⎕ML ⎕WX ⎕CT←1 3 1 9.999999999999998E¯15

∇ {VOID}←Close hObject
     ⍝ Closes an open handle to an object such as a file mapping object handle.
     ⍝ VOID = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If ##.##.NULL=hObject
     #.RCode←##.##.ERROR_SUCCESS
     VOID←0
 :ElseIf ##.##.TRUE=##.##.CloseHandle hObject
     #.RCode←##.##.ERROR_SUCCESS
     VOID←0
 :Else
     #.RCode←##.##.GetLastError
     VOID←1
 :EndIf
∇

∇ hFileMappingObject←Create Parms;hFile;ProtectFlags;MaximumSize;MaximumSizeHigh;MaximumSizeLow;MappingName
     ⍝ Create or open a file and return a handle for access
     ⍝
     ⍝ Parms[1] = MappingName  (required)    Any string without "\"
     ⍝ Parms[2] = MaximumSize  (def 0*)      Maximum size of the file-mapping object, 0=CurrentSize, defaults to 256KB if hFile=#.Win.INVALID_HANDLE_VALUE
     ⍝ Parms[3] = hFile        (def invalid) Handle to file from which to create a mapping object, or #.Win.INVALID_HANDLE_VALUE
     ⍝ Parms[4] = ProtectFlags (def RW)      #.Win.PAGE_READONLY #.Win.PAGE_READWRITE or #.Win.PAGE_WRITECOPY, +#.Win.SEC_COMMIT+#.Win.SEC_IMAGE+#.Win.SEC_NOCACHE+#.Win.SEC_RESERVE
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 2>≡Parms
     Parms←,⊂Parms
 :EndIf
 :Select ↑⍴Parms
 :CaseList 0 1
     MappingName←↑Parms
     MaximumSize hFile ProtectFlags←262144 ##.##.INVALID_HANDLE_VALUE ##.##.PAGE_READWRITE
 :Case 2
     MappingName MaximumSize←Parms
     hFile ProtectFlags←##.##.INVALID_HANDLE_VALUE ##.##.PAGE_READWRITE
 :Case 3
     MappingName MaximumSize hFile←Parms
     ProtectFlags←##.##.PAGE_READWRITE
 :Else
     MappingName MaximumSize hFile ProtectFlags←4↑Parms
 :EndSelect
 MaximumSizeHigh MaximumSizeLow←4294967296 4294967296⊤MaximumSize
 :If ##.##.NULL≠hFileMappingObject←##.##.CreateFileMapping hFile ##.##.SECURITY_ATTRIBUTES ProtectFlags MaximumSizeHigh MaximumSizeLow MappingName
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
     hFileMappingObject←##.##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ Buffer←Load MappingName;hFileMappingObject;pBaseAddress;BufferSize
     ⍝ Load mapped memory as a character vector
     ⍝
     ⍝ MappingName        = Name of the mapping (Any string without "\")
     ⍝ Buffer             = Character Vector to load mapped memory into
     ⍝
     ⍝ On error Buffer is an empty character vector
     ⍝ and the #.RCode should be checked.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If ##.##.NULL≠hFileMappingObject←##.##.OpenFileMapping ##.##.FILE_MAP_READ ##.##.FALSE MappingName
     :If ##.##.NULL≠pBaseAddress←##.##.MapViewOfFile hFileMappingObject ##.##.FILE_MAP_READ 0 0 0
         :If 0<BufferSize←##.##.RtlMoveMemoryRI 1 pBaseAddress 4
             Buffer←##.##.RtlMoveMemoryR BufferSize(pBaseAddress+4)BufferSize
         :Else
             Buffer←''
         :EndIf
     :AndIf ##.##.UnmapViewOfFile pBaseAddress
         #.RCode←##.##.ERROR_SUCCESS
     :ElseIf
         #.RCode←##.##.GetLastError
     :EndIf
     :If ##.##.CloseHandle hFileMappingObject
     :ElseIf RCode=##.##.ERROR_SUCCESS
         #.RCode←##.##.GetLastError
         Buffer←''
     :EndIf
 :Else
     #.RCode←##.##.GetLastError
     Buffer←''
 :EndIf
∇

∇ pBaseAddress←Map Parms;hFileMappingObject;DesiredAccess;NumberOfBytesToMap;FileOffset;FileOffsetHigh;FileOffsetLow
     ⍝ Map a view of a file into the address space of the calling process
     ⍝
     ⍝ Parms[1] = hFileMappingObject Required
     ⍝ Parms[2] = DesiredAccess      (def all) #.Win.FILE_MAP_COPY #.Win.FILE_MAP_WRITE #.Win.FILE_MAP_READ or #.Win.FILE_MAP_ALL_ACCESS
     ⍝ Parms[3] = FileOffset         (def 0)
     ⍝ Parms[4] = NumberOfBytesToMap (def 0)   0=all
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 2>↑⍴Parms
     hFileMappingObject←↑Parms
     DesiredAccess FileOffsetHigh FileOffsetLow NumberOfBytesToMap←##.##.FILE_MAP_ALL_ACCESS 0 0 0
 :Else
     hFileMappingObject DesiredAccess FileOffset NumberOfBytesToMap←4↑Parms
     FileOffsetHigh FileOffsetLow←4294967296 4294967296⊤FileOffset
 :EndIf
 :If ##.##.NULL≠pBaseAddress←##.##.MapViewOfFile hFileMappingObject DesiredAccess FileOffsetHigh FileOffsetLow NumberOfBytesToMap
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

∇ hFileMappingObject←Open Parms;DesiredAccess;InheritHandle;MappingName
     ⍝ Open a named file-mapping object
     ⍝
     ⍝ Parms[1] = MappingName   (required) Any string without "\"
     ⍝ Parms[2] = DesiredAccess (def all)  #.Win.FILE_MAP_COPY #.Win.FILE_MAP_WRITE #.Win.FILE_MAP_READ or #.Win.FILE_MAP_ALL_ACCESS
     ⍝ Parms[3] = InheritHandle (def TRUE) Flag, defines whether hFileMappingObject is inherited by new processes
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 1<≡Parms
     :Select ↑⍴Parms
     :CaseList 0 1
         MappingName←↑Parms
         DesiredAccess InheritHandle←##.##.FILE_MAP_ALL_ACCESS ##.##.TRUE
     :Case 2
         MappingName DesiredAccess←Parms
         InheritHandle←##.##.TRUE
     :Else
         MappingName DesiredAccess InheritHandle←3↑Parms
     :EndSelect
 :Else
     MappingName←Parms
     DesiredAccess InheritHandle←##.##.FILE_MAP_ALL_ACCESS ##.##.TRUE
 :EndIf
 :If ##.##.NULL≠hFileMappingObject←##.##.OpenFileMapping DesiredAccess InheritHandle MappingName
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
     hFileMappingObject←##.##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ {hFileMappingObject}←Buffer Save Parms;MaximumSize;MappingName;BufferSize;CreateFlag;pBaseAddress;ValidFlag
     ⍝ Save a character vector directly into mapped memory
     ⍝
     ⍝ Parms[1]           = MappingName  (required)       Name of the mapping (Any string without "\")
     ⍝ Parms[2]           = MaximumSize  (def BufferSize) Maximum size of the file-mapping object (ignored if MappingName already exists)
     ⍝ Buffer             = Character Vector to save to mapped memory
     ⍝
     ⍝ hFileMappingObject = Handle to the mapping, 0 if MappingName already exists, upon "#.Win.File.Mapping.Close hFileMappingObject" mapping gets destroyed
     ⍝
     ⍝ On error #.Win.INVALID_HANDLE_VALUE is returned, #.RCode #.RText should then be checked
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 2>≡Parms
     Parms←,⊂Parms
 :EndIf
 :If 1<≡Buffer
 :OrIf 1<⍴⍴Buffer
     #.RCode←##.##.ERROR_INVALID_DATA
     hFileMappingObject←##.##.INVALID_HANDLE_VALUE
 :Else
     MappingName←↑Parms
     BufferSize←↑⍴Buffer←##.##.IntTxt Buffer
     MaximumSize←BufferSize⌈2⊃Parms,0
     
     :If CreateFlag←##.##.NULL=hFileMappingObject←##.##.OpenFileMapping ##.##.FILE_MAP_ALL_ACCESS ##.##.FALSE MappingName
     :AndIf ##.##.NULL=hFileMappingObject←##.##.CreateFileMapping ##.##.INVALID_HANDLE_VALUE ##.##.SECURITY_ATTRIBUTES ##.##.PAGE_READWRITE 0(4+MaximumSize)MappingName
         #.RCode←##.##.GetLastError
         hFileMappingObject←##.##.INVALID_HANDLE_VALUE
     :ElseIf ##.##.NULL≠pBaseAddress←##.##.MapViewOfFile hFileMappingObject ##.##.FILE_MAP_ALL_ACCESS 0 0(4+BufferSize)
         ValidFlag←##.##.RtlMoveMemoryWI pBaseAddress BufferSize 4
         ValidFlag←##.##.RtlMoveMemoryW(pBaseAddress+4)Buffer BufferSize
     :AndIf ValidFlag←##.##.UnmapViewOfFile pBaseAddress
         :If ~CreateFlag
             ValidFlag←##.##.CloseHandle hFileMappingObject
             hFileMappingObject←##.##.NULL
         :EndIf
         #.RCode←##.##.ERROR_SUCCESS
     :Else
         #.RCode←##.##.GetLastError
         ValidFlag←##.##.CloseHandle hFileMappingObject
         hFileMappingObject←##.##.INVALID_HANDLE_VALUE
     :EndIf
 :EndIf
∇

∇ ValidFlag←Unmap pBaseAddress
     ⍝ Unmap a mapped view of a file from the calling process's address space
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If ValidFlag←##.##.UnmapViewOfFile pBaseAddress
     #.RCode←##.##.ERROR_SUCCESS
 :Else
     #.RCode←##.##.GetLastError
 :EndIf
∇

:EndNamespace 
:Namespace VWin32
⎕IO ⎕ML ⎕WX ⎕CT←1 3 1 9.999999999999998E¯15

∇ {VOID}←Format Parms;hMem;hDevice;Drive;Cylinder;Head;Sector;Mode;EAX;EBX;ECX;EDX;ESI;EDI;EFlags;R
     ⍝ Win95 only: Formats a drive
     ⍝ Parms[1] = hDevice of VWin32.VxD
     ⍝ Parms[2] = Drive
     ⍝ VOID = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 hDevice Drive←2↑Parms
 Mode←8
 EAX←256⊥Mode 0
 EBX←0
 ECX←0
 EDX←256⊥Drive
 ESI←0
 EDI←0
 EFlags←2⊥1 0 0 1 0 0 0 1 1 0
 EBX EDX ECX EAX EDI ESI EFlags←EBX EDX ECX EAX EDI ESI EFlags ##.DeviceIoControl hDevice ##.##.VWIN32_DIOC_DOS_INT13 7
 :If #.RCode≠##.##.ERROR_SUCCESS
     VOID←1
 :ElseIf 2⊤EFlags
     #.RCode←(1 2 3 4 8 16 64 128⍳↑256 256⊤EAX)⊃##.##.ERROR_BAD_COMMAND ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_WRITE_PROTECT ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_NOT_READY ##.##.ERROR_CRC ##.##.ERROR_SEEK ##.##.ERROR_NOT_READY ##.##.ERROR_GEN_FAILURE
     VOID←1
 :Else
     Cylinder Sector←256 256⊤ECX
     Head←↑256 256⊤EDX
     Cylinder Head Sector←79 1 18⌊Cylinder Head Sector
     Mode←24
     EAX←256⊥Mode 0
     EBX←0
     ECX←256 4 64⊥Cylinder 0 Sector
     EDX←256⊥Head Drive
     ESI←0
     EDI←0
     EFlags←2⊥1 0 0 1 0 0 0 1 1 0
     EBX EDX ECX EAX EDI ESI EFlags←EBX EDX ECX EAX EDI ESI EFlags ##.DeviceIoControl hDevice ##.##.VWIN32_DIOC_DOS_INT13 7
     :If #.RCode≠##.##.ERROR_SUCCESS
         VOID←1
     :ElseIf 2⊤EFlags
         #.RCode←(1 2 3 4 8 16 64 128⍳↑256 256⊤EAX)⊃##.##.ERROR_BAD_COMMAND ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_WRITE_PROTECT ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_NOT_READY ##.##.ERROR_CRC ##.##.ERROR_SEEK ##.##.ERROR_NOT_READY ##.##.ERROR_GEN_FAILURE
         VOID←1
     :Else
         Mode←5
         :For Cylinder Head :In ¯1+⍳1+Cylinder Head
             :If 0=hMem←##.##.Mem.Alloc(512×Sector)↑4 ##.##.TxtInt 256⊥⊃[1]2,¨(⍳Sector),¨⊂Head Cylinder
                 VOID←1
                 :Return
             :Else
                 EAX←256⊥Mode Sector
                 EBX←hMem
                 ECX←256 4 64⊥Cylinder 0 0
                 EDX←256⊥Head Drive
                 ESI←0
                 EDI←0
                 EFlags←2⊥1 0 0 1 0 0 0 1 1 0
                 EBX EDX ECX EAX EDI ESI EFlags←EBX EDX ECX EAX EDI ESI EFlags ##.DeviceIoControl hDevice ##.##.VWIN32_DIOC_DOS_INT13 7
                 :If #.RCode≠##.##.ERROR_SUCCESS
                     R←#.RCode
                     VOID←##.##.Mem.Free hMem
                     #.RCode←R
                     VOID←1
                     :Return
                 :ElseIf 2⊤EFlags
                     VOID←##.##.Mem.Free hMem
                     #.RCode←(1 2 3 4 8 16 64 128⍳↑256 256⊤EAX)⊃##.##.ERROR_BAD_COMMAND ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_WRITE_PROTECT ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_NOT_READY ##.##.ERROR_CRC ##.##.ERROR_SEEK ##.##.ERROR_NOT_READY ##.##.ERROR_GEN_FAILURE
                     VOID←1
                     :Return
                 :Else
                     VOID←##.##.Mem.Free hMem
                 :EndIf
             :EndIf
         :EndFor
         Mode←0
         EAX←256⊥Mode 0
         EBX←0
         ECX←0
         EDX←256⊥Drive
         ESI←0
         EDI←0
         EFlags←2⊥1 0 0 1 0 0 0 1 1 0
         EBX EDX ECX EAX EDI ESI EFlags←EBX EDX ECX EAX EDI ESI EFlags ##.DeviceIoControl hDevice ##.##.VWIN32_DIOC_DOS_INT13 7
         :If #.RCode≠##.##.ERROR_SUCCESS
             VOID←1
         :ElseIf 2⊤EFlags
             #.RCode←(1 2 3 4 8 16 64 128⍳↑256 256⊤EAX)⊃##.##.ERROR_BAD_COMMAND ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_WRITE_PROTECT ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_NOT_READY ##.##.ERROR_CRC ##.##.ERROR_SEEK ##.##.ERROR_NOT_READY ##.##.ERROR_GEN_FAILURE
             VOID←1
         :Else
             VOID←0
         :EndIf
     :EndIf
 :EndIf
∇

∇ Data←GetType Parms;hDevice;Drive;Cylinder;Head;Sector;Mode;EAX;EBX;ECX;EDX;ESI;EDI;EFlags
     ⍝ Win95 only: Gets default characteristics of the drive
     ⍝ Parms[1] = hDevice of VWin32.VxD
     ⍝ Parms[2] = Drive
     ⍝ Data[1]  = Cylinder
     ⍝ Data[2]  = Head
     ⍝ Data[3]  = Sector
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 hDevice Drive←2↑Parms
 Mode←8
 EAX←256⊥Mode 0
 EBX←0
 ECX←0
 EDX←256⊥Drive
 ESI←0
 EDI←0
 EFlags←2⊥1 0 0 1 0 0 0 1 1 0
 EBX EDX ECX EAX EDI ESI EFlags←EBX EDX ECX EAX EDI ESI EFlags ##.DeviceIoControl hDevice ##.##.VWIN32_DIOC_DOS_INT13 7
 :If #.RCode≠##.##.ERROR_SUCCESS
     Data←0 0 0
 :ElseIf 2⊤EFlags
     #.RCode←(1 2 3 4 8 16 64 128⍳↑256 256⊤EAX)⊃##.##.ERROR_BAD_COMMAND ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_WRITE_PROTECT ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_NOT_READY ##.##.ERROR_CRC ##.##.ERROR_SEEK ##.##.ERROR_NOT_READY ##.##.ERROR_GEN_FAILURE
     Data←0 0 0
 :Else
     Cylinder Sector←256 256⊤ECX
     Head←↑256 256⊤EDX
     Data←Cylinder Head Sector
 :EndIf
∇

∇ Data←Read Parms;hMem;hDevice;Drive;Offset;Count;Cylinder;Head;Sector;Sectors;Mode;EAX;EBX;ECX;EDX;ESI;EDI;EFlags;R
     ⍝ Win95 only: Reads from a device
     ⍝ Parms[1] = hDevice of VWin32.VxD
     ⍝ Parms[2] = Drive
     ⍝ Parms[3] = Offset in sectors
     ⍝ Parms[4] = Count in sectors
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 hDevice Drive Offset Count←4↑Parms
 Mode←8
 EAX←256⊥Mode 0
 EBX←0
 ECX←0
 EDX←256⊥Drive
 ESI←0
 EDI←0
 EFlags←2⊥1 0 0 1 0 0 0 1 1 0
 EBX EDX ECX EAX EDI ESI EFlags←EBX EDX ECX EAX EDI ESI EFlags ##.DeviceIoControl hDevice ##.##.VWIN32_DIOC_DOS_INT13 7
 :If #.RCode≠##.##.ERROR_SUCCESS
     Data←''
 :ElseIf 2⊤EFlags
     #.RCode←(1 2 3 4 8 16 64 128⍳↑256 256⊤EAX)⊃##.##.ERROR_BAD_COMMAND ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_WRITE_PROTECT ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_NOT_READY ##.##.ERROR_CRC ##.##.ERROR_SEEK ##.##.ERROR_NOT_READY ##.##.ERROR_GEN_FAILURE
     Data←''
 :Else
     Cylinder Sector←256 256⊤ECX
     Head←↑256 256⊤EDX
     Cylinder Head Sector←79 1 18⌊Cylinder Head Sector
     Mode←2
     Data←''
     :For Cylinder Head Sector Sectors :In Cylinder Head Sector{(0 0 1∘+¨↓[1](1 1 0+⍺)⊤A/B),¨C-0,¯1↓C←{⍵/⍳⍴⍵}1⌽A←↑{×↑⍴⍵:,/⍵ ⋄ ⊂⍬}(↑∘⍴¨(1+A)⊂A←0=⍺[3]|B←(¯1+↑⍵)+⍳2⊃⍵)⍴¨⊂8↑1}Offset Count
         :If 0=hMem←##.##.Mem.Alloc(512×Sectors)⍴↑⎕AV
             Data←''
             :Return
         :Else
             EAX←256 256⊥Mode Sectors
             EBX←hMem
             ECX←256 4 64⊥Cylinder 3 Sector
             EDX←256 256⊥Head Drive
             ESI←0
             EDI←0
             EFlags←2⊥1 0 0 1 0 0 0 1 1 0
             EBX EDX ECX EAX EDI ESI EFlags←EBX EDX ECX EAX EDI ESI EFlags ##.DeviceIoControl hDevice ##.##.VWIN32_DIOC_DOS_INT13 7
             :If #.RCode≠##.##.ERROR_SUCCESS
                 R←#.RCode
                 Data←##.##.Mem.Free hMem
                 #.RCode←R
                 :Return
             :ElseIf 2⊤EFlags
             :OrIf Sectors≠256⊤EAX
                 Data←##.##.Mem.Free hMem
                 #.RCode←(1 2 3 4 8 16 64 128⍳↑256 256⊤EAX)⊃##.##.ERROR_BAD_COMMAND ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_WRITE_PROTECT ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_NOT_READY ##.##.ERROR_CRC ##.##.ERROR_SEEK ##.##.ERROR_NOT_READY ##.##.ERROR_GEN_FAILURE
                 :Return
             :Else
                 Data←Data,(512×Sectors)##.##.Mem.Free hMem
             :EndIf
         :EndIf
     :EndFor
 :EndIf
∇

∇ {VOID}←Data Write Parms;hMem;hDevice;Drive;Offset;Cylinder;Head;Sector;Sectors;Mode;EAX;EBX;ECX;EDX;ESI;EDI;EFlags;R
     ⍝ Win95 only: Writes to a device.
     ⍝ Parms[1] = hDevice of VWin32.VxD
     ⍝ Parms[2] = Drive
     ⍝ Parms[3] = Offset in sectors
     ⍝ VOID = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 hDevice Drive Offset←3↑Parms
 Mode←8
 EAX←256⊥Mode 0
 EBX←0
 ECX←0
 EDX←256⊥Drive
 ESI←0
 EDI←0
 EFlags←2⊥1 0 0 1 0 0 0 1 1 0
 EBX EDX ECX EAX EDI ESI EFlags←EBX EDX ECX EAX EDI ESI EFlags ##.DeviceIoControl hDevice ##.##.VWIN32_DIOC_DOS_INT13 7
 :If #.RCode≠##.##.ERROR_SUCCESS
     VOID←1
 :ElseIf 2⊤EFlags
     #.RCode←(1 2 3 4 8 16 64 128⍳↑256 256⊤EAX)⊃##.##.ERROR_BAD_COMMAND ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_WRITE_PROTECT ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_NOT_READY ##.##.ERROR_CRC ##.##.ERROR_SEEK ##.##.ERROR_NOT_READY ##.##.ERROR_GEN_FAILURE
     VOID←1
 :Else
     Cylinder Sector←256 256⊤ECX
     Head←↑256 256⊤EDX
     Cylinder Head Sector←79 1 18⌊Cylinder Head Sector
     Mode←3
     :For Cylinder Head Sector Sectors :In Cylinder Head Sector{(0 0 1∘+¨↓[1](1 1 0+⍺)⊤A/B),¨C-0,¯1↓C←{⍵/⍳⍴⍵}1⌽A←↑{×↑⍴⍵:,/⍵ ⋄ ⊂⍬}(↑∘⍴¨(1+A)⊂A←0=⍺[3]|B←(¯1+↑⍵)+⍳2⊃⍵)⍴¨⊂8↑1}Offset(⌈(↑⍴Data)÷512)
         :If 0=hMem←##.##.Mem.Alloc(512×Sectors)↑Data
             VOID←1
             :Return
         :Else
             EAX←256 256⊥Mode Sectors
             EBX←hMem
             ECX←256 4 64⊥Cylinder 3 Sector
             EDX←256 256⊥Head Drive
             ESI←0
             EDI←0
             EFlags←2⊥1 0 0 1 0 0 0 1 1 0
             EBX EDX ECX EAX EDI ESI EFlags←EBX EDX ECX EAX EDI ESI EFlags ##.DeviceIoControl hDevice ##.##.VWIN32_DIOC_DOS_INT13 7
             :If #.RCode≠##.##.ERROR_SUCCESS
                 R←#.RCode
                 VOID←##.##.Mem.Free hMem
                 #.RCode←R
                 VOID←1
                 :Return
             :ElseIf 2⊤EFlags
             :OrIf Sectors≠256⊤EAX
                 VOID←##.##.Mem.Free hMem
                 #.RCode←(1 2 3 4 8 16 64 128⍳↑256 256⊤EAX)⊃##.##.ERROR_BAD_COMMAND ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_WRITE_PROTECT ##.##.ERROR_SECTOR_NOT_FOUND ##.##.ERROR_NOT_READY ##.##.ERROR_CRC ##.##.ERROR_SEEK ##.##.ERROR_NOT_READY ##.##.ERROR_GEN_FAILURE
                 VOID←1
                 :Return
             :Else
                 VOID←##.##.Mem.Free hMem
             :EndIf
         :EndIf
         Data←(512×Sectors)↓Data
     :EndFor
     VOID←0
 :EndIf
∇

:Namespace Samples
⎕IO ⎕ML ⎕WX ⎕CT←1 3 1 9.999999999999998E¯15

∇ {VOID}←MakeBootDiskette;hFile;hDevice;B144D70B;R
 #.Win.Init
 :If VOID←#.Win.INVALID_HANDLE_VALUE=hFile←#.Win.File.Open #.Win.Proc.GetWorkspaceDirectory,'\B144TEST.BIN' ⍝ Open WSPath\B144D70B.BIN
 :ElseIf VOID←0=⍴B144D70B←#.Win.File.Read hFile 82(#.Win.File.Size hFile)0                              ⍝ Read Disk Image to Variable B144D70B
     R←#.RCode
     #.Win.File.Close hFile                                                                             ⍝ If Error Close WSPath\B144D70B.BIN with RCode saved
     #.RCode←R
 :ElseIf VOID←#.Win.File.Close hFile                                                                    ⍝ Close WSPath\B144D70B.BIN
 :Else
     :Select 4⊃#.Win.Sys.GetVersion
     :Case #.Win.VER_PLATFORM_WIN32_WINDOWS                                        ⍝ Win95
         :If VOID←#.Win.INVALID_HANDLE_VALUE=hDevice←#.Win.File.DeviceOpen'VWIN32' ⍝ Open VWIN32.VxD
         :ElseIf 79 1 18≢#.Win.File.VWin32.GetType hDevice 0                       ⍝ Query Drive Type
             #.RCode←#.Win.ERROR_NOT_DOS_DISK
         :OrIf #.Win.File.VWin32.Format hDevice 0                                  ⍝ Format Disk
         :OrIf B144D70B #.Win.File.VWin32.Write hDevice 0 0                        ⍝ Write Disk Image
         :OrIf B144D70B≢#.Win.File.VWin32.Read hDevice 0 0(⌈(↑⍴B144D70B)÷512)      ⍝ Verify Written Data
             VOID←1
             R←#.RCode
             #.Win.File.Close hDevice                                              ⍝ If Error Close VWIN32.VxD with RCode saved
             #.RCode←R
         :Else
             VOID←#.Win.File.Close hDevice                                         ⍝ Close VWIN32.VxD
         :EndIf
     :Case #.Win.VER_PLATFORM_WIN32_NT                                                                            ⍝ WinNT
         :If VOID←#.Win.INVALID_HANDLE_VALUE=hDevice←#.Win.File.DeviceOpen'A:'                                    ⍝ Open A:
         :OrIf ''≡#.Win.F3_1Pt44_512 0 79 0 1 #.Win.File.DeviceIoControl hDevice #.Win.IOCTL_DISK_FORMAT_TRACKS 0 ⍝ Format Disk
         :OrIf 0>B144D70B #.Win.File.Write hDevice 0 82                                                           ⍝ Write Disk Image
         :OrIf B144D70B≢#.Win.File.Read hDevice 82(↑⍴B144D70B)0                                                   ⍝ Verify Written Data
             VOID←1
             R←#.RCode
             #.Win.File.Close hDevice                                                                             ⍝ If Error Close A: with RCode saved
             #.RCode←R
         :Else
             VOID←#.Win.File.Close hDevice                                                                        ⍝ Close A:
         :EndIf
     :EndSelect
 :EndIf
 #.Win.Exit
∇

∇ {VOID}←MakeBootFile;Data;hFile;hDevice;R;Sectors
 Sectors←800
 :If VOID←#.Win.INVALID_HANDLE_VALUE=hDevice←#.Win.File.DeviceOpen'VWIN32'
 :ElseIf VOID←0=⍴Data←#.Win.File.VWin32.Read hDevice 0 0 Sectors
     R←#.RCode
     #.Win.File.Close hDevice
     #.RCode←R
 :ElseIf VOID←#.Win.File.Close hDevice
 :Else
     :If VOID←#.Win.INVALID_HANDLE_VALUE=hFile←#.Win.File.Create #.Win.Proc.GetWorkspaceDirectory,'\B144TEST.BIN'
     :ElseIf VOID←¯1=Data #.Win.File.Write hFile 0 82
         R←#.RCode
         #.Win.File.Close hFile
         #.RCode←R
     :Else
         VOID←#.Win.File.Close hFile
     :EndIf
 :EndIf
∇

:EndNamespace 
:EndNamespace 
:EndNamespace 
:Namespace Keyboard
⎕IO ⎕ML ⎕WX←1 3 1

∇ EnterEvent Parms;VirtualKey;Flags
     ⍝ Get the status of the 256 virtual keys
     ⍝
     ⍝ Parms[1] = VirtualKey (#.Win.VK_xxx)
     ⍝ Parms[2] = Flags      (#.Win.KEYEVENTF_EXTENDEDKEY+#.Win.KEYEVENTF_KEYUP)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 VirtualKey Flags←2↑Parms
 {}##.keybd_event VirtualKey 0 Flags 0
∇

∇ State←GetState;GetKeyboardState;ValidFlag
     ⍝ Get the status of the 256 virtual keys
     ⍝
     ⍝ State[Index] = Status of any of the 256 keys (1=toogle state + 128=keypress state)
     ⍝       Index  = ⎕IO+#.Win.VK_xxx
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ↑ValidFlag State←##.GetKeyboardState 1
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     State←256⍴0
 :EndIf
∇

∇ States←GetToggleStates
     ⍝ Get the states of NUMLOCK SHIFTLOCK and SCROLLLOCK
     ⍝
     ⍝ States[1] = State of NUMLOCK
     ⍝ States[2] = State of SHIFTLOCK
     ⍝ States[3] = State of SCROLLLOCK
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 States←2|GetState[⎕IO+##.VK_NUMLOCK ##.VK_CAPITAL ##.VK_SCROLL]
∇

∇ SetToggleStates States;MofifyFlags
     ⍝ Set the states of NUMLOCK SHIFTLOCK and SCROLLLOCK
     ⍝
     ⍝ States[1] = State of NUMLOCK
     ⍝ States[2] = State of SHIFTLOCK
     ⍝ States[3] = State of SCROLLLOCK
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 MofifyFlags←GetToggleStates≠3↑States
 :If MofifyFlags[1]
     EnterEvent ##.VK_NUMLOCK ##.KEYEVENTF_EXTENDEDKEY
     EnterEvent ##.VK_NUMLOCK(##.KEYEVENTF_EXTENDEDKEY+##.KEYEVENTF_KEYUP)
 :EndIf
 :If MofifyFlags[2]
     EnterEvent ##.VK_CAPITAL ##.KEYEVENTF_EXTENDEDKEY
     EnterEvent ##.VK_CAPITAL(##.KEYEVENTF_EXTENDEDKEY+##.KEYEVENTF_KEYUP)
 :EndIf
 :If MofifyFlags[3]
     EnterEvent ##.VK_SCROLL ##.KEYEVENTF_EXTENDEDKEY
     EnterEvent ##.VK_SCROLL(##.KEYEVENTF_EXTENDEDKEY+##.KEYEVENTF_KEYUP)
 :EndIf
∇

:EndNamespace 
:Namespace Library
⎕IO ⎕ML ⎕WX←1 3 1

∇ hModules←EnumModules hProcess;_EnumProcessModules;ValidFlag;cbNeeded;_CreateToolhelp32Snapshot;_Module32First;_Module32Next
     ⍝ Retrieve a handle for each module in the specified process
     ⍝
     ⍝ hProcess = Processhandle or #.Win.Proc.GetCurrentProcess
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Trap 0
     '_EnumProcessModules'⎕NA'I PSAPI|EnumProcessModules I >I[] I >I'
     :If ↑ValidFlag hModules cbNeeded←_EnumProcessModules hProcess 4096 16384 1
         #.RCode←##.ERROR_SUCCESS
         hModules←(↑0 4⊤cbNeeded)↑hModules
     :Else
         #.RCode←##.GetLastError
         hModules←⍬
     :EndIf
 :Else
     :Trap 0
         '_CreateToolhelp32Snapshot'⎕NA'I KRENEL32|CreateToolhelp32Snapshot I I'
         '_Module32First'⎕NA'I KRENEL32|Module32First I ={I I I I I I I I T[256] T[260]}'
         '_Module32Next'⎕NA'I KRENEL32|Module32Next I ={I I I I I I I I T[256] T[260]}'
              ⍝ To be continued ..
         #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
         hModules←⍬
     :Else
         #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
         hModules←⍬
     :EndTrap
 :EndTrap
∇

∇ {VOID}←Free hModule
     ⍝ Decrement reference count of loaded Dynamic-Link-Library
     ⍝ VOID = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.ZERO≠##.FreeLibrary hModule
     #.RCode←##.ERROR_SUCCESS
     VOID←0
 :Else
     #.RCode←##.GetLastError
     VOID←1
 :EndIf
∇

∇ hModule←GetHandle FileName
     ⍝ Retrieve module handle if file has already been mapped into address space
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.NULL=hModule←##.GetModuleHandle⊂FileName
     #.RCode←##.GetLastError
     hModule←##.INVALID_HANDLE_VALUE
 :Else
     #.RCode←##.ERROR_SUCCESS
 :EndIf
∇

∇ BaseName←GetModuleBaseName Parms;hProcess;hModule;_GetModuleBaseName
     ⍝ Retrieve the base name of the specified module
     ⍝
     ⍝ Parms[1] = hProcess
     ⍝ Parms[2] = hModule
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hProcess hModule←2↑Parms
 :Trap 0
     '_GetModuleBaseName'⎕NA'I PSAPI|GetModuleBaseNameA I  I >T[] I'
     :If ×↑⍴BaseName←↑↑/_GetModuleBaseName hProcess hModule ##.MAX_PATH ##.MAX_PATH
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
     BaseName←''
 :EndTrap
∇

∇ Filename←GetModuleFileName Parms;hProcess;hModule;SingleParmFlag;_GetModuleFileNameEx
     ⍝ Retrieve the full path and file name for the file containing the specified module
     ⍝
     ⍝ Parms    = hModule
     ⍝ or
     ⍝ Parms[1] = hProcess
     ⍝ Parms[2] = hModule
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If SingleParmFlag←1=×/⍴Parms
     hModule←↑Parms
 :Else
     hProcess hModule←2↑Parms
     :Trap 0
         '_GetModuleFileNameEx'⎕NA'I PSAPI|GetModuleFileNameExA I I >T[] I'
         :If ×↑⍴Filename←↑↑/_GetModuleFileNameEx hProcess hModule ##.MAX_PATH ##.MAX_PATH
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
         :EndIf
     :Else
         SingleParmFlag←1
     :EndTrap
 :EndIf
 :If SingleParmFlag
     :If ×↑⍴Filename←↑↑/##.GetModuleFileName hModule ##.MAX_PATH ##.MAX_PATH
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :EndIf
∇

∇ Header←GetNTHeaders hModule;Offset;IMAGE_FILE_HEADER;IMAGE_OPTIONAL_HEADER;IMAGE_NT_HEADERS
     ⍝ Get the IMAGE_NT_HEADERS including IMAGE_FILE_HEADER and IMAGE_OPTIONAL_HEADER from a module handle
     ⍝
     ⍝ Header[1]  = Signature
     ⍝ Header[2]  = Machine
     ⍝ Header[3]  = NumberOfSections
     ⍝ Header[4]  = TimeDateStamp
     ⍝ Header[5]  = PointerToSymbolTable
     ⍝ Header[6]  = NumberOfSymbols
     ⍝ Header[7]  = SizeOfOptionalHeader
     ⍝ Header[8]  = Characteristics
     ⍝ Header[9]  = Magic
     ⍝ Header[10] = MajorLinkerVersion
     ⍝ Header[11] = MinorLinkerVersion
     ⍝ Header[12] = SizeOfCode
     ⍝ Header[13] = SizeOfInitializedData
     ⍝ Header[14] = SizeOfUninitializedData
     ⍝ Header[15] = AddressOfEntryPoint
     ⍝ Header[16] = BaseOfCode
     ⍝ Header[17] = BaseOfData
     ⍝ Header[18] = ImageBase
     ⍝ Header[19] = SectionAlignment
     ⍝ Header[20] = FileAlignment
     ⍝ Header[21] = MajorOperatingSystemVersion
     ⍝ Header[22] = MinorOperatingSystemVersion
     ⍝ Header[23] = MajorImageVersion
     ⍝ Header[24] = MinorImageVersion
     ⍝ Header[25] = MajorSubsystemVersion
     ⍝ Header[26] = MinorSubsystemVersion
     ⍝ Header[27] = Win32VersionValue
     ⍝ Header[28] = SizeOfImage
     ⍝ Header[29] = SizeOfHeaders
     ⍝ Header[30] = CheckSum
     ⍝ Header[31] = Subsystem
     ⍝ Header[32] = DllCharacteristics
     ⍝ Header[33] = SizeOfStackReserve
     ⍝ Header[34] = SizeOfStackCommit
     ⍝ Header[35] = SizeOfHeapReserve
     ⍝ Header[36] = SizeOfHeapCommit
     ⍝ Header[37] = LoaderFlags
     ⍝ Header[38] = NumberOfRvaAndSizes
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 IMAGE_FILE_HEADER←2 2 4 4 4 2 2
 IMAGE_OPTIONAL_HEADER←2 1 1 4 4 4 4 4 4 4 4 4 2 2 2 2 2 2 4 4 4 4 2 2 4 4 4 4 4 4
 IMAGE_NT_HEADERS←¯4,IMAGE_FILE_HEADER,IMAGE_OPTIONAL_HEADER
 :If 'MZ'≡2 ##.Mem.Read hModule
     Offset←4 ##.IntTxt 4 ##.Mem.Read hModule+60
 :AndIf 'PE'≡2 ##.Mem.Read hModule+Offset
     Header←IMAGE_NT_HEADERS ##.SplitTxtStruct(+/|IMAGE_OPTIONAL_HEADER)##.Mem.Read hModule+Offset
 :Else
     Header←(⊂''),37⍴0
 :EndIf
∇

∇ pProc←GetProcAddress Parms;hModule;ProcName
     ⍝ Retrieve address of specified exported Dynamic-Link-Library function
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hModule ProcName←2↑Parms
 :If ##.NULL=pProc←##.GetProcAddress hModule ProcName
     #.RCode←##.GetLastError
 :Else
     #.RCode←##.ERROR_SUCCESS
 :EndIf
∇

∇ hModule←Load FileName
     ⍝ Map specified executable module into address space of the calling process
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.NULL=hModule←##.LoadLibrary⊂FileName
     #.RCode←##.GetLastError
     hModule←##.INVALID_HANDLE_VALUE
 :Else
     #.RCode←##.ERROR_SUCCESS
 :EndIf
∇

:Namespace Samples
⎕IO ⎕ML ⎕WX←1 3 1

∇ SCardPCI;hModule;SCARD_PCI_T0;SCARD_PCI_T1;SCARD_PCI_RAW
 hModule←#.Win.Library.Load'WINSCARD'
 'SCARD_PCI_T0:  ',(8 1 8\1 0 1)\#.Win.HexTxt SCARD_PCI_T0←8 #.Win.Mem.Read #.Win.Library.GetProcAddress hModule'g_rgSCardT0Pci'
 'SCARD_PCI_T1:  ',(8 1 8\1 0 1)\#.Win.HexTxt SCARD_PCI_T1←8 #.Win.Mem.Read #.Win.Library.GetProcAddress hModule'g_rgSCardT1Pci'
 'SCARD_PCI_RAW: ',(8 1 8\1 0 1)\#.Win.HexTxt SCARD_PCI_RAW←8 #.Win.Mem.Read #.Win.Library.GetProcAddress hModule'g_rgSCardRawPci'
 #.Win.Library.Free hModule
∇

:EndNamespace 
:EndNamespace 
:Namespace Mem
⎕IO ⎕ML ⎕WX←1 3 1

∇ hMem←Alloc DataSize;Data;Bytes;VOID
     ⍝ Allocates memory (RAM) in the given DataSize(integer) and optionaly fills it with the data in DataSize(Char)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 82=⎕DR DataSize
     Bytes←↑⍴Data←##.IntTxt DataSize
     :If ##.NULL≠hMem←##.GlobalAlloc ##.GMEM_FIXED Bytes
         VOID←##.RtlMoveMemoryW hMem Data Bytes
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :ElseIf 0<Bytes←DataSize
     :If ##.NULL≠hMem←##.GlobalAlloc(##.GMEM_FIXED+##.GMEM_ZEROINIT)Bytes
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :ElseIf ##.NULL≠hMem←##.GlobalAlloc(##.GMEM_MOVEABLE+##.GMEM_ZEROINIT)(|Bytes)
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {Data}←{Bytes}Free hMem;pMem
     ⍝ Frees a previously allocated memory (RAM) and optionaly returns all (¯1) or Bytes number of bytes in Data.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×⎕NC'Bytes'
 :AndIf 0≠Bytes
     :If 0<Bytes
         Bytes←Bytes⌊##.GlobalSize hMem
     :Else
         Bytes←##.GlobalSize hMem
     :EndIf
     :If 0≠Bytes
     :AndIf ##.NULL≠pMem←##.GlobalLock hMem
         Data←##.RtlMoveMemoryR Bytes pMem Bytes
     :Else
         Data←''
     :EndIf
 :Else
     Data←''
 :EndIf
 :If ##.NULL=##.GlobalFree hMem
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ pMem←Handle hMem
     ⍝ Return a pointer to the first byte of memory
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.NULL≠pMem←##.GlobalHandle hMem
     #.RCode←##.ERROR_SUCCESS
 :ElseIf
     #.RCode←##.GetLastError
 :EndIf
∇

∇ pMem←Lock hMem
     ⍝ Lock a global memory object and return a pointer to the first byte of memory
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.NULL≠pMem←##.GlobalLock hMem
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hMem←Bytes ReAlloc Parms;hMem;Flags
     ⍝ Change the size of a specified memory object. The size can increase or decrease.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hMem Flags←2↑Parms,##.GMEM_ZEROINIT
 :If ##.NULL≠hMem←##.GlobalReAlloc hMem Bytes Flags
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Data←Bytes Read pMem
     ⍝ Reads a given number of Bytes from the address in hMem.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0∊Bytes pMem
     Data←''
 :Else
     Data←##.RtlMoveMemoryR Bytes pMem Bytes
 :EndIf
∇

∇ Data←ReadStr hMem
     ⍝ Reads a 0-terminated String from the address in hMem.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0=hMem
     Data←''
 :Else
     Data←2⊃##.lstrcpyPtr(1+##.lstrlenPtr hMem)hMem
 :EndIf
∇

∇ Bytes←Size hMem
     ⍝ Retrieve the current size, in bytes, of the specified memory object
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.NULL≠Bytes←##.GlobalSize hMem
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {LockCount}←Unlock hMem
     ⍝ Decrement the lock count of a memory object allocated with GMEM_MOVEABLE
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.NULL≠LockCount←##.GlobalUnlock hMem
     #.RCode←##.ERROR_SUCCESS
 :ElseIf ##.ERROR_SUCCESS≠#.RCode←##.GetLastError
     LockCount←¯1
 :EndIf
∇

∇ Data Write pMem;Bytes;VOID
     ⍝ Writes Data to the address in hMem.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×Bytes←↑⍴Data←##.IntTxt Data
     VOID←##.RtlMoveMemoryW pMem Data Bytes
 :EndIf
∇

:EndNamespace 
:Namespace Message
⎕IO ⎕ML ⎕WX←1 3 1

∇ {ValidFlag}←Post Parms;hWnd;Msg;wParam;lParam
     ⍝ Place (Post) a message in the message queue associated with
     ⍝ the thread that created the specified window and returns without waiting
     ⍝
     ⍝ Parms[1] = hWnd    Handle to destination window
     ⍝ Parms[2] = Msg     Message
     ⍝ Parms[3] = wParam  First message parameter  (Unsigned Integer)
     ⍝ Parms[4] = lParam  Second message parameter (Unsigned Integer)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWnd Msg wParam lParam←4↑Parms
 wParam←{2147483647≥⍵:⍵ ⋄ ⌊⍵-4294967296}wParam
 lParam←{2147483647≥⍵:⍵ ⋄ ⌊⍵-4294967296}lParam
 :If ValidFlag←##.PostMessage hWnd Msg wParam lParam
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←PostThread Parms;idThread;Msg;wParam;lParam;Count
     ⍝ Post a message to the message queue of the specified thread.
     ⍝ It returns without waiting for the thread to process the message.
     ⍝
     ⍝ Parms[1] = idThread Thread identifier
     ⍝ Parms[2] = Msg      Message                  (#.Win.WM_xxx)
     ⍝ Parms[3] = wParam   First message parameter  (Unsigned Integer)
     ⍝ Parms[4] = lParam   Second message parameter (Unsigned Integer)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 idThread Msg wParam lParam←4↑Parms
 wParam←{2147483647≥⍵:⍵ ⋄ ⌊⍵-4294967296}wParam
 lParam←{2147483647≥⍵:⍵ ⋄ ⌊⍵-4294967296}lParam
 Count←0
 :While ~ValidFlag←##.PostThreadMessage idThread Msg wParam lParam
     {}##.Sleep 25
 :Until 10<Count←1+Count
 :If ValidFlag
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Msg←RegisterWindow String
     ⍝ Define a new window message that is guaranteed to be unique throughout the system.
     ⍝ The message value can be used when sending or posting messages.
     ⍝
     ⍝ String = Message string to be registered: eg 'DyalogCustomMessage1'
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.ZERO≠Msg←##.RegisterWindowMessage⊂String
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {Result}←Send Parms;hWnd;Msg;wParam;lParam
     ⍝ Send the specified message to a window or windows.
     ⍝ It calls the window procedure for the specified window
     ⍝ and does not return until the window procedure has processed the message.
     ⍝
     ⍝ Parms[1] = hWnd    Handle to destination window
     ⍝ Parms[2] = Msg     Message
     ⍝ Parms[3] = wParam  First message parameter  (Unsigned Integer)
     ⍝ Parms[4] = lParam  Second message parameter (Unsigned Integer)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWnd Msg wParam lParam←4↑Parms
 wParam←{2147483647≥⍵:⍵ ⋄ ⌊⍵-4294967296}wParam
 lParam←{2147483647≥⍵:⍵ ⋄ ⌊⍵-4294967296}lParam
 Result←##.SendMessage hWnd Msg wParam lParam
∇

:Namespace Samples
⎕IO ⎕ML ⎕WX←1 3 1

∇ DeQueue;MyMessageForm
     ⍝ Execute this function on the SERVER instance of Dyalog APL
     ⍝ The event DyalogCustomMessage1 is still executed in the "Ready..." state.
     ⍝ Therefore it is not necessary to execute ⎕DQ'MyMessageForm'.
 'MyMessageForm'⎕WC'Form' 'MySampleWindow'('Visible' 0)('Event' 'DyalogCustomMessage1' '_onDyalogCustomMessage1')
 ⎕DQ'MyMessageForm'
∇

∇ Demo;Form
 'Form'⎕WC'Form'('OnTop' 1)
 'Form.ListView'⎕WC'ListView'('Items'(⊂[2]'ZI6'⎕FMT⍳500))('SelItems'(500⍴12↑1))('Style' 'Multi')('View' 'Report')('Posn'(0 0))('Size'(100 100))
 'Form.ListView'ListView_EnsureVisible 100 ⋄ ⎕DL 1
 'Form.ListView'ListView_EnsureVisible 500 ⋄ ⎕DL 1
 'Form.ListView'ListView_EnsureVisible 499 ⋄ ⎕DL 1
 'Form.ListView'ListView_EnsureVisible 490 ⋄ ⎕DL 1
 'Form.ListView'ListView_EnsureVisible 400 ⋄ ⎕DL 1
 'Form.ListView'ListView_EnsureVisible 100 ⋄ ⎕DL 1
 'Form.ListView'ListView_EnsureVisible 1 ⋄ ⎕DL 1
 'Form.ListView'ListView_Scroll 0 100 ⋄ ⎕DL 1
 'Form.ListView'ListView_Scroll 0 100 ⋄ ⎕DL 1
 'Form.ListView'ListView_Scroll 0 ¯150 ⋄ ⎕DL 2
∇

∇ Result←EnQueue Parms;hWnds;Msg;wParam;lParam
     ⍝ Execute this function on the CLIENT instance of Dyalog APL
     ⍝ EnQueued messages will be reported on the server instance
     ⍝ The server instance will terminate upon "EnQueue 1 1"
     ⍝
     ⍝ Parms[1] = wParam  First message parameter  (Unsigned Integer)
     ⍝ Parms[2] = lParam  Second message parameter (Unsigned Integer)
 #.Win.Init
 wParam lParam←2↑Parms
 :If 0∊⍴hWnds←((#.Win.Window.GetText hWnds)∊⊂'MySampleWindow')/hWnds←#.Win.Window.EnumChilds #.Win.Window.GetDesktop
     #.RCode←#.Win.ERROR_WAIT_NO_CHILDREN
     Result←0
 :ElseIf #.Win.ZERO=Msg←#.Win.Message.RegisterWindow'DyalogCustomMessage1'
     Result←0
 :Else
     Result←#.Win.Message.Send¨hWnds,¨⊂Msg wParam lParam
 :End
∇

∇ KillAllThreads;ThreadId;ThreadIds;hKernel;pExitThread
 ThreadIds←(⍳1000)~#.Win.Proc.GetCurrentThreadId
 hKernel←#.Win.Library.GetHandle'KERNEL32'
 pExitThread←#.Win.Library.GetProcAddress hKernel'ExitThread'
 :For ThreadId :In ThreadIds
     #.Win.Message.PostThread ThreadId #.Win.WM_TIMER 0 pExitThread
 :EndFor
∇

∇ {Result}←Object ListView_EnsureVisible Parms;i;fPartialOK;hWnd;LVM_FIRST;LVM_ENSUREVISIBLE
     ⍝ Ensures that a ListView item is either entirely or partially visible,
     ⍝ scrolling the list view control if necessary
     ⍝
     ⍝ Object   =             Name of a ListView object
     ⍝ Parms[1] = i           Index of the list view item
     ⍝ Parms[2] = fPartialOK  Whether the item must be entirely visible: if TRUE, no scrolling if item is at least partially visible
     ⍝
     ⍝ Result   = 0(fail) 1(OK)
 LVM_FIRST←4096
 LVM_ENSUREVISIBLE←LVM_FIRST+19
 hWnd←Object ⎕WG'Handle'
 i fPartialOK←2↑Parms
 i←i-⎕IO
 Result←#.Win.Message.Send hWnd LVM_ENSUREVISIBLE i fPartialOK
∇

∇ {Result}←Object ListView_Scroll Parms;dx;dy;hWnd;LVM_FIRST;LVM_SCROLL
     ⍝ Scrolls the content of a list view control
     ⍝
     ⍝ Object   =     Name of a ListView object
     ⍝ Parms[1] = dx  Amount of horizontal scrolling in pixels, if ('View' 'List'): number of columns
     ⍝ Parms[2] = dy  Amount of vertical scrolling in pixels
     ⍝
     ⍝ Result   = 0(fail) 1(OK)
 LVM_FIRST←4096
 LVM_SCROLL←LVM_FIRST+20
 hWnd←Object ⎕WG'Handle'
 dx dy←2↑Parms
 Result←#.Win.Message.Send hWnd LVM_SCROLL dx dy
∇

∇ _onDyalogCustomMessage1 Message;Object;Event;wParam;lParam
 Object Event wParam lParam←4↑Message
 ⎕←'Object: 'Object
 ⎕←'Event:  'Event
 ⎕←'wParam: 'wParam
 ⎕←'lParam: 'lParam
 ⎕←''
 :If 1 0≡wParam lParam
     ⎕NQ'MyMessageForm' 'Close'
 :EndIf
∇

:EndNamespace 
:EndNamespace 
:Namespace Mutex
⎕IO ⎕ML ⎕WX←1 3 1

∇ {VOID}←Close hObject
     ⍝ Closes an open handle to an object such as a file handle.
     ⍝ VOID = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.TRUE=##.CloseHandle hObject
     #.RCode←##.ERROR_SUCCESS
     VOID←0
 :Else
     #.RCode←##.GetLastError
     VOID←1
 :EndIf
∇

∇ Retrn←{Name}Create Parms;InheritHandle;InitialOwner;SECURITY_ATTRIBUTES;hMutex;ExistentMutex
     ⍝ Create a named (must be different from any event, semaphore, waitable timer, job, or file-mapping object name) or unnamed mutex object
     ⍝
     ⍝ Parms[1] = InitialOwner  Flag (#.Win.FALSE or #.Win.TRUE)
     ⍝ Parms[2] = InheritHandle Flag (def. #.Win.FALSE)
     ⍝
     ⍝ Retrn[1] = hMutex        Handle to the mutex object or #.Win.INVALID_HANDLE_VALUE
     ⍝ Retrn[2] = ExistentMutex Flag indicating the caller opened (1) the mutex instead of creating (0) it
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 InitialOwner InheritHandle←2↑Parms
 SECURITY_ATTRIBUTES←##.SECURITY_ATTRIBUTES
 :Select InheritHandle
 :Case ##.FALSE
     SECURITY_ATTRIBUTES[3]←##.FALSE
 :Case ##.TRUE
     SECURITY_ATTRIBUTES[3]←##.TRUE
 :EndSelect
 :If ×⎕NC'Name'
 :AndIf 0≠↑⍴Name
     hMutex←##.CreateMutex SECURITY_ATTRIBUTES InitialOwner Name
 :Else
     hMutex←##.CreateMutexI SECURITY_ATTRIBUTES InitialOwner 0
 :EndIf
 ExistentMutex←##.ERROR_ALREADY_EXISTS=#.RCode←##.GetLastError
 :If 0=hMutex
     hMutex←##.INVALID_HANDLE_VALUE
 :EndIf
 Retrn←hMutex ExistentMutex
∇

∇ hMutex←Name Open Parms;DesiredAccess;InheritHandle
     ⍝ Return a handle to an existing named mutex object
     ⍝
     ⍝ Parms[1] = DesiredAccess (#.Win.MUTEX_ALL_ACCESS (def.) or #.Win.MUTEX_MODIFY_STATE)
     ⍝ Parms[2] = InheritHandle Flag (def. #.Win.FALSE)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 DesiredAccess InheritHandle←2↑Parms
 :If 0=DesiredAccess
     DesiredAccess←##.MUTEX_ALL_ACCESS
 :EndIf
 :If ##.NULL=hMutex←##.OpenMutex DesiredAccess InheritHandle Name
     #.RCode←##.GetLastError
     hMutex←##.INVALID_HANDLE_VALUE
 :Else
     #.RCode←##.ERROR_SUCCESS
 :EndIf
∇

∇ {VOID}←Release hMutex
     ⍝ Releases ownership of the specified mutex object
     ⍝ VOID = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.ZERO=##.ReleaseMutex hMutex
     #.RCode←##.GetLastError
     VOID←1
 :Else
     #.RCode←##.ERROR_SUCCESS
     VOID←0
 :EndIf
∇

∇ Status←Wait Parms;hHandle;Milliseconds;Full;Last
     ⍝ Return when one of the following occurs: The specified object is in the signaled state. The time-out interval elapses
     ⍝
     ⍝ Parms[1] = hHandle
     ⍝ Parms[2] = Milliseconds to wait or #.Win.INFINITE
     ⍝
     ⍝ Status   = #.Win.WAIT_OBJECT_0  (0)   The state of the specified object is signaled
     ⍝ Status   = #.Win.WAIT_ABANDONED (128) The specified object is a mutex object that was released by thread terminate
     ⍝ Status   = #.Win.WAIT_TIMEOUT   (258) The time-out interval elapsed, and the object's state is nonsignaled
     ⍝ Status   = #.Win.WAIT_FAILED    (¯1)  The function fails, see #.RCode
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hHandle Milliseconds←2↑Parms,##.INFINITE
 Full Last←0(Milliseconds←25)⊤Milliseconds
 :Trap 1000
     :Repeat
         :If ¯1=Full←¯1+Full
             Milliseconds←Last
         :EndIf
         :If #.Win.WAIT_TIMEOUT≠Status←##.WaitForSingleObject hHandle Milliseconds
             :Leave
         :EndIf
     :Until ¯1=Full
     :OrIf 0 0≡Full Last
 :Else
     Status←##.WAIT_TIMEOUT
 :EndTrap
 #.RCode←##.GetLastError
∇

:EndNamespace 
:Namespace Net
⎕IO ⎕ML ⎕WX←1 3 1

:Namespace Alert
⎕IO ⎕ML ⎕WX←1 3 1

∇ {ValidFlag}←RaiseEx Parms;AlertEventName;VariableInfo;VariableInfoSize;ServiceName
     ⍝ Notify all registered clients when a particular event occurs
     ⍝
     ⍝ Parms[1] = AlertEventName 'PRINTING'(ALERT_PRINT_EVENT) 'MESSAGE'(ALERT_MESSAGE_EVENT) 'ERRORLOG'(ALERT_ERRORLOG_EVENT) 'ADMIN'(ALERT_ADMIN_EVENT) 'USER'(ALERT_USER_EVENT)
     ⍝ Parms[2] = VariableInfo   Any of these structures: ADMIN_OTHER_INFO ERRLOG_OTHER_INFO PRINT_OTHER_INFO or USER_OTHER_INFO
     ⍝ Parms[3] = ServiceName
     ⍝
     ⍝ Sample:
     ⍝ #.Win.Net.Alert.RaiseEx'ADMIN'((4 #.Win.TxtInt 6005 1),#.Win.Char.ByteToWide'Test Error',↑⎕AV)'eventlog'
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 AlertEventName VariableInfo ServiceName←3↑Parms
 AlertEventName←##.##.IntTxt ##.##.Char.ByteToWide AlertEventName,↑⎕AV
 ServiceName←##.##.IntTxt ##.##.Char.ByteToWide ServiceName,↑⎕AV
 VariableInfo←##.##.IntTxt VariableInfo
 VariableInfoSize←↑⍴VariableInfo
 ValidFlag←##.##.ERROR_SUCCESS=#.RCode←##.##.NetAlertRaiseEx AlertEventName VariableInfo VariableInfoSize ServiceName
∇

:EndNamespace 
:Namespace Message
⎕IO ⎕ML ⎕WX←1 3 1

∇ {VOID}←BufferSend Parms;ServerName;MsgName;FromName;Buffer;Buflen
     ⍝ Send a buffer of information to a registered message alias
     ⍝
     ⍝ Parms[1] = ServerName  (def loacl or \\...)
     ⍝ Parms[2] = MsgName     (def ⎕AN or message alias)
     ⍝ Parms[3] = FromName    (def local computer name or other computer's name)
     ⍝ Parms[4] = Buffer      (message to be sent)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 0≤##.##.GetVersion  ⍝ WinNT only
     ServerName MsgName FromName Buffer←4↑Parms
     :If ×↑⍴ServerName
         ServerName←##.##.IntTxt ##.##.Char.ByteToWide ServerName,↑⎕AV
     :EndIf
     :If ×↑⍴MsgName
         MsgName←##.##.IntTxt ##.##.Char.ByteToWide MsgName,↑⎕AV
     :Else
         MsgName←##.##.IntTxt ##.##.Char.ByteToWide ⎕AN,↑⎕AV
     :EndIf
     :If ×↑⍴FromName
         FromName←##.##.IntTxt ##.##.Char.ByteToWide FromName,↑⎕AV
     :EndIf
     Buffer←##.##.IntTxt ##.##.Char.ByteToWide Buffer
     Buflen←↑⍴Buffer
     
     :Select ×↑¨⍴¨ServerName FromName
     :Case 1 1
         VOID←0≠#.RCode←##.##.NetMessageBufferSendAA ServerName MsgName FromName Buffer Buflen
     :Case 1 0
         VOID←0≠#.RCode←##.##.NetMessageBufferSendAI ServerName MsgName 0 Buffer Buflen
     :Case 0 1
         VOID←0≠#.RCode←##.##.NetMessageBufferSendIA 0 MsgName FromName Buffer Buflen
     :Case 0 0
         VOID←0≠#.RCode←##.##.NetMessageBufferSendII 0 MsgName 0 Buffer Buflen
     :EndSelect
 :Else
     #.RCode←##.##.ERROR_CALL_NOT_IMPLEMENTED
     VOID←1
 :EndIf
∇

∇ MsgiNames←NameEnum ServerName;Level;BufferPtr;BufferSize;EntriesRead;TotalEntries;Resume_Handle;MsgiNamePtr;MsgiName;MAX_PREFERRED_LENGTH;VOID
     ⍝ List the message aliases that receive messages on a specified computer (Messenger service must be started)
     ⍝
     ⍝ ServerName  (def local ('') or \\...)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 0≤##.##.GetVersion  ⍝ WinNT only
     :If ×↑⍴ServerName
         ServerName←##.##.IntTxt ##.##.Char.ByteToWide ServerName,↑⎕AV
     :EndIf
     MsgiNames←0⍴⊂'' ''
     Level←1
     MAX_PREFERRED_LENGTH←¯1
     Resume_Handle←##.##.NULL
     :Repeat
         :If ×↑⍴ServerName
             #.RCode BufferPtr EntriesRead TotalEntries Resume_Handle←##.##.NetMessageNameEnum ServerName Level 1 MAX_PREFERRED_LENGTH 1 1 Resume_Handle
         :Else
             #.RCode BufferPtr EntriesRead TotalEntries Resume_Handle←##.##.NetMessageNameEnumI 0 Level 1 MAX_PREFERRED_LENGTH 1 1 Resume_Handle
         :EndIf
         :If ##.##.ERROR_SUCCESS≠#.RCode
             :Leave
         :EndIf
         :If ##.##.ERROR_SUCCESS≠↑#.RCode BufferSize←##.##.NetApiBufferSize BufferPtr 1
             VOID←##.##.NetApiBufferFree BufferPtr
             :Leave
         :EndIf
         MsgiNamePtr←↑4 ##.##.IntTxt 4 ##.##.Mem.Read BufferPtr
         :If MsgiNamePtr<BufferPtr
         :OrIf MsgiNamePtr>BufferPtr+BufferSize
             #.RCode←##.##.ERROR_INVALID_BLOCK
             VOID←##.##.NetApiBufferFree BufferPtr
             :Leave
         :EndIf
         MsgiName←##.##.Char.WideToByte(BufferPtr+BufferSize-MsgiNamePtr)##.##.Mem.Read MsgiNamePtr
         :If ##.##.ERROR_SUCCESS≠#.RCode←##.##.NetApiBufferFree BufferPtr
             :Leave
         :EndIf
         MsgiName←0 1↓¨2↑(MsgiName≠↑⎕AV)⊂MsgiName
         MsgiNames,←⊂MsgiName
     :Until 0=Resume_Handle
     :If ##.##.ERROR_SUCCESS≠#.RCode
         MsgiNames←0⍴⊂'' ''
     :EndIf
 :Else
     #.RCode←##.##.ERROR_CALL_NOT_IMPLEMENTED
     VOID←1
 :EndIf
∇

:EndNamespace 
:Namespace Remote
⎕IO ⎕ML ⎕WX←1 3 1

∇ TimeOfDayInfo←TOD UncServerName;BufferPtr
     ⍝ Return the time of day information from a specified server
     ⍝
     ⍝ UncServerName     = string must begin with \\. If '': local computer is used
     ⍝
     ⍝ TimeOfDayInfo[1]  = seconds since 00:00:00, January 1, 1970, GMT
     ⍝ TimeOfDayInfo[2]  = milliseconds from system reset
     ⍝ TimeOfDayInfo[3]  = current hour
     ⍝ TimeOfDayInfo[4]  = current minute
     ⍝ TimeOfDayInfo[5]  = current second
     ⍝ TimeOfDayInfo[6]  = current hundredth second
     ⍝ TimeOfDayInfo[7]  = time zone in minutes from GMT
     ⍝ TimeOfDayInfo[8]  = time interval for tick clock in 1/10000 second
     ⍝ TimeOfDayInfo[9]  = current day
     ⍝ TimeOfDayInfo[10] = current month
     ⍝ TimeOfDayInfo[11] = current year
     ⍝ TimeOfDayInfo[12] = day of the week: 0=Sunday 1=Monday ..
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.##.Init
 :If 0≤##.##.GetVersion  ⍝ WinNT only
     :If ×↑⍴UncServerName
         UncServerName←##.##.IntTxt ##.##.Char.ByteToWide UncServerName,↑⎕AV
         :If ##.##.ERROR_SUCCESS=↑#.RCode BufferPtr←##.##.NetRemoteTOD UncServerName 1
             TimeOfDayInfo←4 ##.##.IntTxt 48 ##.##.Mem.Read BufferPtr
             #.RCode←##.##.NetApiBufferFree BufferPtr
         :Else
             TimeOfDayInfo←12⍴0
         :EndIf
     :ElseIf ##.##.ERROR_SUCCESS=↑#.RCode BufferPtr←##.##.NetRemoteTODI 0 1
         TimeOfDayInfo←4 ##.##.IntTxt 48 ##.##.Mem.Read BufferPtr
         #.RCode←##.##.NetApiBufferFree BufferPtr
     :Else
         TimeOfDayInfo←12⍴0
     :EndIf
 :Else
     #.RCode←##.##.ERROR_CALL_NOT_IMPLEMENTED
     TimeOfDayInfo←12⍴0
 :EndIf
∇

:EndNamespace 
:EndNamespace 
:Namespace Printer
⎕IO ⎕ML ⎕WX←1 3 1

∇ DevMode←BuildDevMode Parms;DeviceName;SpecVersion;DriverVersion;Size;DriverExtra;DriverExtraData
     ⍝ Combines a resolved DEVMODE structure
     ⍝
     ⍝ Parms[1]  = DeviceName       Printer's friendly name, eg "PCL/HP LaserJet"
     ⍝ Parms[2]  = SpecVersion      Version number of initialization data specification (DM_SPECVERSION)
     ⍝ Parms[3]  = DriverVersion    Version number assigned by printer driver developer
     ⍝ Parms[4]  = Size             Size of DEVMODE structure without DriverExtraData
     ⍝ Parms[5]  = DriverExtra      Size of DriverExtraData
     ⍝ Parms[6]  = Fields           Flags specifying whether certain members of DEVMODE structure have been initialized (DM_xxx)
     ⍝ Parms[7]  = Orientation      Portrait=1 Landscape=2
     ⍝ Parms[8]  = PaperSize        Size of the paper to print on (DMPAPER_xxx)
     ⍝ Parms[9]  = PaperLength      Overrides length of paper from PaperSize in tenths of a millimeter
     ⍝ Parms[10] = PaperWidth       Overrides width of paper from PaperSize in tenths of a millimeter
     ⍝ Parms[11] = Scale            Factor by which printed output is to be scaled
     ⍝ Parms[12] = Copies           Number of copies printed
     ⍝ Parms[13] = DefaultSource    Specifies paper source / input bin
     ⍝ Parms[14] = PrintQuality     Printer (x-)resolution in DPI or (DMRES_xxx)
     ⍝ Parms[15] = Color            Switches between color and monochrome on color (DMCOLOR_xxx)
     ⍝ Parms[16] = Duplex           Selects duplex or double-sided printing for capable printers
     ⍝ Parms[17] = YResolution      Printer y-resolution in DPI
     ⍝ Parms[18] = TTOption         Specifies how TrueType fonts should be printed
     ⍝ Parms[19] = Collate          Specifies whether collation should be used when printing multiple copies
     ⍝ Parms[20] = FormName         Specifies the name of the form to use, eg "Letter" or "A4"
     ⍝ Parms[21] = LogPixels        Number of pixels per logical inch of a display device
     ⍝ Parms[22] = BitsPerPel       Color resolution, in bits per pixel, of a display device
     ⍝ Parms[23] = PelsWidth        Width, in pixels, of the visible surface of a display device
     ⍝ Parms[24] = PelsHeight       Height, in pixels, of the visible surface of a display device
     ⍝ Parms[25] = DisplayFlags     Device display mode
     ⍝ Parms[26] = DisplayFrequency Frequency, in hertz, of a display device
     ⍝ Parms[27] = ICMMethod        How ICM is handled
     ⍝ Parms[28] = ICMIntent        Specifies color matching method
     ⍝ Parms[29] = MediaType        Specifies media type being printed on
     ⍝ Parms[30] = DitherType       How dithering is to be done
     ⍝ Parms[31] = Reserved1        Must be zero
     ⍝ Parms[32] = Reserved2        Must be zero
     ⍝ Parms[33] = PanningWidth     Must be zero
     ⍝ Parms[34] = PanningHeight    Must be zero
     ⍝ Parms[35] = DriverExtraData  Device driver's private data
     ⍝
     ⍝ DevMode   = DEVMODE structure
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
     ⍝
 DeviceName SpecVersion DriverVersion Size DriverExtra←5↑Parms
 DriverExtraData←DriverExtra↑↑¯1↑Parms
 DevMode←((Size+.≥+\|##.DEVMODE)↑##.DEVMODE)##.BuildTxtStruct ¯1↓Parms
 DevMode,←DriverExtraData
∇

∇ DevNames←BuildDevNames Parms;Driver;Device;Output;Default;DriverOffset;DeviceOffset;OutputOffset;Value;Type
     ⍝ Combines a resolved DEVNAMES structure
     ⍝
     ⍝ Parms[1]  = Device  Printer's friendly name, eg "PCL/HP LaserJet"
     ⍝ Parms[2]  = Driver  (opt) Driver's name without .drv extension, eg "winspool"
     ⍝ Parms[3]  = Output  (opt) Port "LPT1:" or "FILE:" or filename
     ⍝ Parms[4]  = Default (opt) #.Win.DN_DEFAULTPRN flag set if this is the default printer
     ⍝
     ⍝ DevNames  = DEVNAMES structure
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     Parms←,⊂Parms
 :EndIf
 :Select ↑⍴Parms
 :Case 1
     Device←↑Parms
     :If ','∊↑Value Type←##.Reg.GetValue ##.HKEY_CURRENT_USER'Software\Microsoft\Windows NT\CurrentVersion\Devices'Device
     :AndIf Type≡##.REG_SZ
         Driver Output←{⍵{((⍵-1)↑⍺)(⍵↓⍺)}⍵⍳','}Value
     :Else
         Driver Output←'winspool' ''
     :EndIf
     Default←Device≡GetDefault
 :Case 2
     Device Driver←2↑Parms
     :If ','∊↑Value Type←##.Reg.GetValue ##.HKEY_CURRENT_USER'Software\Microsoft\Windows NT\CurrentVersion\Devices'Device
     :AndIf Type≡##.REG_SZ
         Output←{(⍵⍳',')↓⍵}Value
     :Else
         Output←''
     :EndIf
     Default←Device≡GetDefault
 :Case 3
     Device Driver Output←3↑Parms
     Default←Device≡GetDefault
 :Else
     Device Driver Output Default←4↑Parms
 :EndSelect
 Driver Device Output,←↑⎕AV
 DriverOffset DeviceOffset OutputOffset←+\8,↑∘⍴¨Driver Device
 DevNames←2 ##.TxtInt DriverOffset,DeviceOffset,OutputOffset,Default
 DevNames,←Driver,Device,Output
∇

∇ {ValidFlag}←Close hPrinter
     ⍝ Close the specified printer object
     ⍝
     ⍝ hPrinter = Handle to the specified printer or print server
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.ClosePrinter hPrinter
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hDC←CreateDC Parms;DeviceName;DriverName;DevMode
     ⍝ Create a device context (DC) for a device using the specified name
     ⍝
     ⍝ Parms[1] = DeviceName Printer's friendly name, eg 'PCL/HP LaserJet' or '' if the default printer is requested
     ⍝ Parms[2] = DevMode    (opt) DEVMODE structure (see #.Win.Printer.BuildDevMode or #.Win.Printer.ResolveDevMode for definition)
     ⍝ Parms[3] = DriverName (def 'WINSPOOL')
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     Parms←,⊂Parms
 :EndIf
 :Select ↑⍴Parms
 :Case 1
     :If ''≡DeviceName←↑Parms
         DeviceName←GetDefault
     :EndIf
     DevMode←GetDevMode DeviceName
     DriverName←'WINSPOOL'
 :Case 2
     DeviceName DevMode←Parms
     DriverName←'WINSPOOL'
 :Else
     DeviceName DevMode DriverName←3↑Parms
 :EndSelect
 :If 1<≡DevMode
     DevMode←BuildDevMode DevMode
 :EndIf
 :If ''≡DeviceName
     DeviceName←↑ResolveDevMode DevMode
 :EndIf
 DevMode←##.IntTxt DevMode
 :If ##.NULL≠hDC←##.CreateDC DriverName DeviceName 0 DevMode
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←DeleteDC hDC
     ⍝ Delete the specified device context (DC)
     ⍝
     ⍝ hDC = Handle to the device context, see #.Win.Printer.CreateDC
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.DeleteDC hDC
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ DevMode←EditDevMode DevMode;DeviceName;SpecVersion;DriverVersion;Size;DriverExtra;hwndOwner;hPrinter;sDevMode;Return;ValidFlag;ResolvedFlag
     ⍝ Edit printer settings
     ⍝
     ⍝ DevMode  = Device mode of a printer or if '', the user's default device mode for the default printer gets preloaded
     ⍝
     ⍝ If the user aborts the print dialog, DevMode becomes '' upon return
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :With 2 ⎕NQ'.' 'GetFocus'
     :If (⊂'Handle')∊⎕WG'PropList'
         hwndOwner←⎕WG'Handle'
     :Else
         hwndOwner←0
     :EndIf
 :EndWith
 :If ResolvedFlag←1<≡DevMode
     DeviceName SpecVersion DriverVersion Size DriverExtra←5↑DevMode
     DevMode←BuildDevMode DevMode
 :Else
     :If 0∊⍴DevMode
         DevMode←GetDevMode''
     :EndIf
     DeviceName SpecVersion DriverVersion Size DriverExtra←5↑ResolveDevMode DevMode
 :EndIf
 sDevMode←↑⍴DevMode
 :If ↑ValidFlag hPrinter←##.OpenPrinterI DeviceName 1 0
     :If sDevMode=##.DocumentPropertiesS hwndOwner hPrinter DeviceName 0 0 0
     :AndIf sDevMode=Size+DriverExtra
         DevMode←##.IntTxt DevMode
     :AndIf ##.IDOK=↑Return DevMode←##.DocumentProperties hwndOwner hPrinter DeviceName DevMode DevMode(##.DM_IN_BUFFER+##.DM_IN_PROMPT+##.DM_OUT_BUFFER)
         DevMode←##.TxtInt DevMode
         :If ResolvedFlag
             DevMode←ResolveDevMode DevMode
         :EndIf
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         DevMode←''
     :EndIf
     ValidFlag←##.ClosePrinter hPrinter
 :Else
     #.RCode←##.GetLastError
     DevMode←''
 :EndIf
∇

∇ Parms←EditMargins Parms;Margins;Top;Left;Bottom;Right;ValidFlag;ResolvedFlag;MarginsFlag;DevMode;sDevMode;hDevMode;DevNames;sDevNames;hDevNames;hwndOwner;DeviceName;SpecVersion;DriverVersion;Size;DriverExtra;PageSetupDlg;StructSize;Flags;PaperSize;MinMargin;Margin;hInstance;lCustData;lpfnPageSetupHook;lpfnPagePaintHook;lpPageSetupTemplateName;hPageSetupTemplate
     ⍝ Display a Page Setup dialog box to enable the user to specify the attributes of a printed page
     ⍝
     ⍝ Parms      = DevMode DEVMODE structure (see #.Win.Printer.BuildDevMode or #.Win.Printer.ResolveDevMode for definition)
     ⍝    or
     ⍝ Parms[1]   = DevMode DEVMODE structure (see #.Win.Printer.BuildDevMode or #.Win.Printer.ResolveDevMode for definition)
     ⍝ Parms[2]   = Margins (Top Left Bottom Right)
     ⍝
     ⍝ DevMode    = Device mode of a printer or if '', the user's default device mode for the default printer gets preloaded
     ⍝ Margins[1] = Top    def 0
     ⍝ Margins[2] = Left   def 0
     ⍝ Margins[3] = Bottom def 0
     ⍝ Margins[4] = Right  def 0
     ⍝
     ⍝ If the user aborts the print dialog, DevMode becomes '' upon return
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :With 2 ⎕NQ'.' 'GetFocus'
     :If (⊂'Handle')∊⎕WG'PropList'
         hwndOwner←⎕WG'Handle'
     :Else
         hwndOwner←0
     :EndIf
 :EndWith
 :If MarginsFlag←2=↑⍴Parms
     DevMode Margins←Parms
 :Else
     DevMode←Parms
 :EndIf
 :If ResolvedFlag←1<≡DevMode
     DeviceName SpecVersion DriverVersion Size DriverExtra←5↑DevMode
     DevMode←BuildDevMode DevMode
 :Else
     :If 0∊⍴DevMode
         DevMode←GetDevMode''
     :EndIf
     DeviceName SpecVersion DriverVersion Size DriverExtra←5↑ResolveDevMode DevMode
 :EndIf
 hDevMode←hDevNames←##.NULL
 :If ValidFlag←×sDevMode←↑⍴DevMode
 :AndIf ValidFlag←##.NULL≠hDevMode←##.Mem.Alloc-sDevMode
     DevMode ##.Mem.Write ##.Mem.Lock hDevMode
     ##.Mem.Unlock hDevMode
 :AndIf ValidFlag←×sDevNames←↑⍴DevNames←BuildDevNames DeviceName
 :AndIf ValidFlag←##.NULL≠hDevNames←##.Mem.Alloc-sDevNames
     DevNames ##.Mem.Write ##.Mem.Lock hDevNames
     ##.Mem.Unlock hDevNames
     :If MarginsFlag
         Flags←##.PSD_DEFAULTMINMARGINS+##.PSD_MARGINS+##.PSD_INHUNDREDTHSOFMILLIMETERS
         Top Left Bottom Right←4↑⌊0⌈65535⌊100×Margins
     :Else
         Flags←##.PSD_INHUNDREDTHSOFMILLIMETERS+##.PSD_DISABLEMARGINS
         Top Left Bottom Right←0
     :EndIf
     StructSize←84
     PaperSize←0 0
     MinMargin←0 0 0 0
     hInstance←lCustData←lpfnPageSetupHook←lpfnPagePaintHook←lpPageSetupTemplateName←hPageSetupTemplate←0
     Margin←Left Top Right Bottom
     PageSetupDlg←StructSize hwndOwner hDevMode hDevNames Flags PaperSize MinMargin Margin hInstance lCustData lpfnPageSetupHook lpfnPagePaintHook lpPageSetupTemplateName hPageSetupTemplate
 :AndIf ↑ValidFlag PageSetupDlg←##.PageSetupDlg⊂PageSetupDlg
     StructSize hwndOwner hDevMode hDevNames Flags PaperSize MinMargin Margin hInstance lCustData lpfnPageSetupHook lpfnPagePaintHook lpPageSetupTemplateName hPageSetupTemplate←PageSetupDlg
     Left Top Right Bottom←Margin
 :EndIf
 :If ##.NULL≠hDevNames
     ##.Mem.Free hDevNames
 :EndIf
 :If ##.NULL≠hDevMode
     DevMode←¯1 ##.Mem.Free hDevMode
     :If ResolvedFlag
         DevMode←ResolveDevMode DevMode
     :EndIf
 :Else
     DevMode←''
 :EndIf
 :If ValidFlag
 :Else
     DevMode←''
 :EndIf
 :If MarginsFlag
     Margins←0.01×Top Left Bottom Right
     Parms←DevMode Margins
 :Else
     Parms←DevMode
 :EndIf
∇

∇ Parms←EditPages Parms;InsertDefault;RemoveDefault;Pages;DevMode;sDevMode;hDevMode;DevNames;sDevNames;hDevNames;hwndOwner;ResolvedFlag;PagesFlag;DeviceName;SpecVersion;DriverVersion;Size;DriverExtra;Fields;Orientation;PaperSize;PaperLength;PaperWidth;Scale;Copies;Flags;FromPage;ToPage;MinPage;MaxPage;ValidFlag;PrintDlg;StructSize;hDC;hInstance;lCustData;lpfnPrintHook;lpfnSetupHook;lpPrintTemplateName;lpSetupTemplateName;hPrintTemplate;hSetupTemplate
     ⍝ Display a Print dialog box to enable the user to specify the properties of a particular print job
     ⍝
     ⍝ Parms    = DevMode DEVMODE structure (see #.Win.Printer.BuildDevMode or #.Win.Printer.ResolveDevMode for definition)
     ⍝    or
     ⍝ Parms[1] = DevMode DEVMODE structure (see #.Win.Printer.BuildDevMode or #.Win.Printer.ResolveDevMode for definition)
     ⍝ Parms[2] = Pages   (Flags FromPage ToPage MinPage MaxPage)
     ⍝
     ⍝ DevMode  = Device mode of a printer or if '', the user's default device mode for the default printer gets preloaded
     ⍝ Pages[1] = Flags    (#.Win.PD_ALLPAGES,#.Win.PD_SELECTION or #.Win.PD_PAGENUMS)+#.Win.PD_NOSELECTION+#.Win.PD_NOPAGENUMS+#.Win.PD_PRINTTOFILE+#.Win.PD_HIDEPRINTTOFILE
     ⍝ Pages[2] = FromPage def ⍬=undefined
     ⍝ Pages[3] = ToPage   def ⍬=undefined
     ⍝ Pages[4] = MinPage  def ⍬=undefined
     ⍝ Pages[5] = MaxPage  def ⍬=undefined
     ⍝
     ⍝ If the user aborts the print dialog, DevMode becomes '' upon return
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 InsertDefault←{⍬≡⍺:⍵ ⋄ ⌊1⌈65534⌊⍺}
 RemoveDefault←{⍺≡⍵:⍬ ⋄ ⍺}
 :With 2 ⎕NQ'.' 'GetFocus'
     :If (⊂'Handle')∊⎕WG'PropList'
         hwndOwner←⎕WG'Handle'
     :Else
         hwndOwner←0
     :EndIf
 :EndWith
 :If PagesFlag←2=↑⍴Parms
     DevMode Pages←Parms
 :Else
     DevMode←Parms
 :EndIf
 :If ResolvedFlag←1<≡DevMode
     DeviceName SpecVersion DriverVersion Size DriverExtra Fields Orientation PaperSize PaperLength PaperWidth Scale Copies←12↑DevMode
     DevMode←BuildDevMode DevMode
 :Else
     :If 0∊⍴DevMode
         DevMode←GetDevMode''
     :EndIf
     DeviceName SpecVersion DriverVersion Size DriverExtra Fields Orientation PaperSize PaperLength PaperWidth Scale Copies←12↑ResolveDevMode DevMode
 :EndIf
 hDevMode←hDevNames←##.NULL
 :If ValidFlag←×sDevMode←↑⍴DevMode
 :AndIf ValidFlag←##.NULL≠hDevMode←##.Mem.Alloc-sDevMode
     DevMode ##.Mem.Write ##.Mem.Lock hDevMode
     ##.Mem.Unlock hDevMode
 :AndIf ValidFlag←×sDevNames←↑⍴DevNames←BuildDevNames DeviceName
 :AndIf ValidFlag←##.NULL≠hDevNames←##.Mem.Alloc-sDevNames
     DevNames ##.Mem.Write ##.Mem.Lock hDevNames
     ##.Mem.Unlock hDevNames
     Flags FromPage ToPage MinPage MaxPage←(##.PD_ALLPAGES+##.PD_NOSELECTION+##.PD_NOPAGENUMS)⍬ ⍬ ⍬ ⍬
     :If PagesFlag
         Flags FromPage ToPage MinPage MaxPage←5↑Pages,(×/⍴Pages)↓Flags FromPage ToPage MinPage MaxPage
     :EndIf
     Flags∧##.Bitwise←##.PD_ALLPAGES+##.PD_SELECTION+##.PD_PAGENUMS+##.PD_NOSELECTION+##.PD_NOPAGENUMS+##.PD_PRINTTOFILE+##.PD_HIDEPRINTTOFILE
     Flags∨##.Bitwise←##.PD_USEDEVMODECOPIESANDCOLLATE
     FromPage ToPage MinPage MaxPage InsertDefault←65535 65535 0 65535
     MaxPage⌈←MinPage
     ToPage⌈←FromPage
     ToPage FromPage←MaxPage⌊MinPage⌈ToPage FromPage
     StructSize←66
     hDC←0
     hInstance←lCustData←0
     lpfnPrintHook←lpPrintTemplateName←hPrintTemplate←0
     lpfnSetupHook←lpSetupTemplateName←hSetupTemplate←0
     PrintDlg←StructSize hwndOwner hDevMode hDevNames hDC Flags FromPage ToPage MinPage MaxPage Copies hInstance lCustData lpfnPrintHook lpfnSetupHook lpPrintTemplateName lpSetupTemplateName hPrintTemplate hSetupTemplate
 :AndIf ↑ValidFlag PrintDlg←##.PrintDlg⊂PrintDlg
     StructSize hwndOwner hDevMode hDevNames hDC Flags FromPage ToPage MinPage MaxPage Copies hInstance lCustData lpfnPrintHook lpfnSetupHook lpPrintTemplateName lpSetupTemplateName hPrintTemplate hSetupTemplate←PrintDlg
 :EndIf
 :If ##.NULL≠hDevNames
     ##.Mem.Free hDevNames
 :EndIf
 :If ##.NULL≠hDevMode
     DevMode←¯1 ##.Mem.Free hDevMode
     :If ResolvedFlag
         DevMode←ResolveDevMode DevMode
     :EndIf
 :Else
     DevMode←''
 :EndIf
 :If ValidFlag
 :Else
     DevMode←''
 :EndIf
 :If PagesFlag
     Flags∧##.Bitwise←##.PD_ALLPAGES+##.PD_SELECTION+##.PD_PAGENUMS+##.PD_NOSELECTION+##.PD_NOPAGENUMS+##.PD_PRINTTOFILE+##.PD_HIDEPRINTTOFILE
     FromPage ToPage MinPage MaxPage RemoveDefault←65535 65535 0 65535
     Pages←Flags FromPage ToPage MinPage MaxPage
     Parms←DevMode Pages
 :Else
     Parms←DevMode
 :EndIf
∇

∇ {ValidFlag}←EndDoc hDC
     ⍝ End a print job
     ⍝
     ⍝ hDC = Handle to the device context for the print job, must be the same as on #.Win.Printer.StartDoc
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←0<##.EndDoc hDC
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←EndDocPrinter hPrinter
     ⍝ End print job for the specified printer
     ⍝
     ⍝ hPrinter = Handle to the specified printer or print server
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.EndDocPrinter hPrinter
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←EndPage hDC
     ⍝ Notify the device that the application has finished writing to a page
     ⍝
     ⍝ hDC = Handle to the device context for the print job, must be the same as on #.Win.Printer.StartDoc
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←0<##.EndPage hDC
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←EndPagePrinter hPrinter
     ⍝ Notify print spooler that the application is at the end of page in a print job
     ⍝
     ⍝ hPrinter = Handle to the specified printer or print server
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.EndPagePrinter hPrinter
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Printers←Enum Parms;Flags;Name;TStrAtPtr;Level;pPrinters;sPrinters;cPrinters;ValidFlag;pPrinterName;pServerName;pPortName;Attributes;DeviceNotSelectedTimeout;TransmissionRetryTimeout;PrinterName;ServerName;PortName;RCode
     ⍝ Enumerate available printers, print servers, domains, or print providers
     ⍝
     ⍝ If Flags ∊ #.Win.PRINTER_ENUM_LOCAL+#.Win.PRINTER_ENUM_CONNECTIONS
     ⍝
     ⍝ Parms        = Flags
     ⍝
     ⍝ Printers[;1] = PrinterName
     ⍝ Printers[;2] = ServerName
     ⍝ Printers[;3] = Attributes
     ⍝
     ⍝ If Flags = #.Win.PRINTER_ENUM_NAME
     ⍝
     ⍝ Parms[1]     = Flags
     ⍝ Parms[2]     = ServerName (eg '\\P29220E0')
     ⍝
     ⍝ Printers[;1] = PrinterName
     ⍝ Printers[;2] = PortName
     ⍝ Printers[;3] = Attributes
     ⍝ Printers[;4] = DeviceNotSelectedTimeout
     ⍝ Printers[;5] = TransmissionRetryTimeout
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 TStrAtPtr←{⍵>0:{(¯1+⍵⍳↑⎕AV)↑⍵}⍵↓⍺ ⋄ ''}
 :Select ↑⍴,Parms
 :CaseList 0 1
     Flags←↑Parms
     Name←''
 :Else
     Flags Name←2↑Parms
 :EndSelect
 :If 0=Flags
     Flags←##.PRINTER_ENUM_LOCAL+##.PRINTER_ENUM_CONNECTIONS
 :EndIf
 :If Flags∨.∧##.Bitwise ##.PRINTER_ENUM_LOCAL+##.PRINTER_ENUM_CONNECTIONS
     Level←4
 :Else
     Level←5
 :EndIf
 :If 0∊⍴Name
     :If ~↑ValidFlag sPrinters cPrinters←##.EnumPrintersI Flags 0 Level 0 0 1 1
     :AndIf ValidFlag←##.ERROR_INSUFFICIENT_BUFFER=##.GetLastError
     :AndIf ValidFlag←##.NULL≠pPrinters←##.Mem.Alloc sPrinters
         :If ↑ValidFlag sPrinters cPrinters←##.EnumPrintersI Flags 0 Level pPrinters sPrinters 1 1
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
         :EndIf
         RCode←#.RCode ⋄ Printers←sPrinters ##.Mem.Free pPrinters ⋄ :If RCode≠#.Win.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :ElseIf ~↑ValidFlag sPrinters cPrinters←##.EnumPrinters Flags Name Level 0 0 1 1
 :AndIf ValidFlag←##.ERROR_INSUFFICIENT_BUFFER=##.GetLastError
 :AndIf ValidFlag←##.NULL≠pPrinters←##.Mem.Alloc sPrinters
     :If ↑ValidFlag sPrinters cPrinters←##.EnumPrinters Flags Name Level pPrinters sPrinters 1 1
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
     RCode←#.RCode ⋄ Printers←sPrinters ##.Mem.Free pPrinters ⋄ :If RCode≠#.Win.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
 :Else
     #.RCode←##.GetLastError
 :EndIf
 :Select Level
 :Case 4
     :If ValidFlag
     :AndIf 0<cPrinters
         pPrinterName pServerName Attributes←⊂[1]4 ##.IntTxt cPrinters 12⍴Printers
         PrinterName ServerName←Printers∘TStrAtPtr¨¨0⌈pPrinterName pServerName-pPrinters
         Printers←⊃[1]PrinterName ServerName Attributes
     :Else
         Printers←0 3⍴⊂''
     :EndIf
 :Case 5
     :If ValidFlag
     :AndIf 0<cPrinters
         pPrinterName pPortName Attributes DeviceNotSelectedTimeout TransmissionRetryTimeout←⊂[1]4 ##.IntTxt cPrinters 20⍴Printers
         PrinterName PortName←Printers∘TStrAtPtr¨¨0⌈pPrinterName pPortName-pPrinters
         Printers←⊃[1]PrinterName PortName Attributes DeviceNotSelectedTimeout TransmissionRetryTimeout
     :Else
         Printers←0 5⍴⊂''
     :EndIf
 :EndSelect
∇

∇ JobInfo←{JobInfoLevel}EnumJobs hPrinter;TStrAtPtr;DevModeAtPtr;SystemTimeToQuadTS;PrinterInfoLevel;PrinterInfo;sPrinterInfo;ValidFlag;OpenedFlag;FirstJob;sJobInfo;pJobInfo;pServerName;pPrinterName;pShareName;pPortName;pDriverName;pComment;pLocation;pDevMode;pSepFile;pPrintProcessor;pDatatype;pParameters;pSecurityDescriptor;Attributes;Priority;DefaultPriority;StartTime;UntilTime;Status;cJobs;AveragePPM;JobId;pMachineName;pUserName;pDocument;pNotifyName;pStatusText;Position;TotalPages;Size;Submitted;Year;Month;DayOfWeek;Day;Hour;Minute;Second;Milliseconds;Time;PagesPrinted;PrinterName;MachineName;UserName;Document;NotifyName;Datatype;PrintProcessor;Parameters;DriverName;DevMode;StatusText;SecurityDescriptor
     ⍝ Retrieve information about print jobs for a specified printer
     ⍝
     ⍝ hPrinter     = Handle to the specified printer or printer's friendly name of '' for the default printer
     ⍝ JobInfoLevel = 1 (def) or 2
     ⍝
     ⍝ If JobInfoLevel=1:
     ⍝ JobInfo[;1]  = JobId
     ⍝ JobInfo[;2]  = PrinterName
     ⍝ JobInfo[;3]  = MachineName
     ⍝ JobInfo[;4]  = UserName
     ⍝ JobInfo[;5]  = Document
     ⍝ JobInfo[;6]  = Datatype
     ⍝ JobInfo[;7]  = StatusText
     ⍝ JobInfo[;8]  = Status
     ⍝ JobInfo[;9]  = Priority
     ⍝ JobInfo[;10] = Position
     ⍝ JobInfo[;11] = TotalPages
     ⍝ JobInfo[;12] = PagesPrinted
     ⍝ JobInfo[;13] = Submitted
     ⍝
     ⍝ If JobInfoLevel=2:
     ⍝ JobInfo[;1]  = JobId
     ⍝ JobInfo[;2]  = PrinterName
     ⍝ JobInfo[;3]  = MachineName
     ⍝ JobInfo[;4]  = UserName
     ⍝ JobInfo[;5]  = Document
     ⍝ JobInfo[;6]  = NotifyName
     ⍝ JobInfo[;7]  = Datatype
     ⍝ JobInfo[;8]  = PrintProcessor
     ⍝ JobInfo[;9]  = Parameters
     ⍝ JobInfo[;10] = DriverName
     ⍝ JobInfo[;11] = DevMode
     ⍝ JobInfo[;12] = StatusText
     ⍝ JobInfo[;13] = SecurityDescriptor
     ⍝ JobInfo[;14] = Status
     ⍝ JobInfo[;15] = Priority
     ⍝ JobInfo[;16] = Position
     ⍝ JobInfo[;17] = StartTime
     ⍝ JobInfo[;18] = UntilTime
     ⍝ JobInfo[;19] = TotalPages
     ⍝ JobInfo[;20] = Size
     ⍝ JobInfo[;21] = Submitted
     ⍝ JobInfo[;22] = Time
     ⍝ JobInfo[;23] = PagesPrinted
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 :If 0=⎕NC'JobInfoLevel'
     JobInfoLevel←1
 :EndIf
 ##.Init
 TStrAtPtr←{⍵>0:{(¯1+⍵⍳↑⎕AV)↑⍵}⍵↓⍺ ⋄ ''}
 DevModeAtPtr←{⍵>0:{(+/3↓(5↑##.DEVMODE)##.SplitTxtStruct ⍵)↑⍵}⍵↓⍺ ⋄ ''}
 SystemTimeToQuadTS←{1 1 0 1 1 1 1 1/2⊃##.FileTimeToSystemTime ⍵ 1}∘{2⊃##.FileTimeToLocalFileTime ⍵ 1}∘{2⊃##.SystemTimeToFileTime ⍵ 1}
 PrinterInfoLevel←2
 :If ValidFlag←82≠⎕DR hPrinter
     OpenedFlag←0
 :Else
     :If ''≡hPrinter
         hPrinter←GetDefault
     :EndIf
     :If ↑ValidFlag hPrinter←##.OpenPrinterI hPrinter 1 ##.NULL
         OpenedFlag←1
     :EndIf
 :EndIf
 :If ValidFlag
     :If ~↑ValidFlag sPrinterInfo←##.GetPrinterI hPrinter PrinterInfoLevel 0 0 1
     :AndIf ValidFlag←##.ERROR_INSUFFICIENT_BUFFER=##.GetLastError
     :AndIf ↑ValidFlag PrinterInfo sPrinterInfo←##.GetPrinter hPrinter PrinterInfoLevel sPrinterInfo sPrinterInfo 1
         pServerName pPrinterName pShareName pPortName pDriverName pComment pLocation pDevMode pSepFile pPrintProcessor pDatatype pParameters pSecurityDescriptor Attributes Priority DefaultPriority StartTime UntilTime Status cJobs AveragePPM←4 ##.IntTxt 84↑PrinterInfo
         #.RCode←##.ERROR_SUCCESS
     :AndIf ValidFlag←0<cJobs
         FirstJob←0
         :If ~↑ValidFlag sJobInfo←2↑##.EnumJobsI hPrinter FirstJob cJobs JobInfoLevel 0 0 1 1
         :AndIf ValidFlag←##.ERROR_INSUFFICIENT_BUFFER=##.GetLastError
         :AndIf ValidFlag←##.NULL≠pJobInfo←##.Mem.Alloc sJobInfo
             ValidFlag sJobInfo cJobs←##.EnumJobsI hPrinter FirstJob cJobs JobInfoLevel pJobInfo sJobInfo 1 1
             JobInfo←sJobInfo ##.Mem.Free pJobInfo
         :EndIf
     :Else
         #.RCode←##.GetLastError
     :EndIf
     :If OpenedFlag
         ValidFlag∧←##.ClosePrinter hPrinter
     :EndIf
 :Else
     #.RCode←##.GetLastError
 :EndIf
 :Select JobInfoLevel
 :Case 1
     :If ValidFlag
         JobId pPrinterName pMachineName pUserName pDocument pDatatype pStatusText Status Priority Position TotalPages PagesPrinted Year Month DayOfWeek Day Hour Minute Second Milliseconds←⊂[1]⊃4 4 4 4 4 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2∘##.SplitBinStruct¨⊂[2]cJobs 64⍴JobInfo
         PrinterName MachineName UserName Document Datatype StatusText←JobInfo∘TStrAtPtr¨¨0⌈pPrinterName pMachineName pUserName pDocument pDatatype pStatusText-pJobInfo
         Submitted←SystemTimeToQuadTS¨⊂[1]⊃Year Month DayOfWeek Day Hour Minute Second Milliseconds
         JobInfo←⊃[1]JobId PrinterName MachineName UserName Document Datatype StatusText Status Priority Position TotalPages PagesPrinted Submitted
     :Else
         JobInfo←0 13⍴⊂⍬
     :EndIf
 :Case 2
     :If ValidFlag
         JobId pPrinterName pMachineName pUserName pDocument pNotifyName pDatatype pPrintProcessor pParameters pDriverName pDevMode pStatusText pSecurityDescriptor Status Priority Position StartTime UntilTime TotalPages Size Year Month DayOfWeek Day Hour Minute Second Milliseconds Time PagesPrinted←⊂[1]⊃4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2 4 4∘##.SplitBinStruct¨⊂[2]cJobs 104⍴JobInfo
         PrinterName MachineName UserName Document NotifyName Datatype PrintProcessor Parameters DriverName StatusText SecurityDescriptor←JobInfo∘TStrAtPtr¨¨0⌈pPrinterName pMachineName pUserName pDocument pNotifyName pDatatype pPrintProcessor pParameters pDriverName pStatusText pSecurityDescriptor-pJobInfo
         DevMode←JobInfo∘DevModeAtPtr¨0⌈pDevMode-pJobInfo
         Submitted←SystemTimeToQuadTS¨⊂[1]⊃Year Month DayOfWeek Day Hour Minute Second Milliseconds
         JobInfo←⊃[1]JobId PrinterName MachineName UserName Document NotifyName Datatype PrintProcessor Parameters DriverName DevMode StatusText SecurityDescriptor Status Priority Position StartTime UntilTime TotalPages Size Submitted Time PagesPrinted
     :Else
         JobInfo←0 23⍴⊂⍬
     :EndIf
 :EndSelect
∇

∇ DeviceName←GetDefault;Value;Type
     ⍝ Retrieve the name of the default printer for the current user on the local computer
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ','∊↑Value Type←##.Reg.GetValue #.Win.HKEY_CURRENT_USER'Software\Microsoft\Windows NT\CurrentVersion\Windows' 'Device'
 :AndIf Type≡##.REG_SZ
     DeviceName←{(¯1+⍵⍳',')↑⍵}Value
 :Else
     DeviceName←''
 :EndIf
     ⍝:If ↑ValidFlag DeviceName sDeviceName←##.GetDefaultPrinter 256 256
     ⍝    DeviceName←sDeviceName↑DeviceName
     ⍝    #.RCode←##.ERROR_SUCCESS
     ⍝:Else
     ⍝    #.RCode←##.GetLastError
     ⍝    DeviceName←''
     ⍝:EndIf
∇

∇ DevMode←GetDevMode DeviceName;hPrinter;Level;PrinterInfo;pPrinterInfo;sPrinterInfo;sDevMode;SpecVersion;DriverVersion;Size;DriverExtra;ValidFlag;pServerName;pPrinterName;pShareName;pPortName;pDriverName;pComment;pLocation;pDevMode;pSepFile;pPrintProcessor;pDatatype;pParameters;pSecurityDescriptor;Attributes;Priority;DefaultPriority;StartTime;UntilTime;Status;cJobs;AveragePPM
     ⍝ Get the current printer user setting's DevMode
     ⍝
     ⍝ DeviceName = Printer's friendly name, eg 'PCL/HP LaserJet' or '' if the default printer is requested
     ⍝ DevMode    = DEVMODE structure
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 Level←2
 :If 0∊⍴DeviceName
     DeviceName←GetDefault
 :EndIf
 :If ↑ValidFlag hPrinter←##.OpenPrinterI DeviceName 1 ##.NULL
     :If ~↑ValidFlag sPrinterInfo←##.GetPrinterI hPrinter Level 0 0 1
     :AndIf ValidFlag←##.ERROR_INSUFFICIENT_BUFFER=##.GetLastError
     :AndIf ##.NULL≠pPrinterInfo←##.Mem.Alloc sPrinterInfo
         :If ↑ValidFlag sPrinterInfo←##.GetPrinterI hPrinter Level pPrinterInfo sPrinterInfo 1
             PrinterInfo←sPrinterInfo ##.Mem.Read pPrinterInfo
             pServerName pPrinterName pShareName pPortName pDriverName pComment pLocation pDevMode pSepFile pPrintProcessor pDatatype pParameters pSecurityDescriptor Attributes Priority DefaultPriority StartTime UntilTime Status cJobs AveragePPM←4 ##.IntTxt 84↑PrinterInfo
             pServerName pPrinterName pShareName pPortName pDriverName pComment pLocation pDevMode pSepFile pPrintProcessor pDatatype pParameters pSecurityDescriptor{0⌈⍺-⍵}←pPrinterInfo
             DeviceName SpecVersion DriverVersion Size DriverExtra←(5↑##.DEVMODE)##.SplitTxtStruct pDevMode↓PrinterInfo
             sDevMode←Size+DriverExtra
             DevMode←sDevMode↑pDevMode↓PrinterInfo
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
             DevMode←''
         :EndIf
         ##.Mem.Free pPrinterInfo
     :Else
         #.RCode←##.GetLastError
         DevMode←''
     :EndIf
     ValidFlag←##.ClosePrinter hPrinter
 :Else
     #.RCode←##.GetLastError
     DevMode←''
 :EndIf
∇

∇ Status←GetJobStatus Parms;hPrinter;JobId;Level;JobInfo;sJobInfo;ValidFlag;OpenedFlag;pPrinterName;pMachineName;pUserName;pDocument;pDatatype;pStatus
     ⍝ Get the status of a single job on a printer queue
     ⍝
     ⍝ Parms[1] = hPrinter Handle to the specified printer or printer's friendly name or '' if the default printer is requested
     ⍝ Parms[2] = JobId    Value returned from #.Win.Printer.StartDocPrinter or (#.Win.Printer.EnumJobs '')[;1]
     ⍝
     ⍝ Status   = Addition of these states:
     ⍝            #.Win.JOB_STATUS_PAUSED←1
     ⍝            #.Win.JOB_STATUS_ERROR←2
     ⍝            #.Win.JOB_STATUS_DELETING←4
     ⍝            #.Win.JOB_STATUS_SPOOLING←8
     ⍝            #.Win.JOB_STATUS_PRINTING←16
     ⍝            #.Win.JOB_STATUS_OFFLINE←32
     ⍝            #.Win.JOB_STATUS_PAPEROUT←64
     ⍝            #.Win.JOB_STATUS_PRINTED←128
     ⍝            #.Win.JOB_STATUS_DELETED←256
     ⍝            #.Win.JOB_STATUS_BLOCKED_DEVQ←512
     ⍝            #.Win.JOB_STATUS_USER_INTERVENTION←1024
     ⍝            #.Win.JOB_STATUS_RESTART←2048
     ⍝            #.Win.JOB_STATUS_COMPLETE←4096
     ⍝            .. or ¯1 upon error (see #.RCode #.RText)
     ⍝
     ⍝            #.Win.JOB_CONTROL_PAUSE←1
     ⍝            #.Win.JOB_CONTROL_RESUME←2
     ⍝            #.Win.JOB_CONTROL_CANCEL←3
     ⍝            #.Win.JOB_CONTROL_RESTART←4
     ⍝            #.Win.JOB_CONTROL_DELETE←5
     ⍝            #.Win.JOB_CONTROL_SENT_TO_PRINTER←6
     ⍝            #.Win.JOB_CONTROL_LAST_PAGE_EJECTED←7
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hPrinter JobId←2↑Parms
 Level←1
 :If ValidFlag←82≠⎕DR hPrinter
     OpenedFlag←0
 :Else
     :If ''≡hPrinter
         hPrinter←GetDefault
     :EndIf
     :If ↑ValidFlag hPrinter←##.OpenPrinterI hPrinter 1 ##.NULL
         OpenedFlag←1
     :EndIf
 :EndIf
 :If ValidFlag
     :If ~↑ValidFlag sJobInfo←##.GetJobI hPrinter JobId Level 0 0 1
     :AndIf ValidFlag←##.ERROR_INSUFFICIENT_BUFFER=##.GetLastError
     :AndIf ↑ValidFlag JobInfo sJobInfo←##.GetJob hPrinter JobId Level sJobInfo sJobInfo 1
         JobId pPrinterName pMachineName pUserName pDocument pDatatype pStatus Status←4 ##.IntTxt 32↑JobInfo
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         Status←¯1
     :EndIf
     :If OpenedFlag
         ValidFlag∧←##.ClosePrinter hPrinter
     :EndIf
 :Else
     #.RCode←##.GetLastError
     Status←¯1
 :EndIf
∇

∇ Retrn←GetPNameAndOrientation Parms;Pages;DevMode;Flags;PrintToFile;PName;DeviceName;SpecVersion;DriverVersion;Size;DriverExtra;Fields;Orientation;Driver;OutputPort
     ⍝ Retrieve the ⎕WC'Printer' PName and Orientation parameters from the result of #.Win.Printer.EditSelect
     ⍝
     ⍝ Parms    = DevMode DEVMODE structure (see #.Win.Printer.BuildDevMode or #.Win.Printer.ResolveDevMode for definition)
     ⍝    or
     ⍝ Parms[1] = DevMode DEVMODE structure (see #.Win.Printer.BuildDevMode or #.Win.Printer.ResolveDevMode for definition)
     ⍝ Parms[2] = Pages   (Flags ..) #.Win.PD_PRINTTOFILE
     ⍝
     ⍝ Retrn[1] = PName
     ⍝ Retrn[2] = Orientation
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2=↑⍴Parms
     DevMode Pages←Parms
     Flags←↑Pages
     PrintToFile←Flags∨.∧##.Bitwise ##.PD_PRINTTOFILE
 :Else
     DevMode←Parms
     PrintToFile←0
 :EndIf
 :If 1<≡DevMode
     DeviceName SpecVersion DriverVersion Size DriverExtra Fields Orientation←7↑DevMode
     DevMode←BuildDevMode DevMode
 :Else
     :If 0∊⍴DevMode
         DevMode←GetDevMode''
     :EndIf
     DeviceName SpecVersion DriverVersion Size DriverExtra Fields Orientation←7↑ResolveDevMode DevMode
 :EndIf
 :If PrintToFile
     OutputPort←'FILE:'
 :Else
     DeviceName Driver OutputPort←3↑ResolveDevNames BuildDevNames DeviceName
 :EndIf
 PName←DeviceName,',',OutputPort
 :Select Orientation
 :Case ##.DMORIENT_PORTRAIT
     Orientation←'Portrait'
 :Case ##.DMORIENT_LANDSCAPE
     Orientation←'Landscape'
 :Else
     Orientation←''
 :EndSelect
 Retrn←PName Orientation
∇

∇ PortName←GetPortName hPrinter;Level;PrinterInfo;pPrinterInfo;sPrinterInfo;OpenedFlag;ValidFlag;pServerName;pPrinterName;pShareName;pPortName;pDriverName;pComment;pLocation;pDevMode;pSepFile;pPrintProcessor;pDatatype;pParameters;pSecurityDescriptor;Attributes;Priority;DefaultPriority;StartTime;UntilTime;Status;cJobs;AveragePPM
     ⍝ Get the current printer user setting's PortName
     ⍝
     ⍝ hPrinter = Handle to the specified printer or printer's friendly name or '' if the default printer is requested
     ⍝ PortName = Name of the port where printer is connected
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←82≠⎕DR hPrinter
     OpenedFlag←0
 :Else
     :If ''≡hPrinter
         hPrinter←GetDefault
     :EndIf
     :If ↑ValidFlag hPrinter←##.OpenPrinterI hPrinter 1 ##.NULL
         OpenedFlag←1
     :EndIf
 :EndIf
 Level←2
 :If ValidFlag
     :If ~↑ValidFlag sPrinterInfo←##.GetPrinterI hPrinter Level 0 0 1
     :AndIf ValidFlag←##.ERROR_INSUFFICIENT_BUFFER=##.GetLastError
     :AndIf ##.NULL≠pPrinterInfo←##.Mem.Alloc sPrinterInfo
         :If ↑ValidFlag sPrinterInfo←##.GetPrinterI hPrinter Level pPrinterInfo sPrinterInfo 1
             PrinterInfo←sPrinterInfo ##.Mem.Read pPrinterInfo
             pServerName pPrinterName pShareName pPortName pDriverName pComment pLocation pDevMode pSepFile pPrintProcessor pDatatype pParameters pSecurityDescriptor Attributes Priority DefaultPriority StartTime UntilTime Status cJobs AveragePPM←4 ##.IntTxt 84↑PrinterInfo
             pServerName pPrinterName pShareName pPortName pDriverName pComment pLocation pDevMode pSepFile pPrintProcessor pDatatype pParameters pSecurityDescriptor{0⌈⍺-⍵}←pPrinterInfo
             PortName←{(¯1+⍵⍳↑⎕AV)↑⍵}pPortName↓PrinterInfo
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
             PortName←''
         :EndIf
         ##.Mem.Free pPrinterInfo
     :Else
         #.RCode←##.GetLastError
         PortName←''
     :EndIf
     :If OpenedFlag
         ValidFlag∧←##.ClosePrinter hPrinter
     :EndIf
 :Else
     #.RCode←##.GetLastError
     PortName←''
 :EndIf
∇

∇ Status←GetStatus hPrinter;Level;PrinterInfo;sPrinterInfo;ValidFlag;OpenedFlag;pServerName;pPrinterName;pShareName;pPortName;pDriverName;pComment;pLocation;pDevMode;pSepFile;pPrintProcessor;pDatatype;pParameters;pSecurityDescriptor;Attributes;Priority;DefaultPriority;StartTime;UntilTime;cJobs;AveragePPM
     ⍝ Get the current printer user setting's DevMode
     ⍝
     ⍝ hPrinter = Handle to the specified printer or printer's friendly name or '' if the default printer is requested
     ⍝
     ⍝ Status   = Addition of these states:
     ⍝            #.Win.PRINTER_STATUS_PAUSED            Angehalten
     ⍝            #.Win.PRINTER_STATUS_ERROR             Fehler
     ⍝            #.Win.PRINTER_STATUS_PENDING_DELETION  Druckauftrag wird gelöscht
     ⍝            #.Win.PRINTER_STATUS_PAPER_JAM         Papierstau
     ⍝            #.Win.PRINTER_STATUS_PAPER_OUT         Kein Papier
     ⍝            #.Win.PRINTER_STATUS_MANUAL_FEED       Mauelle Papierzufuhr notwendig
     ⍝            #.Win.PRINTER_STATUS_PAPER_PROBLEM     Problem mit der Papierzufuhr
     ⍝            #.Win.PRINTER_STATUS_OFFLINE           Offline
     ⍝            #.Win.PRINTER_STATUS_IO_ACTIVE         EA aktiv
     ⍝            #.Win.PRINTER_STATUS_BUSY              Ausgelastet
     ⍝            #.Win.PRINTER_STATUS_PRINTING          Wird gedruckt
     ⍝            #.Win.PRINTER_STATUS_OUTPUT_BIN_FULL   Ausgabefach voll
     ⍝            #.Win.PRINTER_STATUS_NOT_AVAILABLE     Nicht verfügbar
     ⍝            #.Win.PRINTER_STATUS_WAITING           Warten
     ⍝            #.Win.PRINTER_STATUS_PROCESSING        Verarbeitung
     ⍝            #.Win.PRINTER_STATUS_INITIALIZING      Initialisierung
     ⍝            #.Win.PRINTER_STATUS_WARMING_UP        Anlaufen
     ⍝            #.Win.PRINTER_STATUS_TONER_LOW         Niedriger Tonerstand
     ⍝            #.Win.PRINTER_STATUS_NO_TONER          Kein Toner
     ⍝            #.Win.PRINTER_STATUS_PAGE_PUNT         Papierverwurf
     ⍝            #.Win.PRINTER_STATUS_USER_INTERVENTION Benutzereingriff notwendig
     ⍝            #.Win.PRINTER_STATUS_OUT_OF_MEMORY     Kein Arbeitspeicher
     ⍝            #.Win.PRINTER_STATUS_DOOR_OPEN         Gerät offen
     ⍝            #.Win.PRINTER_STATUS_SERVER_UNKNOWN    Serverzustand unbekannt
     ⍝            #.Win.PRINTER_STATUS_POWER_SAVE        Stromsparmodus
     ⍝            .. or ¯1 upon error (see #.RCode #.RText)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 Level←2
 :If ValidFlag←82≠⎕DR hPrinter
     OpenedFlag←0
 :Else
     :If ''≡hPrinter
         hPrinter←GetDefault
     :EndIf
     :If ↑ValidFlag hPrinter←##.OpenPrinterI hPrinter 1 ##.NULL
         OpenedFlag←1
     :EndIf
 :EndIf
 :If ValidFlag
     :If ~↑ValidFlag sPrinterInfo←##.GetPrinterI hPrinter Level 0 0 1
     :AndIf ValidFlag←##.ERROR_INSUFFICIENT_BUFFER=##.GetLastError
     :AndIf ↑ValidFlag PrinterInfo sPrinterInfo←##.GetPrinter hPrinter Level sPrinterInfo sPrinterInfo 1
         pServerName pPrinterName pShareName pPortName pDriverName pComment pLocation pDevMode pSepFile pPrintProcessor pDatatype pParameters pSecurityDescriptor Attributes Priority DefaultPriority StartTime UntilTime Status cJobs AveragePPM←4 ##.IntTxt 84↑PrinterInfo
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         Status←¯1
     :EndIf
     :If OpenedFlag
         ValidFlag∧←##.ClosePrinter hPrinter
     :EndIf
 :Else
     #.RCode←##.GetLastError
     Status←¯1
 :EndIf
∇

∇ Params←LoadParams KeyPath;RemoveDefault;DevMode;DeviceName;SpecVersion;DriverVersion;Size;DriverExtra;Pages;Margins;Flags;FromPage;ToPage;MinPage;MaxPage;Margin;Left;Top;Right;Bottom;ValidFlag;hKeyPath;Type
     ⍝ Load printer parameters (DevMode Pages Margins) from the given user's registry KeyPath
     ⍝
     ⍝ KeyPath   =          Should be 'Software\[Manufacturer]\[Application]\[Formname]'
     ⍝ Params[1] = DevMode  1.Argument for #.Win.Printer.EditDevMode, #.Win.Printer.EditMargins, #.Win.Printer.EditPages or #.Win.Printer.SetDevMode or #.Win.Printer.GetPNameAndOrientation
     ⍝ Params[2] = Pages    2.Argument for #.Win.Printer.EditPages or #.Win.Printer.GetPNameAndOrientation
     ⍝ Params[3] = Margins  2.Argument for #.Win.Printer.EditMargins
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 RemoveDefault←{⍺≡⍵:⍬ ⋄ ⍺}
 :If ValidFlag←##.INVALID_HANDLE_VALUE≠hKeyPath←##.Reg.OpenKey ##.HKEY_CURRENT_USER KeyPath ##.KEY_READ
 :AndIf ##.REG_BINARY=2⊃DevMode Type←##.Reg.GetValue hKeyPath'DevMode'
     DeviceName SpecVersion DriverVersion Size DriverExtra←5↑ResolveDevMode DevMode
 :AndIf (↑⍴DevMode)=Size+DriverExtra
 :Else
     DevMode←GetDevMode''
 :EndIf
 :If ValidFlag
 :AndIf ##.REG_BINARY=2⊃Pages Type←##.Reg.GetValue hKeyPath'Pages'
 :AndIf 12=↑⍴Pages
     Flags FromPage ToPage MinPage MaxPage←4 2 2 2 2 ##.SplitBinStruct Pages
     Flags∧##.Bitwise←##.PD_ALLPAGES+##.PD_SELECTION+##.PD_PAGENUMS+##.PD_NOSELECTION+##.PD_NOPAGENUMS+##.PD_PRINTTOFILE+##.PD_HIDEPRINTTOFILE
     FromPage ToPage MinPage MaxPage←65536|FromPage ToPage MinPage MaxPage
     MaxPage⌈←MinPage
     ToPage⌈←FromPage
     ToPage FromPage←MaxPage⌊MinPage⌈ToPage FromPage
     FromPage ToPage MinPage MaxPage RemoveDefault←65535 65535 0 65535
 :Else
     Flags FromPage ToPage MinPage MaxPage←(##.PD_ALLPAGES+##.PD_NOSELECTION+##.PD_NOPAGENUMS)⍬ ⍬ ⍬ ⍬
 :EndIf
 Pages←Flags FromPage ToPage MinPage MaxPage
 :If ValidFlag
 :AndIf ##.REG_BINARY=2⊃Margin Type←##.Reg.GetValue hKeyPath'Margin'
 :AndIf 8=↑⍴Margin
     Left Top Right Bottom←2 2 2 2 ##.SplitBinStruct Margin
     Left Top Right Bottom←65536|Left Top Right Bottom
 :Else
     Left Top Right Bottom←2000 2000 2000 2000
 :EndIf
 :If ValidFlag
     ##.Reg.CloseKey hKeyPath
 :EndIf
 Margins←0.01×Top Left Bottom Right
 Params←DevMode Pages Margins
∇

∇ hPrinter←Open Parms;PrinterName;DesiredAccess;pDatatype;pDevMode;ValidFlag
     ⍝ Retrieve a handle to the specified printer or print server
     ⍝
     ⍝ Parms[1] = PrinterName   Name of the printer or print server or '' if the default printer is requested
     ⍝ Parms[2] = DesiredAccess (opt) #.Win.PRINTER_ACCESS_USE #.Win.PRINTER_ACCESS_ADMINISTER or #.Win.PRINTER_ALL_ACCESS
     ⍝
     ⍝ hPrinter = Handle to the specified printer or print server
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     Parms←,⊂Parms
 :EndIf
 :Select ↑⍴Parms
 :Case 1
     :If ''≡PrinterName←↑Parms
         PrinterName←GetDefault
     :EndIf
     ValidFlag hPrinter←##.OpenPrinterI PrinterName 1 0
 :Else
     PrinterName DesiredAccess←2↑Parms
     pDatatype←0
     pDevMode←0
     ValidFlag hPrinter←##.OpenPrinter PrinterName 1(pDatatype pDevMode DesiredAccess)
 :EndSelect
 :If ValidFlag
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hPrinter←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ Data←sData Read hPrinter;ValidFlag;cBytesRead
     ⍝ Retrieve data from the specified printer
     ⍝
     ⍝ hPrinter = Handle to the specified printer or print server
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ↑ValidFlag Data cBytesRead←##.ReadPrinter hPrinter sData sData 1
     Data←cBytesRead↑Data
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     Data←''
 :EndIf
∇

∇ {hDC}←ResetDC Parms;hDC;DevMode
     ⍝ Update the specified printer or plotter device context (DC) using the DevMode information
     ⍝
     ⍝ Parms[1] = hDC     Handle to the device context for the print job, see #.Win.Printer.CreateDC
     ⍝ Parms[1] = DevMode DEVMODE structure (see #.Win.Printer.BuildDevMode or #.Win.Printer.ResolveDevMode for definition)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2=↑⍴Parms
     hDC DevMode←Parms
     :If 1<≡DevMode
         DevMode←BuildDevMode DevMode
     :EndIf
     DevMode←##.IntTxt DevMode
     :If ##.NULL≠hDC←##.ResetDC hDC DevMode
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     hDC←0
     #.RCode←##.ERROR_INVALID_PARAMETER
 :EndIf
∇

∇ Retrn←ResolveDevMode DevMode;DeviceName;SpecVersion;DriverVersion;Size;DriverExtra;PrinterNames;Selection;ServerName
     ⍝ Resolves a combined DEVMODE structure
     ⍝
     ⍝ DevMode   = DEVMODE structure
     ⍝
     ⍝ Retrn[1]  = DeviceName       Printer's friendly name, eg "PCL/HP LaserJet"
     ⍝ Retrn[2]  = SpecVersion      Version number of initialization data specification (DM_SPECVERSION)
     ⍝ Retrn[3]  = DriverVersion    Version number assigned by printer driver developer
     ⍝ Retrn[4]  = Size             Size of DEVMODE structure without DriverExtraData
     ⍝ Retrn[5]  = DriverExtra      Size of DriverExtraData
     ⍝ Retrn[6]  = Fields           Flags specifying whether certain members of DEVMODE structure have been initialized (DM_xxx)
     ⍝ Retrn[7]  = Orientation      Portrait=1 Landscape=2
     ⍝ Retrn[8]  = PaperSize        Size of the paper to print on (DMPAPER_xxx)
     ⍝ Retrn[9]  = PaperLength      Overrides length of paper from PaperSize in tenths of a millimeter
     ⍝ Retrn[10] = PaperWidth       Overrides width of paper from PaperSize in tenths of a millimeter
     ⍝ Retrn[11] = Scale            Factor by which printed output is to be scaled
     ⍝ Retrn[12] = Copies           Number of copies printed
     ⍝ Retrn[13] = DefaultSource    Specifies paper source / input bin
     ⍝ Retrn[14] = PrintQuality     Printer (x-)resolution in DPI or (DMRES_xxx)
     ⍝ Retrn[15] = Color            Switches between color and monochrome on color (DMCOLOR_xxx)
     ⍝ Retrn[16] = Duplex           Selects duplex or double-sided printing for capable printers
     ⍝ Retrn[17] = YResolution      Printer y-resolution in DPI
     ⍝ Retrn[18] = TTOption         Specifies how TrueType fonts should be printed
     ⍝ Retrn[19] = Collate          Specifies whether collation should be used when printing multiple copies
     ⍝ Retrn[20] = FormName         Specifies the name of the form to use, eg "Letter" or "A4"
     ⍝ Retrn[21] = LogPixels        Number of pixels per logical inch of a display device
     ⍝ Retrn[22] = BitsPerPel       Color resolution, in bits per pixel, of a display device
     ⍝ Retrn[23] = PelsWidth        Width, in pixels, of the visible surface of a display device
     ⍝ Retrn[24] = PelsHeight       Height, in pixels, of the visible surface of a display device
     ⍝ Retrn[25] = DisplayFlags     Device display mode
     ⍝ Retrn[26] = DisplayFrequency Frequency, in hertz, of a display device
     ⍝ Retrn[27] = ICMMethod        How ICM is handled
     ⍝ Retrn[28] = ICMIntent        Specifies color matching method
     ⍝ Retrn[29] = MediaType        Specifies media type being printed on
     ⍝ Retrn[30] = DitherType       How dithering is to be done
     ⍝ Retrn[31] = Reserved1        Must be zero
     ⍝ Retrn[32] = Reserved2        Must be zero
     ⍝ Retrn[33] = PanningWidth     Must be zero
     ⍝ Retrn[34] = PanningHeight    Must be zero
     ⍝ Retrn[35] = DriverExtraData  Device driver's private data
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
     ⍝
 :If 124≤↑⍴DevMode
     :If 30<↑⍴↑DeviceName SpecVersion DriverVersion Size DriverExtra←(5↑##.DEVMODE)##.SplitTxtStruct DevMode
         PrinterNames←,1↑[2]Enum ##.PRINTER_ENUM_LOCAL+##.PRINTER_ENUM_CONNECTIONS
         :If 1∊Selection←(31↑¨PrinterNames)∊⊂31↑DeviceName
             DeviceName←(Selection⍳1)⊃PrinterNames
         :ElseIf '\\'≡2↑DeviceName
             ServerName←(1+(2↓DeviceName)⍳'\')↑DeviceName
             PrinterNames←,1↑[2]Enum ##.PRINTER_ENUM_NAME ServerName
         :AndIf 1∊Selection←(31↑¨PrinterNames)∊⊂31↑DeviceName
             DeviceName←(Selection⍳1)⊃PrinterNames
         :EndIf
     :EndIf
     Retrn←DeviceName SpecVersion DriverVersion Size DriverExtra
     Retrn,←5↓((Size+.≥+\|##.DEVMODE)↑##.DEVMODE)##.SplitTxtStruct DevMode
     Retrn,←((↑⍴##.DEVMODE)-↑⍴Retrn)⍴0
     Retrn,←⊂DriverExtra↑Size↓DevMode
 :Else
     DeviceName SpecVersion DriverVersion Size DriverExtra←'' 1025 1024 156 0
     Retrn←DeviceName SpecVersion DriverVersion Size DriverExtra
     Retrn,←'' 0[1+0<5↓##.DEVMODE],⊂''
 :EndIf
∇

∇ Retrn←ResolveDevNames DevNames;Driver;Device;Output;Default;DriverOffset;DeviceOffset;OutputOffset
     ⍝ Resolves a combined DEVNAMES structure
     ⍝
     ⍝ DevNames  = DEVNAMES structure
     ⍝
     ⍝ Retrn[1]  = Device  Printer's friendly name, eg "PCL/HP LaserJet"
     ⍝ Retrn[2]  = Driver  Driver's name without .drv extension, eg "winspool"
     ⍝ Retrn[3]  = Output  Port "LPT1:" or "FILE:" or filename
     ⍝ Retrn[4]  = Default #.Win.DN_DEFAULTPRN flag set if this is the default printer
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 DriverOffset DeviceOffset OutputOffset Default←2 ##.IntTxt 8↑DevNames
 Driver Device Output←{(¯1+⍵⍳↑⎕AV)↑⍵}¨↓∘DevNames¨DriverOffset DeviceOffset OutputOffset
 Default←Default=##.DN_DEFAULTPRN
 Retrn←Device Driver Output Default
∇

∇ {ValidFlag}←Params SaveParams KeyPath;InsertDefault;DevMode;Pages;Margins;Flags;FromPage;ToPage;MinPage;MaxPage;Margin;Left;Top;Right;Bottom;hKeyPath
     ⍝ Save printer parameters (DevMode Pages Margins) at the given user's registry KeyPath
     ⍝
     ⍝ KeyPath   =          Should be 'Software\[Manufacturer]\[Application]\[Formname]'
     ⍝ Params[1] = DevMode  Result from #.Win.Printer.EditDevMode, ↑#.Win.Printer.EditMargins, ↑#.Win.Printer.EditPages or #.Win.Printer.GetDevMode
     ⍝ Params[2] = Pages    Result from 2⊃#.Win.Printer.EditPages
     ⍝ Params[3] = Margins  Result from 2⊃#.Win.Printer.EditMargins
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 InsertDefault←{⍬≡⍺:⍵ ⋄ ⌊1⌈65534⌊⍺}
 :If ValidFlag←'\'∊KeyPath
 :AndIf ValidFlag←3=↑⍴Params
     DevMode Pages Margins←Params
     :If ValidFlag←##.INVALID_HANDLE_VALUE≠hKeyPath←##.Reg.CreateKey ##.HKEY_CURRENT_USER KeyPath
         :If 1<≡DevMode
             DevMode←BuildDevMode DevMode
         :ElseIf 0∊⍴DevMode
             DevMode←GetDevMode''
         :EndIf
         :If ValidFlag←~DevMode ##.Reg.SetValue hKeyPath'DevMode'##.REG_BINARY
             Flags FromPage ToPage MinPage MaxPage←(##.PD_ALLPAGES+##.PD_NOSELECTION+##.PD_NOPAGENUMS)⍬ ⍬ ⍬ ⍬
             Flags FromPage ToPage MinPage MaxPage←5↑Pages,(×/⍴Pages)↓Flags FromPage ToPage MinPage MaxPage
             Flags∧##.Bitwise←##.PD_ALLPAGES+##.PD_SELECTION+##.PD_PAGENUMS+##.PD_NOSELECTION+##.PD_NOPAGENUMS+##.PD_PRINTTOFILE+##.PD_HIDEPRINTTOFILE
             Flags∨##.Bitwise←##.PD_USEDEVMODECOPIESANDCOLLATE
             FromPage ToPage MinPage MaxPage InsertDefault←65535 65535 0 65535
             MaxPage⌈←MinPage
             ToPage⌈←FromPage
             ToPage FromPage←MaxPage⌊MinPage⌈ToPage FromPage
             Pages←4 2 2 2 2 ##.BuildBinStruct Flags FromPage ToPage MinPage MaxPage
         :AndIf ValidFlag←~Pages ##.Reg.SetValue hKeyPath'Pages'##.REG_BINARY
             Top Left Bottom Right←4↑⌊0⌈65535⌊100×Margins
             Margin←2 2 2 2 ##.BuildBinStruct Left Top Right Bottom
         :AndIf ValidFlag←~Margin ##.Reg.SetValue hKeyPath'Margin'##.REG_BINARY
         :EndIf
         ##.Reg.CloseKey hKeyPath
     :EndIf
 :EndIf
∇

∇ {ValidFlag}←SetDevMode DevMode;hPrinter;Level;PrinterInfo;pPrinterInfo;sPrinterInfo;sDevMode;Command;DeviceName;SpecVersion;DriverVersion;Size;DriverExtra;ValidFlag;pServerName;pPrinterName;pShareName;pPortName;pDriverName;pComment;pLocation;pDevMode;pSepFile;pPrintProcessor;pDatatype;pParameters;pSecurityDescriptor;Attributes;Priority;DefaultPriority;StartTime;UntilTime;Status;cJobs;AveragePPM;DesiredAccess
     ⍝ Set the current user printer device mode
     ⍝
     ⍝ DevMode = DEVMODE structure (see #.Win.Printer.BuildDevMode or #.Win.Printer.ResolveDevMode for definition)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 1<≡DevMode
     DeviceName SpecVersion DriverVersion Size DriverExtra←5↑DevMode
     DevMode←BuildDevMode DevMode
 :Else
     DeviceName SpecVersion DriverVersion Size DriverExtra←5↑ResolveDevMode DevMode
 :EndIf
 sDevMode←↑⍴DevMode
 pDatatype pDevMode DesiredAccess←0 0 ##.PRINTER_ALL_ACCESS
 :If ValidFlag←sDevMode=Size+DriverExtra
 :AndIf ↑ValidFlag hPrinter←##.OpenPrinter DeviceName 1(pDatatype pDevMode DesiredAccess)
     Level←2
     Command←0
     :If ~↑ValidFlag sPrinterInfo←##.GetPrinterI hPrinter Level 0 0 1
     :AndIf ValidFlag←##.ERROR_INSUFFICIENT_BUFFER=##.GetLastError
     :AndIf ##.NULL≠pPrinterInfo←##.Mem.Alloc sPrinterInfo
         :If ↑ValidFlag sPrinterInfo←##.GetPrinterI hPrinter Level pPrinterInfo sPrinterInfo 1
             PrinterInfo←sPrinterInfo ##.Mem.Read pPrinterInfo
             pServerName pPrinterName pShareName pPortName pDriverName pComment pLocation pDevMode pSepFile pPrintProcessor pDatatype pParameters pSecurityDescriptor Attributes Priority DefaultPriority StartTime UntilTime Status cJobs AveragePPM←4 ##.IntTxt 84↑PrinterInfo
             DeviceName SpecVersion DriverVersion Size DriverExtra←5↑ResolveDevMode sDevMode ##.Mem.Read pDevMode
         :AndIf ValidFlag←sDevMode=Size+DriverExtra
             DevMode ##.Mem.Write pDevMode
         :AndIf ValidFlag←##.SetPrinterI hPrinter Level pPrinterInfo Command
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.ERROR_INVALID_DATA{0≠⍵:⍵ ⋄ ⍺}##.GetLastError
         :EndIf
         ##.Mem.Free pPrinterInfo
     :Else
         #.RCode←##.GetLastError
         ValidFlag←0
     :EndIf
     ValidFlag∧←##.ClosePrinter hPrinter
 :Else
     #.RCode←##.ERROR_INVALID_DATA{0≠⍵:⍵ ⋄ ⍺}##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←Status SetJobStatus Parms;hPrinter;JobId;Level;Command;pDatatype;pDevMode;DesiredAccess;OpenedFlag;JobInfo;sJobInfo;pJobInfo
     ⍝ Set the status of a single job on a printer queue
     ⍝
     ⍝ Parms[1] = hPrinter Handle to the specified printer or printer's friendly name or '' if the default printer is requested
     ⍝ Parms[2] = JobId    Value returned from #.Win.Printer.StartDocPrinter or (#.Win.Printer.EnumJobs '')[;1]
     ⍝
     ⍝ Status   = Addition of these states:
     ⍝            #.Win.JOB_STATUS_SPOOLING
     ⍝            #.Win.JOB_STATUS_PRINTING
     ⍝            #.Win.JOB_STATUS_OFFLINE
     ⍝            #.Win.JOB_STATUS_PAPEROUT
     ⍝            #.Win.JOB_STATUS_PRINTED
     ⍝            #.Win.JOB_STATUS_DELETED
     ⍝            #.Win.JOB_STATUS_BLOCKED_DEVQ
     ⍝            #.Win.JOB_STATUS_USER_INTERVENTION
     ⍝            #.Win.JOB_STATUS_RESTART
     ⍝            #.Win.JOB_STATUS_COMPLETE
     ⍝
     ⍝            .. or one of these control commands:
     ⍝            #.Win.JOB_CONTROL_PAUSE
     ⍝            #.Win.JOB_CONTROL_RESUME
     ⍝            #.Win.JOB_CONTROL_CANCEL  (replaced by #.Win.JOB_CONTROL_DELETE)
     ⍝            #.Win.JOB_CONTROL_RESTART
     ⍝            #.Win.JOB_CONTROL_DELETE
     ⍝            #.Win.JOB_CONTROL_SENT_TO_PRINTER
     ⍝            #.Win.JOB_CONTROL_LAST_PAGE_EJECTED
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hPrinter JobId←2↑Parms
 :Select ↑Status
 :CaseList ##.JOB_CONTROL_PAUSE ##.JOB_CONTROL_RESUME ##.JOB_CONTROL_CANCEL ##.JOB_CONTROL_RESTART ##.JOB_CONTROL_DELETE ##.JOB_CONTROL_SENT_TO_PRINTER ##.JOB_CONTROL_LAST_PAGE_EJECTED
     Level←0
     pJobInfo←##.NULL
     Command←↑Status
 :Else
     Level←1
     Command←##.NULL
 :EndSelect
 pDatatype pDevMode DesiredAccess←0 0 ##.PRINTER_ALL_ACCESS
 :If ValidFlag←82≠⎕DR hPrinter
     OpenedFlag←0
 :Else
     :If ''≡hPrinter
         hPrinter←GetDefault
     :EndIf
     :If ↑ValidFlag hPrinter←##.OpenPrinter hPrinter 1(pDatatype pDevMode DesiredAccess)
         OpenedFlag←1
     :EndIf
 :EndIf
 :If ValidFlag
     :Select
     :Case 0
         :If ValidFlag←##.SetJobI hPrinter JobId Level pJobInfo Command
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
         :EndIf
     :Case 1
         :If ~↑ValidFlag sJobInfo←##.GetJobI hPrinter JobId Level 0 0 1
         :AndIf ValidFlag←##.ERROR_INSUFFICIENT_BUFFER=##.GetLastError
         :AndIf ValidFlag←##.NULL≠pJobInfo←##.Mem.Alloc sJobInfo
             :If ↑ValidFlag sJobInfo←##.GetJobI hPrinter JobId Level pJobInfo sJobInfo 1
                 (4 ##.##.TxtInt Status)##.Mem.Write pJobInfo+7×4
             :AndIf ValidFlag←##.SetJobI hPrinter JobId Level pJobInfo Command
                 #.RCode←##.ERROR_SUCCESS
             :Else
                 #.RCode←##.GetLastError
             :EndIf
             ##.Mem.Free pJobInfo
         :Else
             #.RCode←##.GetLastError
         :EndIf
     :EndSelect
     :If OpenedFlag
         ValidFlag∧←##.ClosePrinter hPrinter
     :EndIf
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←Status SetStatus hPrinter;OpenedFlag;Level;Command;pDatatype;pDevMode;DesiredAccess
     ⍝ Get the current printer user setting's DevMode
     ⍝
     ⍝ hPrinter = Handle to the specified printer or printer's friendly name or '' if the default printer is requested
     ⍝
     ⍝ Status   = Addition of these states:
     ⍝            #.Win.PRINTER_STATUS_PAPER_JAM         Papierstau
     ⍝            #.Win.PRINTER_STATUS_PAPER_OUT         Kein Papier
     ⍝            #.Win.PRINTER_STATUS_MANUAL_FEED       Mauelle Papierzufuhr notwendig
     ⍝            #.Win.PRINTER_STATUS_PAPER_PROBLEM     Problem mit der Papierzufuhr
     ⍝            #.Win.PRINTER_STATUS_OFFLINE           Offline
     ⍝            #.Win.PRINTER_STATUS_IO_ACTIVE         EA aktiv
     ⍝            #.Win.PRINTER_STATUS_BUSY              Ausgelastet
     ⍝            #.Win.PRINTER_STATUS_PRINTING          Wird gedruckt
     ⍝            #.Win.PRINTER_STATUS_OUTPUT_BIN_FULL   Ausgabefach voll
     ⍝            #.Win.PRINTER_STATUS_NOT_AVAILABLE     Nicht verfügbar
     ⍝            #.Win.PRINTER_STATUS_WAITING           Warten
     ⍝            #.Win.PRINTER_STATUS_PROCESSING        Verarbeitung
     ⍝            #.Win.PRINTER_STATUS_INITIALIZING      Initialisierung
     ⍝            #.Win.PRINTER_STATUS_WARMING_UP        Anlaufen
     ⍝            #.Win.PRINTER_STATUS_TONER_LOW         Niedriger Tonerstand
     ⍝            #.Win.PRINTER_STATUS_NO_TONER          Kein Toner
     ⍝            #.Win.PRINTER_STATUS_PAGE_PUNT         Papierverwurf
     ⍝            #.Win.PRINTER_STATUS_USER_INTERVENTION Benutzereingriff notwendig
     ⍝            #.Win.PRINTER_STATUS_OUT_OF_MEMORY     Kein Arbeitspeicher
     ⍝            #.Win.PRINTER_STATUS_DOOR_OPEN         Gerät offen
     ⍝            #.Win.PRINTER_STATUS_SERVER_UNKNOWN    Serverzustand unbekannt
     ⍝            #.Win.PRINTER_STATUS_POWER_SAVE        Stromsparmodus
     ⍝            .. or one of these control commands:
     ⍝            #.Win.PRINTER_CONTROL_PAUSE            Anhalten
     ⍝            #.Win.PRINTER_CONTROL_RESUME           Wiederaufnahme
     ⍝            #.Win.PRINTER_CONTROL_PURGE            Alle Druckaufträge löschen
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 Level←0
 :Select ↑Status
 :CaseList ##.PRINTER_CONTROL_PAUSE ##.PRINTER_CONTROL_RESUME ##.PRINTER_CONTROL_PURGE
     Command←↑Status
     Status←##.NULL
 :Else
     Command←##.PRINTER_CONTROL_SET_STATUS
 :EndSelect
 pDatatype pDevMode DesiredAccess←0 0 ##.PRINTER_ALL_ACCESS
 :If ValidFlag←82≠⎕DR hPrinter
     OpenedFlag←0
 :Else
     :If ''≡hPrinter
         hPrinter←GetDefault
     :EndIf
     :If ↑ValidFlag hPrinter←##.OpenPrinter hPrinter 1(pDatatype pDevMode DesiredAccess)
         OpenedFlag←1
     :EndIf
 :EndIf
 :If ValidFlag
     :If ValidFlag←##.SetPrinterI hPrinter Level Status Command
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
     :If OpenedFlag
         ValidFlag∧←##.ClosePrinter hPrinter
     :EndIf
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {JobId}←StartDoc Parms;hDC;DocName;OutputFile;Datatype;TypeFlags;DocInfo;cbSize;pDocInfo;pDocName;pOutputFile;pDatatype;RCode
     ⍝ Start a print job
     ⍝
     ⍝ Parms[1] = hDC        Handle to the device context for the print job, see #.Win.Printer.CreateDC
     ⍝ Parms[2] = DocName    (def '') Name appearing in the print job list
     ⍝ Parms[3] = OutputFile (def '') ''=Send to printer, else print to file
     ⍝ Parms[4] = Datatype   (def 'RAW') 'RAW' 'RAW [FF Appended]' 'RAW [FF Auto]' 'Text' 'EMF' or 'PSCRIPT1'
     ⍝ Parms[5] = TypeFlags  (def 0) can be #.Win.DI_APPBANDING+#.Win.DI_ROPS_READ_DESTINATION
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     Parms←,⊂Parms
 :EndIf
 :Select ↑⍴Parms
 :Case 1
     hDC←↑Parms
     DocName OutputFile Datatype TypeFlags←'' '' 'RAW' 0
 :Case 2
     hDC DocName←Parms
     OutputFile Datatype TypeFlags←'' 'RAW' 0
 :Case 3
     hDC DocName OutputFile←Parms
     Datatype TypeFlags←'RAW' 0
 :Case 4
     hDC DocName OutputFile Datatype←Parms
     TypeFlags←0
 :Else
     hDC DocName OutputFile Datatype TypeFlags←5↑Parms
 :EndSelect
 cbSize←1×5×4
 :If ×↑⍴OutputFile
     DocName OutputFile Datatype,←↑⎕AV
     pDocName pOutputFile pDatatype←+\cbSize,↑∘⍴¨DocName OutputFile
 :Else
     DocName Datatype,←↑⎕AV
     pDocName pDatatype←+\cbSize,↑⍴DocName
     pOutputFile←0
 :EndIf
 DocInfo←(4 ##.TxtInt cbSize pDocName pOutputFile pDatatype TypeFlags),DocName,OutputFile,Datatype
 :If 0≠pDocInfo←##.Mem.Alloc DocInfo
     pDocName pOutputFile pDatatype{(⍺+⍵)××⍺}←pDocInfo
     (4 ##.TxtInt pDocName pOutputFile pDatatype)##.Mem.Write 4+pDocInfo
     :If 0≠JobId←##.StartDoc hDC pDocInfo
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
     RCode←#.RCode ⋄ ##.Mem.Free pDocInfo ⋄ #.RCode←RCode
 :Else
     JobId←0
 :EndIf
∇

∇ {JobId}←StartDocPrinter Parms;hPrinter;DocName;OutputFile;Datatype;DocInfo;Level;pDocInfo;pDocName;pOutputFile;pDatatype;RCode
     ⍝ Notify print spooler that a document is to be spooled for printing
     ⍝
     ⍝ Parms[1] = hPrinter   Handle to an open printer
     ⍝ Parms[2] = DocName    (def '') Name appearing in the print job list
     ⍝ Parms[3] = OutputFile (def '') ''=Send to printer, else print to file
     ⍝ Parms[4] = Datatype   (def 'RAW') 'RAW' 'RAW [FF Appended]' 'RAW [FF Auto]' 'Text' 'EMF' or 'PSCRIPT1'
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     Parms←,⊂Parms
 :EndIf
 :Select ↑⍴Parms
 :Case 1
     hPrinter←↑Parms
     DocName OutputFile Datatype←'' '' 'RAW'
 :Case 2
     hPrinter DocName←Parms
     OutputFile Datatype←'' 'RAW'
 :Case 3
     hPrinter DocName OutputFile←Parms
     Datatype←'RAW'
 :Else
     hPrinter DocName OutputFile Datatype←4↑Parms
 :EndSelect
 Level←1
 :If ×↑⍴OutputFile
     DocName OutputFile Datatype,←↑⎕AV
     pDocName pOutputFile pDatatype←+\12,↑∘⍴¨DocName OutputFile
 :Else
     DocName Datatype,←↑⎕AV
     pDocName pDatatype←+\12,↑⍴DocName
     pOutputFile←0
 :EndIf
 DocInfo←(4 ##.TxtInt pDocName pOutputFile pDatatype),DocName,OutputFile,Datatype
 :If 0≠pDocInfo←##.Mem.Alloc DocInfo
     pDocName pOutputFile pDatatype{(⍺+⍵)××⍺}←pDocInfo
     (4 ##.TxtInt pDocName pOutputFile pDatatype)##.Mem.Write pDocInfo
     :If 0≠JobId←##.StartDocPrinter hPrinter Level pDocInfo
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
     RCode←#.RCode ⋄ ##.Mem.Free pDocInfo ⋄ #.RCode←RCode
 :Else
     JobId←0
 :EndIf
∇

∇ {ValidFlag}←StartPage hDC
     ⍝ Prepare the printer driver to accept data
     ⍝
     ⍝ hDC = Handle to the device context for the print job, must be the same as on #.Win.Printer.StartDoc
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←0<##.StartPage hDC
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←StartPagePrinter hPrinter
     ⍝ Notify print spooler that a page is about to be printed on the specified printer
     ⍝
     ⍝ hPrinter = Handle to the specified printer or print server
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.StartPagePrinter hPrinter
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←ViewProps hPrinter;hwndOwner;OpenedFlag
     ⍝ Display a printer-properties property sheet for the specified printer
     ⍝
     ⍝ hPrinter = Handle to the specified printer or printer's friendly name or '' if the default printer is requested
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :With 2 ⎕NQ'.' 'GetFocus'
     :If (⊂'Handle')∊⎕WG'PropList'
         hwndOwner←⎕WG'Handle'
     :Else
         hwndOwner←0
     :EndIf
 :EndWith
 :If ValidFlag←82≠⎕DR hPrinter
     OpenedFlag←0
 :Else
     :If ''≡hPrinter
         hPrinter←GetDefault
     :EndIf
     :If ↑ValidFlag hPrinter←##.OpenPrinterI hPrinter 1 ##.NULL
         OpenedFlag←1
     :EndIf
 :EndIf
 :If ValidFlag
 :AndIf ValidFlag←##.PrinterProperties hwndOwner hPrinter
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
 :If OpenedFlag
     ValidFlag∧←##.ClosePrinter hPrinter
 :EndIf
∇

∇ {ValidFlag}←Data Write hPrinter;sData;cWritten
     ⍝ Notify print spooler that data should be written to the specified printer
     ⍝
     ⍝ hPrinter = Handle to the specified printer or print server
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2003
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 sData←↑⍴Data←##.IntTxt Data
 :If ##.TRUE sData≡ValidFlag cWritten←##.WritePrinter hPrinter Data sData 1
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

:EndNamespace 
:Namespace Proc
⎕IO ⎕ML ⎕WX ⎕CT←1 3 1 9.999999999999998E¯15

∇ {VOID}←Close hObject
     ⍝ Closes an open handle to an object such as a file handle.
     ⍝ VOID = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.TRUE=##.CloseHandle hObject
     #.RCode←##.ERROR_SUCCESS
     VOID←0
 :Else
     #.RCode←##.GetLastError
     VOID←1
 :EndIf
∇

∇ Retrn←CreateThread Parms;ThreadAttributes;StackSize;StartAddress;lpParameter;CreationFlags;SecurityDescriptor;lpSecurityDescriptor;InheritHandle;hThread;ThreadId
     ⍝ Create a thread to execute within the virtual address space of the calling process
     ⍝
     ⍝ Parms[1] = StartAddress       Pointer to ThreadProc(lpParameter) to be executed by the thread
     ⍝ Parms[2] = lpParameter        (opt) def 0           Single parameter value passed to the thread
     ⍝ Parms[3] = StackSize          (opt) def 0           Initial commit size of the stack, in bytes
     ⍝ Parms[4] = CreationFlags      (opt) def #.Win.NULL  or #.Win.CREATE_SUSPENDED
     ⍝ Parms[5] = SecurityDescriptor (opt) def #.Win.NULL  Security descriptor for the object that controls the sharing of it
     ⍝ Parms[6] = InheritHandle      (opt) def #.Win.FALSE or #.Win.TRUE if returned handle is inherited when a new process is created
     ⍝
     ⍝ Retrn[1] = hThread  or if fail #.Win.INVALID_HANDLE_VALUE
     ⍝ Retrn[2] = ThreadId or if fail O
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 StartAddress lpParameter StackSize CreationFlags SecurityDescriptor InheritHandle←6↑Parms
 :If ×↑⍴SecurityDescriptor
     lpSecurityDescriptor←##.Mem.Alloc SecurityDescriptor
 :Else
     lpSecurityDescriptor←##.NULL
 :EndIf
 ThreadAttributes←##.SECURITY_ATTRIBUTES
 ThreadAttributes[2]←lpSecurityDescriptor
 ThreadAttributes[3]←InheritHandle
 hThread ThreadId←##.CreateThread ThreadAttributes StackSize StartAddress lpParameter CreationFlags 1
 :If ##.NULL≠hThread
     #.RCode←##.ERROR_SUCCESS
     Retrn←hThread ThreadId
 :Else
     #.RCode←##.GetLastError
     Retrn←##.INVALID_HANDLE_VALUE 0
 :EndIf
 :If lpSecurityDescriptor≠##.NULL
     RCode←#.RCode ⋄ ##.Mem.Free lpSecurityDescriptor ⋄ :If RCode≠#.Win.ERROR_SUCCESS ⋄ #.RCode←RCode ⋄ :EndIf
 :EndIf
∇

∇ hTargetHandle←DuplicateHandle Parms;hSourceProcessHandle;hSourceHandle;hTargetProcessHandle;dwDesiredAccess;bInheritHandle;dwOptions;VOID
     ⍝ Duplicate an object handle. Duplicate handle refers to same object as original handle.
     ⍝
     ⍝ Parms[1] = hSourceProcessHandle handle to source process
     ⍝ Parms[2] = hSourceHandle        handle to duplicate
     ⍝ Parms[3] = hTargetProcessHandle handle to target process
     ⍝ Parms[4] = dwDesiredAccess      requested access          (ignored if dwOptions=DUPLICATE_SAME_ACCESS)
     ⍝ Parms[5] = bInheritHandle       handle inheritance option (#.Win.TRUE or #.Win.FALSE)
     ⍝ Parms[6] = dwOptions            optional actions          (#.Win.DUPLICATE_CLOSE_SOURCE+#.Win.DUPLICATE_SAME_ACCESS)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hSourceProcessHandle hSourceHandle hTargetProcessHandle dwDesiredAccess bInheritHandle dwOptions←6↑Parms
 :If ##.ZERO≠↑VOID hTargetHandle←##.DuplicateHandle hSourceProcessHandle hSourceHandle hTargetProcessHandle 1 dwDesiredAccess bInheritHandle dwOptions
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hTargetHandle←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ {ValidFlag}←EmptyWorkingSet ProcessId;_EmptyWorkingSet
     ⍝ Remove as many pages as possible from the working set of the specified process
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Trap 0
     '_EmptyWorkingSet'⎕NA'I PSAPI|EmptyWorkingSet I'
     :If ValidFlag←_EmptyWorkingSet ProcessId
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     #.RCode←ERROR_CALL_NOT_IMPLEMENTED
     ValidFlag←0
 :EndTrap
∇

∇ ProcessIds←EnumProcesses;_EnumProcesses;ValidFlag;cbNeeded;_CreateToolhelp32Snapshot;_Process32First;_Process32Next
     ⍝ Retrieve the process identifier for each process object in the system
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Trap 0
     '_EnumProcesses'⎕NA'I PSAPI|EnumProcesses >I[] I >I'
     :If ↑ValidFlag ProcessIds cbNeeded←_EnumProcesses 4096 16384 1
         #.RCode←##.ERROR_SUCCESS
         ProcessIds←(↑0 4⊤cbNeeded)↑ProcessIds
     :Else
         #.RCode←##.GetLastError
         ProcessIds←⍬
     :EndIf
 :Else
     :Trap 0
         '_CreateToolhelp32Snapshot'⎕NA'I KRENEL32|CreateToolhelp32Snapshot I I'
         '_Process32First'⎕NA'I KRENEL32|Process32First I ={I I I I I I I I T[256] T[260]}'
         '_Process32Next'⎕NA'I KRENEL32|Process32Next I ={I I I I I I I I T[256] T[260]}'
              ⍝ To be continued ..
         #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
         ProcessIds←⍬
     :Else
         #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
         ProcessIds←⍬
     :EndTrap
 :EndTrap
∇

∇ {Value}←{Value}EnvironmentVariable Name
     ⍝ Get/Set/Modify the Value of the enviroment variable Name.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×⎕NC'Value'
     :If ##.ZERO≠##.SetEnvironmentVariable Name Value
         #.RCode←##.ERROR_SUCCESS
         Value←↑↑/##.GetEnvironmentVariable Name 1024 1024
     :Else
         #.RCode←##.GetLastError
         Value←''
     :EndIf
 :Else
     Value←↑↑/##.GetEnvironmentVariable Name 1024 1024
     #.RCode←##.ERROR_SUCCESS
 :EndIf
∇

∇ ExcludeWorkspaceDirectory;A;B
     ⍝ Exclude path section of ⎕WSID from enviroment variable PATH.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 :If ×⎕NC'_WsDir'
 :AndIf ∨/B←(A←(';'≠A)⊂A←EnvironmentVariable'PATH')∊⊂_WsDir
     (1↓∊';',¨(~B)/A)EnvironmentVariable'PATH'
 :EndIf
 ⎕EX'_WsDir'
∇

∇ {Retrn}←{CurrentDirectory}ExecuteApplication Parms;CommandLine;ChildWaitMode;CreationFlags;ShowWindow;ShowWindowFlag;ValidFlag;pEnvironment;StartupInfo;ProcessInformation;hProcess;hThread;ProcessId;ThreadId;ProcessExitCode;ThreadExitCode
     ⍝ Execute a GDI task
     ⍝ The task is executed in the "CurrentDirectory" if given or in the current directory of this task, if not.
     ⍝
     ⍝ Parms[1] = CommandLine                 "executable parameters ..."
     ⍝ Parms[2] = ChildWaitMode (opt def=1)   0 = Execute forked  application, return immediately when new application has started
     ⍝                                        1 = Execute spawned application, return when new application finishes. Ctrl-Break will terminate the process and a child wait condition
     ⍝                                        2 = Execute forked  application, leave local process and thread handles open and return ProcessInformation structure
     ⍝                                        3 = Execute spawned application, return when new application finishes. ProcessExitCodes will be returned
     ⍝ Parms[3] = ShowWindow    (opt def=def) #.Win.SW_SHOWDEFAULT #.Win.SW_HIDE #.Win.SW_SHOWNORMAL #.Win.SW_SHOWMINIMIZED or #.Win.SW_SHOWMAXIMIZED
     ⍝ Parms[4] = CreationFlags (opt def=nrm) #.Win.IDLE_PRIORITY_CLASS #.Win.NORMAL_PRIORITY_CLASS #.Win.HIGH_PRIORITY_CLASS or #.Win.REALTIME_PRIORITY_CLASS
     ⍝
     ⍝ Retrn[1] = InvalidFlag (Bool)          0 = Process started successfully
     ⍝                                        1 = Process could not start. For details, see #.RCode #.RText
     ⍝ Retrn[2] = ProcessInformation          Only if ChildWaitMode=2: (hProcess hThread ProcessId ThreadId)
     ⍝                                        You have to close both handles by performing: "#.Win.Proc.Close¨hProcess hThread"
     ⍝ Retrn[2] = ProcessExitCodes            Only if ChildWaitMode=3: (ProcessExitCode ThreadExitCode)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×⎕NC'CurrentDirectory'
     CurrentDirectory←2⊃##.ExpandEnvironmentStrings CurrentDirectory ##.MAX_PATH ##.MAX_PATH
 :Else
     CurrentDirectory←⊃↑/##.GetCurrentDirectory ##.MAX_PATH ##.MAX_PATH
 :EndIf
 :If 1<≡Parms
     :Select ↑⍴,Parms
     :Case 1
         CommandLine←↑Parms
         ChildWaitMode CreationFlags←1 ##.NORMAL_PRIORITY_CLASS
     :Case 2
         CommandLine ChildWaitMode←Parms
         CreationFlags←##.NORMAL_PRIORITY_CLASS
     :Case 3
         CommandLine ChildWaitMode ShowWindow←Parms
         CreationFlags←##.NORMAL_PRIORITY_CLASS
     :Else
         CommandLine ChildWaitMode ShowWindow CreationFlags←4↑Parms
     :EndSelect
 :Else
     CommandLine ChildWaitMode CreationFlags←Parms 1 ##.NORMAL_PRIORITY_CLASS
 :EndIf
 CommandLine←2⊃##.ExpandEnvironmentStrings CommandLine 1024 1024
 pEnvironment←##.GetEnvironmentStrings
 StartupInfo←##.STARTUPINFO
 :If ×⎕NC'ShowWindow'
     StartupInfo[12 13]←##.STARTF_USESHOWWINDOW ShowWindow
 :EndIf
 :If ↑ValidFlag ProcessInformation←##.CreateProcess ##.NULL CommandLine ##.NULL ##.NULL ##.TRUE CreationFlags pEnvironment CurrentDirectory StartupInfo 0
     hProcess hThread ProcessId ThreadId←ProcessInformation
     ValidFlag←##.FreeEnvironmentStrings pEnvironment
     #.RCode←##.ERROR_SUCCESS
     :Select ChildWaitMode
     :Case 0
         ValidFlag←##.CloseHandle¨hProcess hThread
         Retrn←0
     :Case 1
         :Trap 1000
             :While ##.TRUE ##.STILL_ACTIVE≡##.GetExitCodeProcess hProcess 1
             :Until ##.WAIT_OBJECT_0=##.WaitForSingleObject hProcess 10
         :Else
             ValidFlag←##.TerminateProcess hProcess ##.CONTROL_C_EXIT
             #.RCode←##.ERROR_PROCESS_ABORTED
             Retrn←1
         :EndTrap
         :While ##.TRUE ##.STILL_ACTIVE≡##.GetExitCodeThread hThread 1
             ValidFlag←##.TerminateThread hThread ##.STATUS_WAIT_0
         :EndWhile
         ValidFlag←##.CloseHandle¨hProcess hThread
         Retrn←0
     :Case 2
         Retrn←0(hProcess hThread ProcessId ThreadId)
     :Case 3
         :Trap 1000
             :While ##.TRUE ##.STILL_ACTIVE≡ProcessExitCode←##.GetExitCodeProcess hProcess 1
             :Until ##.WAIT_OBJECT_0=##.WaitForSingleObject hProcess 10
         :Else
             ValidFlag←##.TerminateProcess hProcess ##.CONTROL_C_EXIT
             #.RCode←##.ERROR_PROCESS_ABORTED
             Retrn←1
         :EndTrap
         :While ##.TRUE ##.STILL_ACTIVE≡ThreadExitCode←##.GetExitCodeThread hThread 1
             ValidFlag←##.TerminateThread hThread ##.STATUS_WAIT_0
         :EndWhile
         ValidFlag←##.CloseHandle¨hProcess hThread
         Retrn←0(ProcessExitCode ThreadExitCode)
     :EndSelect
 :Else
     #.RCode←##.GetLastError
     ValidFlag←##.FreeEnvironmentStrings pEnvironment
     :Select ChildWaitMode
     :CaseList 0 1
         Retrn←1
     :Case 2
         Retrn←1(##.INVALID_HANDLE_VALUE ##.INVALID_HANDLE_VALUE 0 0)
     :Case 3
         Retrn←1(##.WAIT_FAILED ##.WAIT_FAILED)
     :EndSelect
 :EndIf
∇

∇ StdOutput←{CurrentDirectory}ExecuteProcess CommandLine;StdInput;hStdInputRead;hStdInputWrite;hStdOutputRead;hStdOutputWrite;NumberOfBytesRead;NumberOfBytesWritten;cbAvail;Buffer;pEnvironment;ValidFlag;SecurityAttributes;StartupInfo;ProcessInformation;hProcess;hThread;ProcessId;ThreadId
     ⍝ Execute a new (console) task in a hidden window.
     ⍝ The task is executed in the "CurrentDirectory" if given or in the current directory of this task, if not.
     ⍝ Any necessary input strings can be given in further text vectors in "CommandLine".
     ⍝ If omitted, "CommandLine" may consist of a simple text vector naming the task name and
     ⍝ blank separated command line arguments.
     ⍝ The result of the function is the task's result, converted to a vector of vectors.
     ⍝ If the function hangs, it may be interrupted by Ctrl-Break, the accumulated result is always returned.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 #.RCode←##.ERROR_SUCCESS
 :If ×⎕NC'CurrentDirectory'
     CurrentDirectory←2⊃##.ExpandEnvironmentStrings CurrentDirectory ##.MAX_PATH ##.MAX_PATH
 :Else
     CurrentDirectory←⊃↑/##.GetCurrentDirectory ##.MAX_PATH ##.MAX_PATH
 :EndIf
 :If 1<≡CommandLine
     StdInput←∊(1↓CommandLine),¨⊂⎕AV[4 3]
     CommandLine←↑CommandLine
 :Else
     StdInput←''
     CommandLine←,CommandLine
 :EndIf
 CommandLine←2⊃##.ExpandEnvironmentStrings CommandLine 1024 1024
 SecurityAttributes←##.SECURITY_ATTRIBUTES
 SecurityAttributes[3]←##.TRUE
 :If ↑ValidFlag hStdInputRead hStdInputWrite←##.CreatePipe 0 0 SecurityAttributes(0×↑⍴StdInput)
     SecurityAttributes←##.SECURITY_ATTRIBUTES
     SecurityAttributes[3]←##.TRUE
     :If ↑ValidFlag hStdOutputRead hStdOutputWrite←##.CreatePipe 0 0 SecurityAttributes 0
         pEnvironment←##.GetEnvironmentStrings
         StartupInfo←##.STARTUPINFO
         StartupInfo[12 13 16 17 18]←(##.STARTF_USESHOWWINDOW+##.STARTF_USESTDHANDLES)##.SW_HIDE hStdInputRead hStdOutputWrite hStdOutputWrite
         :If ↑ValidFlag ProcessInformation←##.CreateProcess ##.NULL CommandLine ##.NULL ##.NULL ##.TRUE(##.NORMAL_PRIORITY_CLASS+##.CREATE_SEPARATE_WOW_VDM)pEnvironment CurrentDirectory StartupInfo 0
             hProcess hThread ProcessId ThreadId←ProcessInformation
             ValidFlag←##.CloseHandle¨hStdInputRead hStdOutputWrite
             ValidFlag←##.FreeEnvironmentStrings pEnvironment
             :If 0∊⍴StdInput
             :OrIf ↑ValidFlag NumberOfBytesWritten←##.WriteFileC hStdInputWrite(2⊃##.CharToOemCBuff(⊂StdInput),2⍴↑⍴StdInput)(↑⍴StdInput)0 0
                 ValidFlag←##.CloseHandle hStdInputWrite
                 StdOutput←''
                 :Trap 1000
                     :While ##.TRUE ##.STILL_ACTIVE≡##.GetExitCodeProcess hProcess 1
                         :If ↑ValidFlag cbAvail←##.PeekNamedPipeAvail hStdOutputRead 0 0 0 0 0
                         :AndIf 0≠cbAvail
                             ValidFlag Buffer NumberOfBytesRead←##.ReadFileC hStdOutputRead cbAvail cbAvail 0 0
                             StdOutput,←2⊃##.OemCToCharBuff Buffer NumberOfBytesRead NumberOfBytesRead
                         :EndIf
                     :Until ##.WAIT_OBJECT_0=##.WaitForSingleObject hProcess 10
                 :Else
                     ValidFlag←##.TerminateProcess hProcess ##.CONTROL_C_EXIT
                     #.RCode←##.ERROR_PROCESS_ABORTED
                 :EndTrap
                 :If ↑ValidFlag cbAvail←##.PeekNamedPipeAvail hStdOutputRead 0 0 0 0 0
                 :AndIf 0≠cbAvail
                     ValidFlag Buffer NumberOfBytesRead←##.ReadFileC hStdOutputRead cbAvail cbAvail 0 0
                     StdOutput,←2⊃##.OemCToCharBuff Buffer NumberOfBytesRead NumberOfBytesRead
                 :EndIf
                 :While ##.TRUE ##.STILL_ACTIVE≡##.GetExitCodeThread hThread 1
                     ValidFlag←##.TerminateThread hThread ##.STATUS_WAIT_0
                 :EndWhile
                 ValidFlag←##.CloseHandle¨hStdOutputRead hProcess hThread
                 StdOutput←{(-0=⍴↑¯1↑⍵)↓⍵}{1↓¨(+\⎕AV[3]=⍵)⊂⍵}{⎕AV[3],(~⎕AV[4 3]⍷⍵)/⍵}StdOutput
             :Else
                 #.RCode←##.GetLastError
                 StdOutput←0↑⊂''
                 ValidFlag←##.CloseHandle¨hStdInputWrite hStdOutputRead hProcess hThread
             :EndIf
         :Else
             #.RCode←##.GetLastError
             StdOutput←0↑⊂''
             ValidFlag←##.CloseHandle¨hStdInputRead hStdInputWrite hStdOutputRead hStdOutputWrite
             ValidFlag←##.FreeEnvironmentStrings pEnvironment
         :EndIf
     :Else
         StdOutput←0↑⊂''
         #.RCode←##.GetLastError
         ValidFlag←##.CloseHandle¨hStdInputRead hStdInputWrite
     :EndIf
 :Else
     StdOutput←0↑⊂''
     #.RCode←##.GetLastError
 :EndIf
∇

∇ ExitProcess ExitCode;VOID
     ⍝ End a process and all its threads
     ⍝
     ⍝ ExitCode  Exit code for all threads
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 VOID←##.ExitProcess ExitCode
∇

∇ ExitThread ExitCode;VOID
     ⍝ End a thread
     ⍝
     ⍝ ExitCode  Exit code for thread
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 VOID←##.ExitThread ExitCode
∇

∇ Data←GetCommandLine;A
     ⍝ Gets the command line of this task.
     ⍝ The format of the result is a vector of couples of vectors,
     ⍝ specifying (parameter value)(parameter value)...
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×A←'%'+.=Data←2⊃##.lstrcpyPtr(1+##.lstrlenPtr Data)(Data←##.GetCommandLine)
     Data←2⊃##.ExpandEnvironmentStrings Data A(A←(↑⍴Data)+512×A)
 :EndIf
 Data←{2↑¨(('='≠⍵)⊂¨⍵),¨⊂⊂''}{⍵{(⍵/(' '≠⍺)∨⍵>=\⍵)⊂⍵/⍺}'"'≠⍵}Data
∇

∇ ProcessHandle←GetCurrentProcess
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 ProcessHandle←##.GetCurrentProcess
 #.RCode←##.ERROR_SUCCESS
∇

∇ ProcessId←GetCurrentProcessId
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 ProcessId←##.GetCurrentProcessId
 #.RCode←##.ERROR_SUCCESS
∇

∇ ThreadHandle←GetCurrentThread
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 ThreadHandle←##.GetCurrentThread
 #.RCode←##.ERROR_SUCCESS
∇

∇ ThreadId←GetCurrentThreadId
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 ThreadId←##.GetCurrentThreadId
 #.RCode←##.ERROR_SUCCESS
∇

∇ A←GetEnvironmentStrings;B;C;D
     ⍝ Gets the environment variables as a vector of couples of vetors.
     ⍝ The format is (variable value)(variable value)...
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 A←0⍴⊂''
 C←D←##.GetEnvironmentStrings
 :While ×⍴B←,2⊃##.lstrcpyPtr(1+##.lstrlenPtr C)C
     C←C+1+↑⍴A,∘⊂←B
 :EndWhile
 D←##.FreeEnvironmentStrings D
 A←2↑¨(⊂⊂''),⍨¨('='≠A)⊂¨A
∇

∇ ExitCode←GetExitCodeProcess hProcess;ValidFlag
     ⍝ Retrieve termination status of specified process
     ⍝
     ⍝ Parms[1] = hProcess   Handle to the process
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ↑ValidFlag ExitCode←##.GetExitCodeProcess hProcess 1
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     ExitCode←¯1
 :EndIf
∇

∇ ExitCode←GetExitCodeThread hThread;ValidFlag
     ⍝ Retrieve termination status of specified thread
     ⍝
     ⍝ Parms[1] = hThread   Handle to the thread
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ↑ValidFlag ExitCode←##.GetExitCodeThread hThread 1
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     ExitCode←¯1
 :EndIf
∇

∇ PriorityClass←GetPriorityClass hProcess
     ⍝ Retrieve the priority class for the specified process
     ⍝ This value together with the priority value of each thread
     ⍝ of the process determines each thread's base priority level
     ⍝
     ⍝ hProcess      = Handle to process
     ⍝ PriorityClass = #.Win.IDLE_PRIORITY_CLASS #.Win.NORMAL_PRIORITY_CLASS #.Win.HIGH_PRIORITY_CLASS #.Win.REALTIME_PRIORITY_CLASS W2K: #.Win.BELOW_NORMAL_PRIORITY_CLASS #.Win.ABOVE_NORMAL_PRIORITY_CLASS
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠PriorityClass←##.GetPriorityClass hProcess
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Priority←GetThreadPriority hThread
     ⍝ Retrieve the priority value for the specified thread
     ⍝ This value together with the priority class of the thread's
     ⍝ process, determines the thread's base-priority level
     ⍝
     ⍝ hThread  = Handle to the thread
     ⍝ Priority = #.Win.THREAD_PRIORITY_IDLE #.Win.THREAD_PRIORITY_LOWEST #.Win.THREAD_PRIORITY_BELOW_NORMAL #.Win.THREAD_PRIORITY_NORMAL #.Win.THREAD_PRIORITY_ABOVE_NORMAL #.Win.THREAD_PRIORITY_HIGHEST #.Win.THREAD_PRIORITY_TIME_CRITICAL
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.THREAD_PRIORITY_ERROR_RETURN≠Priority←##.GetThreadPriority hThread
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Retrn←GetWorkingSetSize hProcess;_GetProcessWorkingSetSize;ValidFlag;MinimumWorkingSetSize;MaximumWorkingSetSize
     ⍝ Retrieve the minimum and maximum working set sizes of the specified process
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Trap 0
     '_GetProcessWorkingSetSize'⎕NA'I KERNEL32|GetProcessWorkingSetSize I >U >U'
     :If ↑ValidFlag MinimumWorkingSetSize MaximumWorkingSetSize←_GetProcessWorkingSetSize hProcess 1 1
         #.RCode←##.ERROR_SUCCESS
         :If 4294967295 4294967295≡Retrn←MinimumWorkingSetSize MaximumWorkingSetSize
             Retrn←¯1 ¯1
         :EndIf
     :Else
         #.RCode←##.GetLastError
         Retrn←0 0
     :EndIf
 :Else
     #.RCode←ERROR_CALL_NOT_IMPLEMENTED
     Retrn←0 0
 :EndTrap
∇

∇ WorkspaceDirectory←GetWorkspaceDirectory
     ⍝ Gets path section of ⎕WSID to Directory.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 WorkspaceDirectory←{(⍵{(':'=↑(¯1-⍵)↑⍺)-⍵}(⌽⍵)⍳'\')↓⍵}↑↑/2↑##.GetFullPathName ⎕WSID 1024 1024 0
∇

∇ IncludeWorkspaceDirectory;A;B;C
     ⍝ Include path section of ⎕WSID to enviroment variable PATH.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 A←B←(';'≠A)⊂A←EnvironmentVariable'PATH'
 :If ×⎕NC'_WsDir'
 :AndIf ∨/C←A∊⊂_WsDir
     A←(~C)/A
 :EndIf
 :If ~∨/A∊⊂_WsDir←((':'=↑(¯1-C)↑⎕WSID)-C←'\'⍳⍨⌽⎕WSID)↓⎕WSID←↑↑/2↑##.GetFullPathName ⎕WSID 1024 1024 0
     A,←⊂_WsDir
 :EndIf
 :If A≢B
     (1↓∊';',¨A)EnvironmentVariable'PATH'
 :EndIf
∇

∇ ProcessHandle←Open Parms;DesiredAccess;InheritHandle;ProcessId
     ⍝ Returns a handle of an existing process object
     ⍝
     ⍝ Parms[1] = ProcessId
     ⍝ Parms[2] = DesiredAccess (opt, default #.Win.MAXIMUM_ALLOWED)
     ⍝ Parms[3] = InheritHandle (opt, default 0)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Select ↑⍴Parms
 :CaseList 0 1
     ProcessId←↑Parms
     DesiredAccess←##.MAXIMUM_ALLOWED
     InheritHandle←0
 :Case 2
     ProcessId DesiredAccess←Parms
     InheritHandle←0
 :Case 3
     ProcessId DesiredAccess InheritHandle←Parms
 :Else
     #.RCode←##.ERROR_INVALID_PARAMETER
     ProcessHandle←##.INVALID_HANDLE_VALUE
     :Return
 :EndSelect
 :If ##.ZERO≠ProcessHandle←##.OpenProcess DesiredAccess InheritHandle ProcessId
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     ProcessHandle←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ {ValidFlag}←PriorityClass SetPriorityClass hProcess
     ⍝ Set the priority class for the specified process
     ⍝ This value together with the priority value of each thread
     ⍝ of the process determines each thread's base priority level
     ⍝
     ⍝ hProcess      = Handle to process
     ⍝ PriorityClass = #.Win.IDLE_PRIORITY_CLASS #.Win.NORMAL_PRIORITY_CLASS #.Win.HIGH_PRIORITY_CLASS #.Win.REALTIME_PRIORITY_CLASS W2K: #.Win.BELOW_NORMAL_PRIORITY_CLASS #.Win.ABOVE_NORMAL_PRIORITY_CLASS
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.SetPriorityClass hProcess PriorityClass
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←Priority SetThreadPriority hThread
     ⍝ Set the priority value for the specified thread
     ⍝ This value together with the priority class of the thread's
     ⍝ process, determines the thread's base-priority level
     ⍝
     ⍝ hThread  = Handle to the thread
     ⍝ Priority = #.Win.THREAD_PRIORITY_IDLE #.Win.THREAD_PRIORITY_LOWEST #.Win.THREAD_PRIORITY_BELOW_NORMAL #.Win.THREAD_PRIORITY_NORMAL #.Win.THREAD_PRIORITY_ABOVE_NORMAL #.Win.THREAD_PRIORITY_HIGHEST #.Win.THREAD_PRIORITY_TIME_CRITICAL
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ValidFlag←##.SetThreadPriority hThread Priority
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←Parms SetWorkingSetSize hProcess;_SetProcessWorkingSetSize;ValidFlag;MinimumWorkingSetSize;MaximumWorkingSetSize
     ⍝ Set the minimum and maximum working set sizes for the specified process
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ¯1 ¯1≡MinimumWorkingSetSize MaximumWorkingSetSize←2↑Parms
     MinimumWorkingSetSize MaximumWorkingSetSize←4294967295
 :EndIf
 :Trap 0
     '_SetProcessWorkingSetSize'⎕NA'I KERNEL32|SetProcessWorkingSetSize I U U'
     :If ValidFlag←_SetProcessWorkingSetSize hProcess MinimumWorkingSetSize MaximumWorkingSetSize
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     #.RCode←ERROR_CALL_NOT_IMPLEMENTED
     ValidFlag←0
 :EndTrap
∇

∇ {Directory}←SetWorkspaceDirectory Directory;WSID;A
     ⍝ Sets path section of ⎕WSID to Directory.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×↑⍴Directory←,Directory
     WSID←Directory,((':'=¯1↑Directory)-'\'⍳⍨⌽WSID)↑WSID←↑↑/2↑##.GetFullPathName ⎕WSID 1024 1024 0
     ⎕WSID←↑↑/2↑##.GetFullPathName WSID 1024 1024 0
     :If ×⎕NC'_WsDir'
         :If ∨/A←(Directory←WSID←(';'≠Directory)⊂Directory←EnvironmentVariable'PATH')∊⊂_WsDir
             Directory←(~A)/Directory
         :EndIf
         :If ~∨/Directory∊⊂_WsDir←((':'=↑(¯1-A)↑⎕WSID)-A←'\'⍳⍨⌽⎕WSID)↓⎕WSID←↑↑/2↑##.GetFullPathName ⎕WSID 1024 1024 0
             Directory,←⊂_WsDir
         :EndIf
         :If Directory≢WSID
             (1↓∊';',¨Directory)EnvironmentVariable'PATH'
         :EndIf
     :EndIf
 :EndIf
 Directory←((':'=↑(¯1-Directory)↑⎕WSID)-Directory←'\'⍳⍨⌽⎕WSID)↓⎕WSID←↑↑/2↑##.GetFullPathName ⎕WSID 1024 1024 0
∇

∇ {ValidFlag}←Sleep Milliseconds;Full;Last
     ⍝ Suspend the execution of the current thread for a specified interval
     ⍝
     ⍝ Milliseconds = Milliseconds to sleep or #.Win.INFINITE
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 Full Last←0(Milliseconds←25)⊤Milliseconds
 :Trap 1000
     :Repeat
         :If ¯1=Full←¯1+Full
             Milliseconds←Last
         :EndIf
         {}##.Sleep Milliseconds
     :Until ¯1=Full
     :OrIf 0 0≡Full Last
     #.RCode←##.ERROR_SUCCESS
     ValidFlag←1
 :Else
     #.RCode←##.ERROR_PROCESS_ABORTED
     ValidFlag←0
 :EndTrap
∇

∇ {ValidFlag}←TerminateProcess Parms;hProcess;ExitCode
     ⍝ Terminate a thread
     ⍝
     ⍝ Parms[1] = hProcess  Handle to the process to terminate
     ⍝ Parms[2] = ExitCode  Exit code for the process and for all threads terminated
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hProcess ExitCode←2↑Parms
 :If ValidFlag←##.TerminateProcess hProcess ExitCode
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {ValidFlag}←TerminateThread Parms;hThread;ExitCode
     ⍝ Terminate a thread
     ⍝
     ⍝ Parms[1] = hThread   Handle to the thread to terminate
     ⍝ Parms[2] = ExitCode  Exit code to be retrieved with function GetExitCodeThread
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hThread ExitCode←2↑Parms
 :If ValidFlag←##.TerminateThread hThread ExitCode
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Status←WaitForSingleObject Parms;hHandle;Milliseconds;Full;Last
     ⍝ Return when one of the following occurs: The specified object is in the signaled state. The time-out interval elapses
     ⍝
     ⍝ Parms[1] = hHandle
     ⍝ Parms[2] = Milliseconds to wait or #.Win.INFINITE
     ⍝
     ⍝ Status   = #.Win.WAIT_OBJECT_0  (0)   The state of the specified object is signaled
     ⍝ Status   = #.Win.WAIT_ABANDONED (128) The specified object is a mutex object that was released by thread terminate
     ⍝ Status   = #.Win.WAIT_TIMEOUT   (258) The time-out interval elapsed, and the object's state is nonsignaled
     ⍝ Status   = #.Win.WAIT_FAILED    (¯1)  The function fails, see #.RCode
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hHandle Milliseconds←2↑Parms,##.INFINITE
 Full Last←0(Milliseconds←25)⊤Milliseconds
 :Trap 1000
     :Repeat
         :If ¯1=Full←¯1+Full
             Milliseconds←Last
         :EndIf
         :If #.Win.WAIT_TIMEOUT≠Status←##.WaitForSingleObject hHandle Milliseconds
             :Leave
         :EndIf
     :Until ¯1=Full
     :OrIf 0 0≡Full Last
 :Else
     Status←##.WAIT_TIMEOUT
 :EndTrap
 #.RCode←##.GetLastError
∇

:Namespace Samples
⎕IO ⎕ML ⎕WX ⎕CT←1 3 1 9.999999999999998E¯15

∇ EmptyAllOtherWorkingSets;hToken;PreviousState;ProcessId;hProcess
 #.Win.Init
 :If #.Win.INVALID_HANDLE_VALUE≠hToken←#.Win.Security.OpenProcessToken #.Win.Proc.GetCurrentProcess(#.Win.TOKEN_ADJUST_PRIVILEGES+#.Win.TOKEN_QUERY)
     PreviousState←#.Win.Security.AdjustTokenPrivileges #.Win.Sys.GetComputerName hToken 0(#.Win.SE_DEBUG_NAME #.Win.SE_PRIVILEGE_ENABLED)
     :For ProcessId :In #.Win.Proc.EnumProcesses~#.Win.Proc.GetCurrentProcessId
         :If #.Win.INVALID_HANDLE_VALUE≠hProcess←#.Win.Proc.Open ProcessId #.Win.PROCESS_ALL_ACCESS
             #.Win.Proc.EmptyWorkingSet hProcess
             #.Win.Proc.Close hProcess
         :EndIf
     :EndFor
     #.Win.Security.AdjustTokenPrivileges #.Win.Sys.GetComputerName hToken 0,PreviousState
     #.Win.Security.Close hToken
 :EndIf
∇

∇ List←GetProcessList;hToken;PreviousState;ProcessId;hProcess;hModules;ModuleCount;hModule;FileName;BaseName;MinimumWorkingSetSize;MaximumWorkingSetSize;PriorityClass
 #.Win.Init
     ⍝ Try to get extra privileges
 :If #.Win.INVALID_HANDLE_VALUE≠hToken←#.Win.Security.OpenProcessToken #.Win.Proc.GetCurrentProcess(#.Win.TOKEN_ADJUST_PRIVILEGES+#.Win.TOKEN_QUERY)
     PreviousState←#.Win.Security.AdjustTokenPrivileges #.Win.Sys.GetComputerName hToken 0(#.Win.SE_DEBUG_NAME #.Win.SE_PRIVILEGE_ENABLED)
 :EndIf
     ⍝ Build up process list
 List←0 6⍴⊂''
 :For ProcessId :In #.Win.Proc.EnumProcesses
     ⍝ Try to open process
     :If #.Win.INVALID_HANDLE_VALUE≠hProcess←#.Win.Proc.Open ProcessId #.Win.MAXIMUM_ALLOWED
     ⍝ Get module handles
         hModules←#.Win.Library.EnumModules hProcess
     ⍝ Retrive BaseName and alternatively FileName of process
         hModule←↑hModules
         BaseName←#.Win.Library.GetModuleBaseName hProcess hModule
         FileName←#.Win.Library.GetModuleFileName hProcess hModule
     ⍝ Special treatments
         :If 2 ''≡ProcessId FileName
             BaseName←'System'
             FileName←'System'
         :EndIf
     ⍝ Retrive WorkingSetSizes of process
         MinimumWorkingSetSize MaximumWorkingSetSize←#.Win.Proc.GetWorkingSetSize hProcess
         MinimumWorkingSetSize←(⍕MinimumWorkingSetSize÷1024),'KB'
         MaximumWorkingSetSize←(⍕MaximumWorkingSetSize÷1024),'KB'
     ⍝ Retrive ModuleCount of process
         ModuleCount←⍕↑⍴hModules
     ⍝ Retrive PriorityClass of process
         PriorityClass←#.Win.Proc.GetPriorityClass hProcess
         PriorityClass←(#.Win.IDLE_PRIORITY_CLASS #.Win.NORMAL_PRIORITY_CLASS #.Win.HIGH_PRIORITY_CLASS #.Win.REALTIME_PRIORITY_CLASS #.Win.BELOW_NORMAL_PRIORITY_CLASS #.Win.ABOVE_NORMAL_PRIORITY_CLASS 0⍳PriorityClass)⊃'Idle' 'Normal' 'High' 'Realtime' '< Normal' '> Normal' 'Unknown'(⍕PriorityClass)
     ⍝ Close this process
         #.Win.Proc.Close hProcess
     ⍝ Special treatments
     :ElseIf ProcessId=0
         BaseName MinimumWorkingSetSize MaximumWorkingSetSize ModuleCount PriorityClass←'Idle' '???' '???' '???' 'Unknown'
     :Else
         BaseName MinimumWorkingSetSize MaximumWorkingSetSize ModuleCount PriorityClass←'???' '???' '???' '???' 'Unknown'
     :EndIf
     ⍝ Append to optput list
     List⍪←(⍕ProcessId)BaseName MinimumWorkingSetSize MaximumWorkingSetSize ModuleCount PriorityClass
 :EndFor
     ⍝ Reset to previous privileges
 :If #.Win.INVALID_HANDLE_VALUE≠hToken
     #.Win.Security.AdjustTokenPrivileges #.Win.Sys.GetComputerName hToken 0,PreviousState
     #.Win.Security.Close hToken
 :EndIf
∇

:EndNamespace 
:EndNamespace 
:Namespace Profile
⎕IO ⎕ML ⎕WX←1 3 1

∇ String←GetString Parms;FileName;AppName;KeyName;FileNameBufferSize;GetStringBufferSize
     ⍝ Get the sections, keys or values of a profile file (eg .INI or .INF)
     ⍝
     ⍝ Parms    = FileName
     ⍝ or
     ⍝ Parms[1] = FileName/s
     ⍝ String   = SectionNames
     ⍝
     ⍝ Parms[1] = FileName/s
     ⍝ Parms[2] = SectionName/s
     ⍝ String   = KeyNames
     ⍝
     ⍝ Parms[1] = FileName/s
     ⍝ Parms[2] = SectionName/s
     ⍝ Parms[3] = KeyName/s
     ⍝ String   = Values
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 FileNameBufferSize←1024
 GetStringBufferSize←8192
 ##.Init
 :If 1<≡Parms
     :Select ↑⍴,Parms
     :Case 1
         :Select ≡FileName←↑Parms
         :CaseList 0 1
             :If ×↑⍴FileName←↑↑/2↑##.SearchPathI 0 FileName 0 FileNameBufferSize FileNameBufferSize 1
                 #.RCode←##.ERROR_SUCCESS
                 String←{(⍵≠↑⎕AV)⊂⍵}↑↑/##.GetPrivateProfileStringS 0 0 ''GetStringBufferSize GetStringBufferSize FileName
             :Else
                 #.RCode←##.GetLastError
                 String←''
             :EndIf
         :Case 2
             :If ×↑⍴FileName←↑∘↑/¨2↑¯##.SearchPathI¨0,¨(⊂¨FileName),¨⊂0 FileNameBufferSize FileNameBufferSize 1
                 #.RCode←##.ERROR_SUCCESS
                 String←{(⍵≠↑⎕AV)⊂¨⍵}↑¨↑/¨##.GetPrivateProfileStringS 0 0 ''GetStringBufferSize GetStringBufferSize∘,¨⊂¨FileName
             :Else
                 #.RCode←##.GetLastError
                 String←0⍴⊂''
             :EndIf
         :Else
             String←''
         :EndSelect
     :Case 2
         :If 1<≡↑FileName AppName←Parms
             String←GetString¨(⊂¨FileName),¨⊂¨AppName
         :ElseIf ×↑⍴FileName←↑↑/2↑##.SearchPathI 0 FileName 0 FileNameBufferSize FileNameBufferSize 1
             #.RCode←##.ERROR_SUCCESS
             :Select ≡AppName
             :CaseList 0 1
                 String←{(⍵≠↑⎕AV)⊂⍵}↑↑/##.GetPrivateProfileStringK AppName 0 ''GetStringBufferSize GetStringBufferSize FileName
             :Case 2
                 String←{(⍵≠↑⎕AV)⊂¨⍵}↑¨↑/¨##.GetPrivateProfileStringK¨(⊂¨AppName),¨⊂0 ''GetStringBufferSize GetStringBufferSize FileName
             :Else
                 String←''
             :EndSelect
         :Else
             #.RCode←##.GetLastError
             String←''
         :EndIf
     :Case 3
         :If 1<≡↑FileName AppName KeyName←Parms
             String←GetString¨(⊂¨FileName),¨(⊂¨AppName),¨⊂¨KeyName
         :ElseIf ×↑⍴FileName←↑↑/2↑##.SearchPathI 0 FileName 0 FileNameBufferSize FileNameBufferSize 1
             #.RCode←##.ERROR_SUCCESS
             :Select ≡KeyName
             :CaseList 0 1
                 String←↑↑/##.GetPrivateProfileStringV AppName KeyName''GetStringBufferSize GetStringBufferSize FileName
             :Case 2
                 :If 2≠≡AppName
                     AppName←⊂AppName
                 :EndIf
                 String←↑¨↑/¨##.GetPrivateProfileStringV¨(⊂¨AppName),¨(⊂¨KeyName),¨⊂''GetStringBufferSize GetStringBufferSize FileName
             :Case 3
                 String←↑¨¨↑/¨¨##.GetPrivateProfileStringV¨¨(,∘''GetStringBufferSize GetStringBufferSize FileName)¨¨(⊂∘⊂¨AppName),∘⊂¨¨KeyName
             :Else
                 String←''
             :EndSelect
         :Else
             #.RCode←##.GetLastError
             String←''
         :EndIf
     :Else
         String←''
     :EndSelect
 :ElseIf ×↑⍴Parms←↑↑/2↑##.SearchPathI 0 Parms 0 FileNameBufferSize FileNameBufferSize 1
     #.RCode←##.ERROR_SUCCESS
     String←{(⍵≠↑⎕AV)⊂⍵}↑↑/##.GetPrivateProfileStringS 0 0 ''GetStringBufferSize GetStringBufferSize Parms
 :Else
     #.RCode←##.GetLastError
     String←''
 :EndIf
∇

∇ {Bool}←{String}SetString Parms;AppName;KeyName;FileName
     ⍝ Set the value of a profile file (eg .INI or .INF)
     ⍝ or delete its section or entry, or flush profile buffer
     ⍝
     ⍝ String   = Value       Set the value for a key name
     ⍝ Parms[1] = FileName
     ⍝ Parms[2] = SectionName
     ⍝ Parms[3] = KeyName
     ⍝
     ⍝ Parms[1] = FileName    Delete the key name
     ⍝ Parms[2] = SectionName
     ⍝ Parms[3] = KeyName
     ⍝
     ⍝ Parms[1] = FileName    Delete the section
     ⍝ Parms[2] = SectionName
     ⍝
     ⍝ Parms    = FileName    Flush the file
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×⎕NC'String'
     FileName AppName KeyName←3↑Parms
     :If Bool←##.WritePrivateProfileStringV AppName KeyName String FileName
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     :If 2>≡Parms
         Parms←,⊂,Parms
     :EndIf
     :Select ↑⍴,Parms
     :Case 1
         FileName←Parms
         :If Bool←##.WritePrivateProfileStringF ##.NULL ##.NULL ##.NULL FileName
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
         :EndIf
     :Case 2
         FileName AppName←Parms
         :If Bool←##.WritePrivateProfileStringS AppName ##.NULL ##.NULL FileName
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
         :EndIf
     :Case 3
         FileName AppName KeyName←Parms
         :If Bool←##.WritePrivateProfileStringK AppName KeyName ##.NULL FileName
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
         :EndIf
     :EndSelect
 :EndIf
∇

:Namespace Samples
⎕IO ⎕ML ⎕WX←1 3 1

∇ Retrn←GetWinIni;FileName;SectionNames;KeyNames;Values
 FileName←'WIN.INI'
 SectionNames←#.Win.Profile.GetString FileName
 KeyNames←#.Win.Profile.GetString FileName SectionNames
 Values←#.Win.Profile.GetString FileName SectionNames KeyNames
 Retrn←SectionNames,[1.5]KeyNames,[1.5]¨Values
∇

:EndNamespace 
:EndNamespace 
:Namespace Reg
⎕IO ⎕ML ⎕WX←1 3 1

∇ {InvalidFlag}←CloseKey hKey
     ⍝ Release a handle to the specified registry key
     ⍝
     ⍝ hKey        = Handle to an open key
     ⍝
     ⍝ InvalidFlag = 0:Ok 1:Error
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 InvalidFlag←##.ERROR_SUCCESS≠#.RCode←##.RegCloseKey hKey
∇

∇ hkResult←CreateKey Parms;hKey;SubKey;Class;samDesired;Options;Disposition
     ⍝ Create the specified registry key. If it already exists, the function opens it.
     ⍝
     ⍝ Parms[1]      = hKey       Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2]      = SubKey     Subkey name to create or open, must not begin with '\'
     ⍝ Parms[3]      = Class      (opt) Class string (object type) of this key. Ignored if key already exists. No classes are currently defined, applications should omit this parameter.
     ⍝ Parms[3 or 4] = samDesired (opt, required if Options is specified) #.Win.KEY_ALL_ACCESS (def) #.Win.KEY_READ #.Win.KEY_WRITE  #.Win.KEY_CREATE_LINK #.Win.KEY_CREATE_SUB_KEY #.Win.KEY_ENUMERATE_SUB_KEYS #.Win.KEY_EXECUTE #.Win.KEY_NOTIFY #.Win.KEY_QUERY_VALUE or #.Win.KEY_SET_VALUE
     ⍝ Parms[4 or 5] = Options    (opt) Default: Create in file (#.Win.REG_OPTION_NON_VOLATILE). Memory only (#.Win.REG_OPTION_VOLATILE), or for backup (#.Win.REG_OPTION_BACKUP_RESTORE)
     ⍝
     ⍝ hkResult      = Handle to created or opened registry key or on error #.Win.INVALID_HANDLE_VALUE
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Select ↑⍴Parms
 :Case 2
     hKey SubKey←Parms
     Class samDesired Options←''##.KEY_ALL_ACCESS ##.REG_OPTION_NON_VOLATILE
 :Case 3
     hKey SubKey Class←Parms
     :If 82=⎕DR Class
         samDesired Options←##.KEY_ALL_ACCESS ##.REG_OPTION_NON_VOLATILE
     :Else
         Class samDesired Options←''Class ##.REG_OPTION_NON_VOLATILE
     :EndIf
 :Case 4
     hKey SubKey Class samDesired←Parms
     :If 82=⎕DR Class
         Options←##.REG_OPTION_NON_VOLATILE
     :Else
         Class samDesired Options←''Class samDesired
     :EndIf
 :Case 5
     hKey SubKey Class samDesired Options←Parms
 :Else
     #.RCode←##.ERROR_INVALID_PARAMETER
     hkResult←##.INVALID_HANDLE_VALUE
     :Return
 :EndSelect
 :If ##.ERROR_SUCCESS≠↑#.RCode hkResult Disposition←##.RegCreateKeyEx hKey SubKey 0 Class Options samDesired 0 1 1
     hkResult←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ {InvalidFlag}←DeleteKey Parms;hKey;SubKey;RecursiveFlag
     ⍝ Delete a subkey and its values, optionaly all its recursively subkeys and its values
     ⍝ CAUTION: With the RecursiveFlag set, you might destroy complete registry paths of arbitrary depth !
     ⍝
     ⍝ Parms[1]    = hKey          Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2]    = SubKey        Subkey name to delete, must not begin with '\', ('' cannot be deleted, though its recursively subkeys can)
     ⍝ Parms[3]    = RecursiveFlag (opt) Default #.Win.FALSE, if #.Win.TRUE: recursively delete keys
     ⍝
     ⍝ InvalidFlag = 0:Ok 1:Error
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 3=↑⍴Parms
     hKey SubKey RecursiveFlag←Parms
 :AndIf ##.TRUE=RecursiveFlag
     #.RCode←##.ERROR_SUCCESS
     InvalidFlag←hKey{0≡⍵:0
         ##.ERROR_SUCCESS≠↑RCode hSubKey←##.RegOpenKeyEx ⍺ ⍵ 0 ##.KEY_ALL_ACCESS 1:{1}#.RCode⌈←RCode
         (##.ERROR_SUCCESS≠#.RCode⌈←##.RegCloseKey hSubKey)∨∨/hSubKey ∇¨{⍵{##.ERROR_SUCCESS≠#.RCode⌈←↑⍵:⍬
                 0=2⊃⍵:⍬
                 {{0∊⍴⍵:⍬ ⋄ {⍵[3]↑2⊃⍵}¨⍵}(##.ERROR_SUCCESS=↑¨⍵)/⍵}##.RegEnumKeyExS¨⍺,¨(¯1+⍳2⊃⍵),¨⊂6↑2⍴1+3⊃⍵}##.RegQueryInfoKeyS ⍵,0 0 0 1 1 0 0 0 0 0 0
         }hSubKey:1
         ##.ERROR_SUCCESS≠#.RCode⌈←##.RegDeleteKey ⍺ ⍵}SubKey
 :Else
     hKey SubKey←2↑Parms
     InvalidFlag←##.ERROR_SUCCESS≠#.RCode←##.RegDeleteKey hKey SubKey
 :EndIf
∇

∇ {InvalidFlag}←DeleteValue Parms;hKey;SubKey;ValueName
     ⍝ Delete ValueName in a given "hKey {SubKey}"
     ⍝
     ⍝ Parms[1]    = hKey      Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2]    = ValueName Name of the value to delete
     ⍝ or
     ⍝ Parms[1]    = hKey      Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2]    = SubKey    Subkey name to delete, must not begin with '\'
     ⍝ Parms[3]    = ValueName Name of the value to delete
     ⍝
     ⍝ InvalidFlag = 0:Ok 1:Error
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1999
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2=↑⍴Parms
     hKey ValueName←Parms
     SubKey←''
 :ElseIf ''≢2⊃hKey SubKey ValueName←3↑Parms
 :AndIf InvalidFlag←##.ERROR_SUCCESS≠↑#.RCode hKey←##.RegOpenKeyEx hKey SubKey 0 ##.KEY_SET_VALUE 1
     :Return
 :EndIf
 InvalidFlag←##.ERROR_SUCCESS≠#.RCode←##.RegDeleteValue hKey ValueName
 :If ''≢SubKey
     InvalidFlag∨←##.ERROR_SUCCESS≠#.RCode⌈←##.RegCloseKey hKey
 :EndIf
∇

∇ SubKeys←{Depth}EnumKey Parms;hKey;SubKey;VOID;cSubKeys;cbMaxSubKeyLen;cbMaxClassLen;cValues;hSubKeys;ValidSubKeys
     ⍝ List all SubKeys of a given "hKey {SubKey}" within "Depth" levels deep
     ⍝
     ⍝ Parms[1]    = hKey   Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2]    = SubKey (opt) Subkey name, where to begin enumeration, must not begin with '\'
     ⍝
     ⍝ Depth       =        Number of recursive subkeys to enumerate
     ⍝
     ⍝ SubKeys[;1] = Depth
     ⍝ SubKeys[;2] = Name
     ⍝ SubKeys[;3] = Class
     ⍝ SubKeys[;4] = LastWriteTime
     ⍝ SubKeys[;5] = Number of SubKeys
     ⍝ SubKeys[;6] = Number of SubValues
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1999
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2≠⎕NC'Depth'
     Depth←0
 :EndIf
 :If 2>≡Parms
     hKey←Parms
     SubKey←''
 :ElseIf ''≢2⊃hKey SubKey←2↑Parms
 :AndIf ##.ERROR_SUCCESS≠↑#.RCode hKey←##.RegOpenKeyEx hKey SubKey 0 ##.KEY_READ 1
     SubKeys←0 6⍴0 '' ''(8⍴0)0 0
     :If 2=↑⍴Depth
         SubKeys←SubKeys(0 0)
     :EndIf
     :Return
 :EndIf
 :If ##.ERROR_SUCCESS=#.RCode←↑VOID cSubKeys cbMaxSubKeyLen cbMaxClassLen cValues←0 0 1 1 0+##.RegQueryInfoKeyK hKey 0 0 0 1 1 1 1 0 0 0 0
 :AndIf ×↑⍴SubKeys←⊃##.RegEnumKeyEx¨hKey,¨(¯1+⍳cSubKeys),¨⊂cbMaxSubKeyLen cbMaxSubKeyLen 0 cbMaxClassLen cbMaxClassLen 1
 :AndIf ##.ERROR_SUCCESS=#.RCode←⌈/SubKeys[;1]
     SubKeys←(2⊃2↑Depth),(SubKeys[;3 5]↑¨SubKeys[;2 4]),{⍵[1 2 4 5 6 7 8 3]}¨↑¨×/¨##.FileTimeToSystemTime¨(1↓¨##.FileTimeToLocalFileTime¨(⊂¨SubKeys[;6]),¨0),¨0
     SubKeys←SubKeys[⍋#.Uppercase⊃SubKeys[;2];]
     :If 0<↑Depth
         SubKeys←SubKeys{↑⍪/(⊂[2]⍺,⊃2⊃⍵)⍪¨↑⍵}⊂[1]⊃(¯1 1+2↑Depth)∘EnumKey¨hKey,¨⊂¨SubKeys[;2]
     :ElseIf ×↑⍴hSubKeys←##.RegOpenKeyEx¨hKey,¨(⊂¨SubKeys[;2]),¨⊂0 ##.KEY_READ 1
     :AndIf ×↑⍴hSubKeys←(ValidSubKeys←##.ERROR_SUCCESS=↑¨hSubKeys)/2⊃¨hSubKeys
         SubKeys←SubKeys,⊃ValidSubKeys\{(##.ERROR_SUCCESS=↑¨⍵)×1↓¨⍵}##.RegQueryInfoKeyC¨hSubKeys,¨⊂0 0 0 1 0 0 1 0 0 0 0
         VOID←##.RegCloseKey¨hSubKeys
     :Else
         SubKeys←6↑[2]SubKeys
     :EndIf
     :If ''≢SubKey
     :AndIf ##.ERROR_SUCCESS≠#.RCode←##.RegCloseKey hKey
         SubKeys←0 6⍴0 '' ''(8⍴0)0 0
     :EndIf
 :Else
     :If ''≢SubKey
         VOID←##.RegCloseKey hKey
     :EndIf
     SubKeys←0 6⍴0 '' ''(8⍴0)0 0
 :EndIf
 :If 2=↑⍴Depth
     SubKeys←SubKeys(cSubKeys cValues)
 :EndIf
∇

∇ SubKeys←{Depth}EnumKeyShort Parms;hKey;SubKey;VOID;cSubKeys;cbMaxSubKeyLen
     ⍝ List all SubKeys unsorted of a given "hKey {SubKey}" within "Depth" levels deep
     ⍝
     ⍝ Parms[1]    = hKey   Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2]    = SubKey (opt) Subkey name, where to begin enumeration, must not begin with '\'
     ⍝
     ⍝ Depth       =        Number of recursive subkeys to enumerate
     ⍝
     ⍝ SubKeys[;1] = Depth
     ⍝ SubKeys[;2] = Name
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1999
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     hKey←Parms
     SubKey←''
 :ElseIf ''≢2⊃hKey SubKey←2↑Parms
 :AndIf ##.ERROR_SUCCESS≠↑#.RCode hKey←##.RegOpenKeyEx hKey SubKey 0 ##.KEY_READ 1
     SubKeys←0 2⍴0 ''
     :Return
 :EndIf
 :If ##.ERROR_SUCCESS=#.RCode←↑VOID cSubKeys cbMaxSubKeyLen←0 0 1+##.RegQueryInfoKeyS hKey 0 0 0 1 1 0 0 0 0 0 0
 :AndIf ×↑⍴SubKeys←⊃##.RegEnumKeyExS¨hKey,¨(¯1+⍳cSubKeys),¨⊂cbMaxSubKeyLen cbMaxSubKeyLen 0 0 0 0
 :AndIf ##.ERROR_SUCCESS=#.RCode←⌈/SubKeys[;1]
     SubKeys←0,[1.5]SubKeys[;3]↑¨SubKeys[;2]
     :If ×⎕NC'Depth'
     :AndIf 0<Depth
         SubKeys←↑,[1]/(⊂[2]SubKeys)⍪¨{(1+1↑[2]⍵),1↓[2]⍵}¨(Depth-1)EnumKeyShort¨hKey,¨⊂¨SubKeys[;2]
     :EndIf
     :If ''≢SubKey
     :AndIf ##.ERROR_SUCCESS≠#.RCode←##.RegCloseKey hKey
         SubKeys←0 2⍴0 ''
     :EndIf
 :Else
     :If ''≢SubKey
         VOID←##.RegCloseKey hKey
     :EndIf
     SubKeys←0 2⍴0 ''
 :EndIf
∇

∇ Values←{Raw}EnumValue Parms;hKey;SubKey;VOID;cValues;cbMaxValueNameLen;cbMaxValueLen
     ⍝ List all Values of a given "hKey {SubKey}"
     ⍝
     ⍝ Parms[1]   = hKey   Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2]   = SubKey (opt) Subkey name, where to begin enumeration, must not begin with '\'
     ⍝
     ⍝ Raw        =        (opt) Default #.Win.FALSE, if #.Win.TRUE: #.Win.REG_EXPAND_SZ type values are not expanded
     ⍝
     ⍝ Values[;1] = ValueName
     ⍝ Values[;2] = Type
     ⍝ Values[;3] = Data
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1999
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     hKey←Parms
     SubKey←''
 :ElseIf ''≢2⊃hKey SubKey←2↑Parms
 :AndIf ##.ERROR_SUCCESS≠↑#.RCode hKey←##.RegOpenKeyEx hKey SubKey 0 ##.KEY_READ 1
     Values←0 3⍴'' 0 0
     :Return
 :EndIf
 :If ##.ERROR_SUCCESS=#.RCode←↑VOID cValues cbMaxValueNameLen cbMaxValueLen←0 0 1 1+##.RegQueryInfoKeyV hKey 0 0 0 0 0 0 1 1 1 0 0
 :AndIf ×↑⍴Values←⊃##.RegEnumValue¨hKey,¨(¯1+⍳cValues),¨⊂cbMaxValueNameLen cbMaxValueNameLen 0 1 cbMaxValueLen cbMaxValueLen
 :AndIf ##.ERROR_SUCCESS=#.RCode←⌈/Values[;1]
     :For cValues :In ⍳cValues
         :Select Values[cValues;4]
         :Case ##.REG_SZ
             Values[cValues;5]←⊂(Values[cValues;6]-1)↑↑Values[cValues;5]
         :Case ##.REG_DWORD
             Values[cValues;5]←↑4 ##.IntTxt 4↑↑Values[cValues;5]
         :Case ##.REG_EXPAND_SZ
             :If ×⎕NC'Raw'
             :AndIf ##.FALSE≠Raw
                 Values[cValues;5]←⊂(Values[cValues;6]-1)↑↑Values[cValues;5]
             :Else
                 Values[cValues;5]←⊂2⊃##.ExpandEnvironmentStrings Values[cValues;6]{(⊂(⍺-1)↑⍵),2⍴##.MAX_PATH+⍺}↑Values[cValues;5]
             :EndIf
         :Case ##.REG_MULTI_SZ
             Values[cValues;5]←⊂{(⍵≠↑⎕AV)⊂⍵}Values[cValues;6]↑↑Values[cValues;5]
         :CaseList ##.REG_BINARY ##.REG_RESOURCE_LIST
             Values[cValues;5]←⊂##.IntTxt Values[cValues;6]↑↑Values[cValues;5]
         :Case ##.REG_DWORD_BIG_ENDIAN
             Values[cValues;5]←↑4 ##.IntTxt⌽4↑↑Values[cValues;5]
         :Else
             Values[cValues;5]←⊂Values[cValues;6]↑↑Values[cValues;5]
         :EndSelect
     :EndFor
     Values←(Values[;3]↑¨Values[;2]),Values[;4 5]
     Values←Values[⍋#.Uppercase⊃Values[;1];]
     :If ''≢SubKey
     :AndIf ##.ERROR_SUCCESS≠#.RCode←##.RegCloseKey hKey
         Values←0 3⍴'' 0 0
     :EndIf
 :Else
     :If ''≢SubKey
         VOID←##.RegCloseKey hKey
     :EndIf
     Values←0 3⍴'' 0 0
 :EndIf
∇

 FullKeyPath←{
     ⍝ Expand Depth and SubKeys to full path SubKey names
     ⍝
     ⍝ Sample:
     ⍝ SubKeys←100 #.Win.Reg.EnumKeyShort hKey SubKey
     ⍝ FullPathSubKeys←(SubKey,'\')∘,¨SubKeys #.Win.Reg.FullKeyPath⍳↑⍴SubKeys
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1999
     ⍝ mailto:Hager@Dortmund.net
     ×≡⍵:⍺∘∇¨⍵ ⋄ 1↓∊'\',¨⍺[1+⍵-⍺[⌽⍳⍵;1]⍳0,⍳⍺[⍵;1];2]}

∇ SecurityDescriptor←GetKeySecurity Parms;hKey;SubKey;SecurityInformation;hKeyBase;cbSecurityDescriptor;VOID
     ⍝ GetKeySecurity for a given "hKey {SubKey}"
     ⍝
     ⍝ Parms[1] = hKey                Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2] = SecurityInformation #.Win.OWNER_SECURITY_INFORMATION+#.Win.GROUP_SECURITY_INFORMATION+#.Win.DACL_SECURITY_INFORMATION+#.Win.SACL_SECURITY_INFORMATION
     ⍝ or
     ⍝ Parms[1] = hKey                Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2] = SubKey              Subkey name to get information about, must not begin with '\'
     ⍝ Parms[3] = SecurityInformation #.Win.OWNER_SECURITY_INFORMATION+#.Win.GROUP_SECURITY_INFORMATION+#.Win.DACL_SECURITY_INFORMATION+#.Win.SACL_SECURITY_INFORMATION
     ⍝
     ⍝ Return: SecurityDescriptor or ⍬ on Error
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1999
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2=↑⍴Parms
     hKey SecurityInformation←Parms
     SubKey←''
 :ElseIf ''≢2⊃hKey SubKey SecurityInformation←3↑Parms
     hKeyBase←hKey
 :AndIf ##.ERROR_SUCCESS≠↑#.RCode hKey←##.RegOpenKeyEx hKeyBase SubKey 0 ##.KEY_READ 1
 :AndIf ##.ERROR_SUCCESS≠↑#.RCode hKey←##.RegOpenKeyEx hKeyBase SubKey 0 ##.STANDARD_RIGHTS_READ 1
     SecurityDescriptor←⍬
     :Return
 :EndIf
 cbSecurityDescriptor←0
 :If ##.ERROR_INSUFFICIENT_BUFFER=↑#.RCode SecurityDescriptor cbSecurityDescriptor←##.RegGetKeySecurity hKey SecurityInformation cbSecurityDescriptor cbSecurityDescriptor
 :AndIf ##.ERROR_SUCCESS≠↑#.RCode SecurityDescriptor cbSecurityDescriptor←##.RegGetKeySecurity hKey SecurityInformation cbSecurityDescriptor cbSecurityDescriptor
 :AndIf ''≢SubKey
     VOID←##.RegCloseKey hKey
     SecurityDescriptor←⍬
 :ElseIf ##.ERROR_SUCCESS≠#.RCode
 :AndIf ''≢SubKey
     VOID←##.RegCloseKey hKey
     SecurityDescriptor←⍬
 :ElseIf ''≢SubKey
 :AndIf ##.ERROR_SUCCESS≠#.RCode←##.RegCloseKey hKey
     SecurityDescriptor←⍬
 :Else
     SecurityDescriptor←cbSecurityDescriptor↑SecurityDescriptor
 :EndIf
∇

∇ Value←{Raw}GetValue Parms;hKey;SubKey;ValueName;Raw;Type;Data;cbData;VOID
     ⍝ Retrieve the type and data for a specified value name associated with an open registry key.
     ⍝ With "Raw≠FALSE" REG_EXPAND_SZ type values are not expanded.
     ⍝
     ⍝ Parms    = hKey      (ValueName=default)
     ⍝ or
     ⍝ Parms[1] = hKey      Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2] = ValueName Name of the value to query
     ⍝ or
     ⍝ Parms[1] = hKey      Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2] = SubKey    Subkey name to get value from, must not begin with '\'
     ⍝ Parms[3] = ValueName Name of the value to query
     ⍝
     ⍝ Raw      =           (opt) Default #.Win.FALSE, if #.Win.TRUE: #.Win.REG_EXPAND_SZ type values are not expanded
     ⍝
     ⍝ Value[1] = Data      Value’s data of the specified Type
     ⍝ Value[2] = Type      #.Win.REG_NONE #.Win.REG_SZ #.Win.REG_EXPAND_SZ #.Win.REG_BINARY #.Win.REG_DWORD #.Win.REG_DWORD_BIG_ENDIAN #.Win.REG_LINK #.Win.REG_MULTI_SZ #.Win.REG_RESOURCE_LIST #.Win.REG_FULL_RESOURCE_DESCRIPTOR #.Win.REG_RESOURCE_REQUIREMENTS_LIST
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1999
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     hKey←↑Parms
     SubKey←ValueName←''
 :Else
     :Select ↑⍴Parms
     :Case 1
         hKey←↑Parms
         SubKey←ValueName←''
     :Case 2
         hKey ValueName←Parms
         SubKey←''
     :Case 3
         hKey SubKey ValueName←Parms
     :Else
         #.RCode←##.ERROR_INVALID_PARAMETER
         Value←''##.REG_NONE
         :Return
     :EndSelect
 :EndIf
 :If ''≢SubKey
 :AndIf ##.ERROR_SUCCESS≠↑#.RCode hKey←##.RegOpenKeyEx hKey SubKey 0 ##.KEY_READ 1
     Value←''##.REG_NONE
 :Else
     cbData←1024
     :While ##.ERROR_MORE_DATA=↑#.RCode Type Data cbData←##.RegQueryValueExT hKey ValueName 0 1 cbData cbData
         cbData+←1024
     :EndWhile
     :If ##.ERROR_SUCCESS≠#.RCode
         :If ''≢SubKey
             VOID←##.RegCloseKey hKey
         :EndIf
         Value←''##.REG_NONE
     :ElseIf ''≢SubKey
     :AndIf ##.ERROR_SUCCESS≠#.RCode←##.RegCloseKey hKey
         Value←''##.REG_NONE
     :Else
         :Select Type
         :Case ##.REG_SZ
             Data←(cbData-1)↑Data
         :Case ##.REG_DWORD
             Data←↑4 ##.IntTxt 4↑Data
         :Case ##.REG_EXPAND_SZ
             :If ×⎕NC'Raw'
             :AndIf ##.FALSE≠Raw
                 Data←(cbData-1)↑Data
             :Else
                 Data←2⊃##.ExpandEnvironmentStrings(⊂(cbData-1)↑Data),2⍴##.MAX_PATH+cbData
             :EndIf
         :Case ##.REG_MULTI_SZ
             Data←(Data≠↑⎕AV)⊂Data←cbData↑Data
         :CaseList ##.REG_BINARY ##.REG_RESOURCE_LIST
             Data←cbData↑Data
         :Case ##.REG_DWORD_BIG_ENDIAN
             Data←↑4 ##.IntTxt⌽4↑Data
         :Else
             Data←cbData↑Data
         :EndSelect
         Value←Data Type
     :EndIf
 :EndIf
∇

∇ hkResult←OpenKey Parms;hKey;SubKey;samDesired
     ⍝ Open the specified registry key
     ⍝
     ⍝ Parms[1] = hKey       Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2] = SubKey     Subkey name to open, must not begin with '\'
     ⍝ Parms[3] = samDesired (opt) #.Win.KEY_ALL_ACCESS (def) #.Win.KEY_READ #.Win.KEY_WRITE  #.Win.KEY_CREATE_LINK #.Win.KEY_CREATE_SUB_KEY #.Win.KEY_ENUMERATE_SUB_KEYS #.Win.KEY_EXECUTE #.Win.KEY_NOTIFY #.Win.KEY_QUERY_VALUE or #.Win.KEY_SET_VALUE
     ⍝
     ⍝ hkResult =            Handle to opened registry key or on error #.Win.INVALID_HANDLE_VALUE
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hKey SubKey samDesired←3↑Parms
 :If 0=samDesired
     samDesired←##.KEY_ALL_ACCESS
 :EndIf
 :If ##.ERROR_SUCCESS≠↑#.RCode hkResult←##.RegOpenKeyEx hKey SubKey 0 samDesired 1
     hkResult←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ {InvalidFlag}←SecurityDescriptor SetKeySecurity Parms;hKey;SubKey;SecurityInformation;hKeyBase
     ⍝ SetKeySecurity for a given "hKey {SubKey}"
     ⍝
     ⍝ Parms[1] = hKey                Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2] = SecurityInformation #.Win.OWNER_SECURITY_INFORMATION+#.Win.GROUP_SECURITY_INFORMATION+#.Win.DACL_SECURITY_INFORMATION+#.Win.SACL_SECURITY_INFORMATION
     ⍝ or
     ⍝ Parms[1] = hKey                Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2] = SubKey              Subkey name to get information about, must not begin with '\'
     ⍝ Parms[3] = SecurityInformation #.Win.OWNER_SECURITY_INFORMATION+#.Win.GROUP_SECURITY_INFORMATION+#.Win.DACL_SECURITY_INFORMATION+#.Win.SACL_SECURITY_INFORMATION
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1999
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2=↑⍴Parms
     hKey SecurityInformation←Parms
     SubKey←''
 :ElseIf ''≢2⊃hKey SubKey SecurityInformation←3↑Parms
     hKeyBase←hKey
 :AndIf InvalidFlag←##.ERROR_SUCCESS≠↑#.RCode hKey←##.RegOpenKeyEx hKeyBase SubKey 0 ##.KEY_ALL_ACCESS 1
 :AndIf InvalidFlag←##.ERROR_SUCCESS≠↑#.RCode hKey←##.RegOpenKeyEx hKeyBase SubKey 0(##.WRITE_DAC+##.WRITE_OWNER)1
 :AndIf InvalidFlag←##.ERROR_SUCCESS≠↑#.RCode hKey←##.RegOpenKeyEx hKeyBase SubKey 0 ##.WRITE_DAC 1
     :Return
 :EndIf
 InvalidFlag←##.ERROR_SUCCESS≠#.RCode←##.RegSetKeySecurity hKey SecurityInformation(##.IntTxt SecurityDescriptor)
 :If ''≢SubKey
     InvalidFlag∨←##.ERROR_SUCCESS≠#.RCode⌈←##.RegCloseKey hKey
 :EndIf
∇

∇ {InvalidFlag}←Data SetValue Parms;hKey;SubKey;hkResult;Disposition;ValueName;Type;cbData
     ⍝ Set a Value under a given "hKey {SubKey}"
     ⍝
     ⍝ Parms[1]    = hKey      Handle to an open key or one of: #.Win.HKEY_CURRENT_USER #.Win.HKEY_LOCAL_MACHINE #.Win.HKEY_CLASSES_ROOT #.Win.HKEY_USERS #.Win.HKEY_CURRENT_CONFIG #.Win.HKEY_PERFORMANCE_DATA or #.Win.HKEY_DYN_DATA
     ⍝ Parms[2]    = SubKey    (opt) Subkey name to set value at, must not begin with '\'
     ⍝ Parms[3]    = ValueName (opt, Default='') Name of the value to set
     ⍝ Parms[4]    = Type      (opt, Default former Type or depends on Data) #.Win.REG_NONE #.Win.REG_SZ #.Win.REG_EXPAND_SZ #.Win.REG_BINARY #.Win.REG_DWORD #.Win.REG_DWORD_BIG_ENDIAN #.Win.REG_LINK #.Win.REG_MULTI_SZ #.Win.REG_RESOURCE_LIST #.Win.REG_FULL_RESOURCE_DESCRIPTOR #.Win.REG_RESOURCE_REQUIREMENTS_LIST
     ⍝
     ⍝ InvalidFlag = 0:Ok 1:Error
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1999
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :Select ↑⍴Parms
 :CaseList 0 1
     hKey←↑Parms
     SubKey←''
     ValueName←''
     Type←⍬
 :Case 2
     hKey ValueName←Parms
     SubKey←''
     Type←⍬
 :Case 3
     hKey ValueName Type←Parms
     :If 82≠⎕DR Type
         SubKey←''
     :Else
         SubKey←ValueName
         ValueName←Type
         Type←⍬
     :EndIf
 :Case 4
     hKey SubKey ValueName Type←Parms
 :EndSelect
 hkResult←hKey
 :If ''≢SubKey
 :AndIf InvalidFlag←##.ERROR_SUCCESS≠↑#.RCode hkResult←##.RegOpenKeyEx hKey SubKey 0 ##.KEY_ALL_ACCESS 1
 :AndIf InvalidFlag←##.ERROR_SUCCESS≠↑#.RCode hkResult Disposition←##.RegCreateKeyEx hKey SubKey 0 ''##.REG_OPTION_NON_VOLATILE ##.KEY_ALL_ACCESS 0 1 1
 :Else
     hKey←hkResult
     :If ⍬≡Type
     :AndIf InvalidFlag←##.ERROR_SUCCESS≠↑#.RCode Type←##.RegQueryType hKey ValueName 0 1 0 0
         Type←⍬
     :EndIf
     :If ⍬≢Type
     :ElseIf 1<≡Data
         Type←##.REG_MULTI_SZ
     :ElseIf 82=⎕DR Data
         Type←##.REG_SZ
     :ElseIf ⍬≡⍴Data
         Type←##.REG_DWORD
     :Else
         Type←##.REG_BINARY
     :EndIf
     :Select Type
     :CaseList ##.REG_SZ ##.REG_EXPAND_SZ
         Data←##.IntTxt Data,↑⎕AV
     :Case ##.REG_DWORD
         Data←##.IntTxt 4 ##.TxtInt⌊Data
     :CaseList ##.REG_BINARY ##.REG_RESOURCE_LIST
         :If 82≠⎕DR Data
             Data←##.TxtInt Data
         :EndIf
         Data←##.IntTxt Data
     :Case ##.REG_DWORD_BIG_ENDIAN
         Data←⌽##.IntTxt 4 ##.TxtInt⌊Data
     :Case ##.REG_MULTI_SZ
         Data←##.IntTxt(↑{×↑⍴⍵:,/⍵ ⋄ ⊂''}Data,¨↑⎕AV),↑⎕AV
     :Else
         Data←##.IntTxt Data
     :EndSelect
     cbData←↑⍴Data
     InvalidFlag←##.ERROR_SUCCESS≠#.RCode←##.RegSetValueExI1 hKey ValueName 0 Type Data cbData
     :If ''≢SubKey
         InvalidFlag∨←##.ERROR_SUCCESS≠#.RCode⌈←##.RegCloseKey hKey
     :EndIf
 :EndIf
∇

:EndNamespace 
:Namespace SCard
⎕IO ⎕ML ⎕WX←1 3 1

∇ VOID←BeginTransaction hCard
     ⍝ Start a transaction, waiting for the completion of all other transactions before it begins.
     ⍝
     ⍝ hCard = Reference value obtained from a previous call to #.Win.SCard.Connect
     ⍝
     ⍝ VOID  1=ok 0=fail
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 VOID←##.SCARD_S_SUCCESS=#.RCode←##.SCardBeginTransaction hCard
∇

∇ Retrn←Connect Parms;hContext;Reader;ShareMode;PreferredProtocols;hCard;ActiveProtocol
     ⍝ Search smart card database and provides a list of named cards previously introduced to the system by the user
     ⍝
     ⍝ Parm[1] = hContext           see #.Win.SCard.EstablishContext
     ⍝ Parm[2] = Reader
     ⍝ Parm[3] = ShareMode          (#.Win.SCARD_SHARE_EXCLUSIVE #.Win.SCARD_SHARE_SHARED or #.Win.SCARD_SHARE_DIRECT)
     ⍝ Parm[4] = PreferredProtocols (#.Win.SCARD_PROTOCOL_UNDEFINED+#.Win.SCARD_PROTOCOL_T0+#.Win.SCARD_PROTOCOL_T1)
     ⍝
     ⍝ Retrn[1] = hCard
     ⍝ Retrn[2] = ActiveProtocol (#.Win.SCARD_PROTOCOL_UNDEFINED #.Win.SCARD_PROTOCOL_T0 or #.Win.SCARD_PROTOCOL_T1)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hContext Reader ShareMode PreferredProtocols←4↑Parms
 Reader←(##.IntTxt Reader),0
 :If ##.SCARD_S_SUCCESS=↑#.RCode hCard ActiveProtocol←##.SCardConnect hContext Reader ShareMode PreferredProtocols 1 1
     Retrn←hCard ActiveProtocol
 :Else
     Retrn←##.INVALID_HANDLE_VALUE ##.SCARD_PROTOCOL_UNDEFINED
 :EndIf
∇

∇ {VOID}←Disconnect Parms;hCard;Disposition
     ⍝ Terminate connection previously opened between calling application and smart card in target reader
     ⍝
     ⍝ Parms[1] = hCard
     ⍝ Parms[2] = Disposition (#.Win.SCARD_LEAVE_CARD #.Win.SCARD_RESET_CARD #.Win.SCARD_UNPOWER_CARD or #.Win.SCARD_EJECT_CARD)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hCard Disposition←Parms
 VOID←##.SCARD_S_SUCCESS≠#.RCode←##.SCardDisconnect hCard Disposition
∇

∇ VOID←EndTransaction Parms;hCard;Disposition
     ⍝ Start a transaction, waiting for the completion of all other transactions before it begins.
     ⍝
     ⍝ Parms[1] = hCard       Reference value obtained from a previous call to #.Win.SCard.Connect
     ⍝ Parms[2] = Disposition What to do with the card: #.Win.SCARD_LEAVE_CARD (def) #.Win.SCARD_RESET_CARD #.Win.SCARD_UNPOWER_CARD or #.Win.SCARD_EJECT_CARD
     ⍝
     ⍝ VOID  1=ok 0=fail
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hCard Disposition←2↑Parms
 VOID←##.SCARD_S_SUCCESS=#.RCode←##.SCardEndTransaction hCard Disposition
∇

∇ hContext←EstablishContext Scope
     ⍝ Establish resource manager context (scope) within which database operations are performed
     ⍝
     ⍝ Scope = #.Win.SCARD_SCOPE_USER or #.Win.SCARD_SCOPE_SYSTEM
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.SCARD_S_SUCCESS≠↑#.RCode hContext←##.SCardEstablishContext Scope ##.NULL ##.NULL 1
     hContext←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ Cards←ListCards Parms;hContext;Atr;mszCards;cchCards
     ⍝ Search smart card database and provides a list of named cards previously introduced to the system by the user
     ⍝
     ⍝ Parms[1] = hContext (handle identifying resource manager context)
     ⍝ Parms[2] = (opt.) Atr (string to compare to known cards)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     hContext←↑Parms
     :If ##.SCARD_S_SUCCESS=↑#.RCode cchCards←##.SCardListCardsI hContext ##.NULL ##.NULL ##.NULL ##.NULL 0
     :AndIf ##.SCARD_S_SUCCESS=↑#.RCode mszCards cchCards←##.SCardListCards hContext ##.NULL ##.NULL ##.NULL cchCards cchCards
         Cards←{(⍵≠↑⎕AV)⊂⍵}cchCards↑mszCards
     :Else
         Cards←0⍴⊂''
     :EndIf
 :Else
     hContext Atr←2↑Parms
     Atr←(##.SCARD_ATR_LENGTH↑##.IntTxt Atr),0
     :If ##.SCARD_S_SUCCESS=↑#.RCode cchCards←##.SCardListCardsAI hContext Atr ##.NULL ##.NULL ##.NULL 0
     :AndIf ##.SCARD_S_SUCCESS=↑#.RCode mszCards cchCards←##.SCardListCardsA hContext Atr ##.NULL ##.NULL cchCards cchCards
         Cards←{(⍵≠↑⎕AV)⊂⍵}cchCards↑mszCards
     :Else
         Cards←0⍴⊂''
     :EndIf
 :EndIf
∇

∇ Interfaces←ListInterfaces Parms;hContext;Card;guidInterfaces;cguidInterfaces
     ⍝ Provide list of interfaces supplied by a given card
     ⍝
     ⍝ Parms[1] = hContext (handle identifying resource manager context)
     ⍝ Parms[2] = Card (name of smart card already introduced to smart card subsystem)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hContext Card←2↑Parms
 Card←(##.IntTxt Card),0
 :If ##.SCARD_S_SUCCESS=↑#.RCode cguidInterfaces←##.SCardListInterfacesI hContext Card ##.NULL 0
 :AndIf ##.SCARD_S_SUCCESS=↑#.RCode guidInterfaces cguidInterfaces←##.SCardListInterfaces hContext Card cguidInterfaces cguidInterfaces
     Interfaces←{(⍵≠↑⎕AV)⊂⍵}cguidInterfaces↑guidInterfaces
 :Else
     Interfaces←0⍴⊂''
 :EndIf
∇

∇ Groups←ListReaderGroups hContext;mszGroups;cchGroups
     ⍝ Provide list of reader groups that have previously been introduced to the system.
     ⍝
     ⍝ hContext = handle that identifies the resource manager context
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.SCARD_S_SUCCESS=↑#.RCode cchGroups←##.SCardListReaderGroupsI hContext ##.NULL 0
 :AndIf ##.SCARD_S_SUCCESS=↑#.RCode mszGroups cchGroups←##.SCardListReaderGroups hContext cchGroups cchGroups
     Groups←{(⍵≠↑⎕AV)⊂⍵}cchGroups↑mszGroups
 :Else
     Groups←0⍴⊂''
 :EndIf
∇

∇ Readers←ListReaders Parms;hContext;Groups;mszReaders;cchReaders
     ⍝ Provide list of readers within a set of named reader groups, eliminating duplicates
     ⍝
     ⍝ Parms[1]   = hContext (handle identifying resource manager context)
     ⍝ Parms[2..] = Groups (names of reader groups defined to the system, all readers if omitted)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     hContext←↑Parms
     :If ##.SCARD_S_SUCCESS=↑#.RCode cchReaders←##.SCardListReadersI hContext ##.NULL ##.NULL 0
     :AndIf ##.SCARD_S_SUCCESS=↑#.RCode mszReaders cchReaders←##.SCardListReaders hContext ##.NULL cchReaders cchReaders
         Readers←{(⍵≠↑⎕AV)⊂⍵}cchReaders↑mszReaders
     :Else
         Readers←0⍴⊂''
     :EndIf
 :Else
     hContext←↑Parms
     Groups←1↓Parms
     Groups←(∊(##.IntTxt¨Groups),¨0),0
     :If ##.SCARD_S_SUCCESS=↑#.RCode cchReaders←##.SCardListReadersTI hContext Groups ##.NULL 0
     :AndIf ##.SCARD_S_SUCCESS=↑#.RCode mszReaders cchReaders←##.SCardListReadersT hContext Groups cchReaders cchReaders
         Readers←{(⍵≠↑⎕AV)⊂⍵}cchReaders↑mszReaders
     :Else
         Readers←0⍴⊂''
     :EndIf
 :EndIf
∇

∇ rgReaderStates←LocateCardByATR Parms;hContext;AtrMasks;Readers;pReaders;cReaders;cAtrs;rgbAtr;rgbMask;cbAtr;i;szReader;pvUserData;dwCurrentState;dwEventState;RCode;rgAtrMasks
     ⍝ Searche readers for a card with an ATR string that matches one of the card names
     ⍝
     ⍝ Parms[1]   = hContext (handle identifying resource manager context)
     ⍝ Parms[2..] = AtrMasks (Atr Mask)(Atr Mask)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2007
     ⍝ mailto:Hager@Dortmund.net
 hContext←↑Parms←,Parms
 AtrMasks←1↓Parms
     
 :Select ≡AtrMasks
 :Case 1
     AtrMasks←0⍴⊂'' ''
 :Case 2
     AtrMasks←,⊂AtrMasks
 :EndSelect
 rgAtrMasks←0⍴⊂0(36⍴0)(36⍴0)
 :For i :In ⍳cAtrs←↑⍴AtrMasks
     rgbAtr rgbMask←i⊃AtrMasks
     rgbAtr←##.IntTxt ##.TxtHex rgbAtr
     rgbMask←##.IntTxt ##.TxtHex rgbMask
     cbAtr←↑⍴rgbAtr
     rgbAtr←36↑rgbAtr
     rgbMask←36↑rgbMask
     rgAtrMasks,←⊂cbAtr rgbAtr rgbMask
 :EndFor
 :If 0∨.≠pReaders←#.Win.Mem.Alloc¨(Readers←ListReaders hContext),¨↑⎕AV
     cReaders←↑⍴rgReaderStates←(5↑¨pReaders),¨⊂⊂36⍴0
     :If ##.SCARD_S_SUCCESS=↑#.RCode rgReaderStates←##.SCardLocateCardsByATR hContext rgAtrMasks cAtrs rgReaderStates cReaders
         :For i :In ⍳⍴rgReaderStates
             szReader pvUserData dwCurrentState dwEventState cbAtr rgbAtr←i⊃rgReaderStates
             (i⊃rgReaderStates)←(i⊃Readers)dwEventState(##.HexTxt ##.TxtInt cbAtr↑rgbAtr)
         :EndFor
     :Else
         rgReaderStates←0⍴⊂'' 0 ''
     :EndIf
     RCode←#.RCode ⋄ #.Win.Mem.Free¨pReaders ⋄ #.RCode←RCode
 :EndIf
∇

∇ Retrn←Reconnect Parms;hCard;ShareMode;PreferredProtocols;Initialization;ActiveProtocol
     ⍝ Reestablish an existing connection between the calling application and a smart card
     ⍝
     ⍝ Parm[1] = hCard              see #.Win.SCard.Connect
     ⍝ Parm[2] = ShareMode          (#.Win.SCARD_SHARE_EXCLUSIVE or #.Win.SCARD_SHARE_SHARED)
     ⍝ Parm[3] = PreferredProtocols (#.Win.SCARD_PROTOCOL_UNDEFINED+#.Win.SCARD_PROTOCOL_T0+#.Win.SCARD_PROTOCOL_T1)
     ⍝ Parm[4] = Initialization     (#.Win.SCARD_LEAVE_CARD (def) #.Win.SCARD_RESET_CARD or #.Win.SCARD_UNPOWER_CARD)
     ⍝
     ⍝ Retrn[1] = ValidFlag
     ⍝ Retrn[2] = ActiveProtocol (#.Win.SCARD_PROTOCOL_UNDEFINED #.Win.SCARD_PROTOCOL_T0 or #.Win.SCARD_PROTOCOL_T1)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2007
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hCard ShareMode PreferredProtocols Initialization←4↑Parms
 :If ##.SCARD_S_SUCCESS=↑#.RCode ActiveProtocol←##.SCardReconnect hCard ShareMode PreferredProtocols Initialization 1
     Retrn←1 ActiveProtocol
 :Else
     Retrn←0 ##.SCARD_PROTOCOL_UNDEFINED
 :EndIf
∇

∇ {VOID}←ReleaseContext hContext
     ⍝ Close established resource manager context, freeing any resources allocated, incl SCARDHANDLE objects and mem from SCARD_AUTOALLOCATE
     ⍝
     ⍝ hContext = handle that identifies the resource manager context
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 VOID←##.SCARD_S_SUCCESS≠#.RCode←##.SCardReleaseContext hContext
∇

∇ Retrn←Status hCard;ReaderName;ReaderLen;State;Protocol;Atr;AtrLen
     ⍝ Provide current status of smart card in  reader
     ⍝
     ⍝ hCard    = Reference value returned from Connect
     ⍝
     ⍝ Retrn[1] = ReaderName
     ⍝ Retrn[2] = State (#.Win.SCARD_UNKNOWN #.Win.SCARD_ABSENT #.Win.SCARD_PRESENT #.Win.SCARD_SWALLOWED #.Win.SCARD_POWERED #.Win.SCARD_NEGOTIABLE or #.Win.SCARD_SPECIFIC)
     ⍝ Retrn[3] = Protocol (#.Win.SCARD_PROTOCOL_UNDEFINED #.Win.SCARD_PROTOCOL_T0 or #.Win.SCARD_PROTOCOL_T1)
     ⍝ Retrn[4] = ATR (Sequence of bytes returned from smart card when turned on identifying card)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 AtrLen←ReaderLen←4096
 :If ##.SCARD_S_SUCCESS=↑#.RCode ReaderName ReaderLen State Protocol Atr AtrLen←##.SCardStatus hCard ReaderLen ReaderLen 1 1 ##.SCARD_ATR_LENGTH ##.SCARD_ATR_LENGTH
     Atr←AtrLen↑Atr
     ReaderName←ReaderLen↑ReaderName
     Retrn←ReaderName State Protocol Atr
 :Else
     Retrn←'' 0 ##.SCARD_PROTOCOL_UNDEFINED''
 :EndIf
∇

∇ Retrn←Transmit Parms;hCard;SendPci;SendBuffer;cbSendLength;RecvPci;RecvBuffer;cbRecvLength
     ⍝ Send a service request to the smart card, and expects to receive data back from the card.
     ⍝ Parms[1] = hCard      see #.Win.SCard.Connect
     ⍝ Parms[2] = SendPci    ProtocolControlInformation(#.Win.SCARD_PCI_T0 #.Win.SCARD_PCI_T1 or #.Win.SCARD_PCI_RAW)
     ⍝ Parms[3] = SendBuffer T=0: CmdBytes[Cla(InstrClass),Ins(InstrCode),P1(InstrParam1),P2(InstrParam2),IfNotZero/P3(IOTransferSize)],SendData
     ⍝ Parms[4] = RecvPci    opt.
     ⍝
     ⍝ Retrn[1] = RecvBuffer
     ⍝ Retrn[2] = RecvPci    Only if Parms[4] was given
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 3<↑⍴Parms
     hCard SendPci SendBuffer RecvPci←4↑Parms
     SendPci←##.IntTxt SendPci
     cbSendLength←↑⍴SendBuffer←##.IntTxt SendBuffer
     RecvPci←##.IntTxt RecvPci
     :If ##.SCARD_S_SUCCESS=↑#.RCode RecvPci RecvBuffer cbRecvLength←##.SCardTransmit hCard SendPci SendBuffer cbSendLength RecvPci 4096 4096
         RecvBuffer←cbRecvLength↑RecvBuffer
         RecvPci←##.TxtInt RecvPci
     :Else
         RecvBuffer←''
         RecvPci←''
     :EndIf
     Retrn←RecvPci RecvBuffer
 :Else
     hCard SendPci SendBuffer←3↑Parms
     SendPci←##.IntTxt SendPci
     cbSendLength←↑⍴SendBuffer←##.IntTxt SendBuffer
     :If ##.SCARD_S_SUCCESS=↑#.RCode RecvBuffer cbRecvLength←##.SCardTransmitI hCard SendPci SendBuffer cbSendLength ##.NULL 4096 4096
         RecvBuffer←cbRecvLength↑RecvBuffer
     :Else
         RecvBuffer←''
     :EndIf
     Retrn←RecvBuffer
 :EndIf
∇

:Namespace CardOS
⍝ === VARIABLES ===

COMPUTE_ALGORITHM←(⎕ucs 0 8804)

CREATE_FILE←(⎕ucs 0 224)

CRYPT←(⎕ucs 0 9074)

DECREASE_RECORD←(⎕ucs 0 48)

DELETE_FILE←(⎕ucs 0 226)

DELETE_RECORD←(⎕ucs 0 212)

ERASE_BINARY←(⎕ucs 0 619)

GET_VERSION←(⎕ucs 0 0)

GET_VERSION_COPYRIGHT←(⎕ucs 0 0 127 0 0)

INCREASE_RECORD←(⎕ucs 0 50)

READ_BINARY←(⎕ucs 0 8728)

READ_RECORD←(⎕ucs 0 9021)

SELECT_FILE←(⎕ucs 0 164)

SELECT_FILE_FID←(⎕ucs 0 164 0 0)

SELECT_FILE_FID_DF←(⎕ucs 0 164 1 0)

SELECT_FILE_FID_EF←(⎕ucs 0 164 2 0)

SELECT_FILE_FNAME_DF←(⎕ucs 0 164 4 0)

SELECT_FILE_PARENT_DF←(⎕ucs 0 164 3 0)

SELECT_FILE_PATH_ABSOLUTE←(⎕ucs 0 164 8 0)

SELECT_FILE_PATH_RELATIVE←(⎕ucs 0 164 9 0)

UPDATE_BINARY←(⎕ucs 0 214)

UPDATE_RECORD←(⎕ucs 0 220)

VERIFY←(⎕ucs 0 32)


⍝ === End of variables definition ===

⎕IO ⎕ML ⎕WX←1 3 1

∇ Response←GetVersionCopyright hCard;Split;MultiString;SendBuffer;RecvBuffer;STRING;SW1;SW2
 Split←{⍺↑¨(×⍺)\(⍺/⍳⍴⍺)⊂⍵}
 MultiString←{⍵{(⍵×1++\~⍵)⊂⍺}⍵≠↑⎕AV}
 SendBuffer←GET_VERSION_COPYRIGHT
 :If 2>↑⍴RecvBuffer←##.Transmit hCard ##.##.SCARD_PCI_T1 SendBuffer
     Response←0⍴⊂''
 :Else
     STRING SW1 SW2←(¯2+↑⍴RecvBuffer)1 1 Split RecvBuffer
     :Select ##.##.HexTxt SW1,SW2
     :Case '9000'
         Response←MultiString STRING
     :Case '6B00'
         #.RCode←1
         Response←0⍴⊂''
     :Else
         #.RCode←1
         Response←0⍴⊂''
     :EndSelect
 :EndIf
∇

∇ Init;CLA_DEFAULT;INS_GET_VERSION;INS_CREATE_FILE;INS_SELECT_FILE;INS_DELETE_FILE;INS_READ_BINARY;INS_UPDATE_BINARY;INS_ERASE_BINARY;INS_READ_RECORD;INS_UPDATE_RECORD;INS_DELETE_RECORD;INS_DECREASE_RECORD;INS_INCREASE_RECORD;INS_VERIFY;INS_COMPUTE_ALGORITHM;INS_CRYPT
 CLA_DEFAULT←##.##.TxtHex'00'
 INS_GET_VERSION←##.##.TxtHex'00'
 INS_CREATE_FILE←##.##.TxtHex'E0'
 INS_SELECT_FILE←##.##.TxtHex'A4'
 INS_DELETE_FILE←##.##.TxtHex'E2'
 INS_READ_BINARY←##.##.TxtHex'B0'
 INS_UPDATE_BINARY←##.##.TxtHex'D6'
 INS_ERASE_BINARY←##.##.TxtHex'0E'
 INS_READ_RECORD←##.##.TxtHex'B2'
 INS_UPDATE_RECORD←##.##.TxtHex'DC'
 INS_DELETE_RECORD←##.##.TxtHex'D4'
 INS_DECREASE_RECORD←##.##.TxtHex'30'
 INS_INCREASE_RECORD←##.##.TxtHex'32'
 INS_VERIFY←##.##.TxtHex'20'
 INS_COMPUTE_ALGORITHM←##.##.TxtHex'88'
 INS_CRYPT←##.##.TxtHex'8A'
     
 GET_VERSION←CLA_DEFAULT,INS_GET_VERSION
 CREATE_FILE←CLA_DEFAULT,INS_CREATE_FILE
 SELECT_FILE←CLA_DEFAULT,INS_SELECT_FILE
 DELETE_FILE←CLA_DEFAULT,INS_DELETE_FILE
 READ_BINARY←CLA_DEFAULT,INS_READ_BINARY
 UPDATE_BINARY←CLA_DEFAULT,INS_UPDATE_BINARY
 ERASE_BINARY←CLA_DEFAULT,INS_ERASE_BINARY
 READ_RECORD←CLA_DEFAULT,INS_READ_RECORD
 UPDATE_RECORD←CLA_DEFAULT,INS_UPDATE_RECORD
 DELETE_RECORD←CLA_DEFAULT,INS_DELETE_RECORD
 DECREASE_RECORD←CLA_DEFAULT,INS_DECREASE_RECORD
 INCREASE_RECORD←CLA_DEFAULT,INS_INCREASE_RECORD
 VERIFY←CLA_DEFAULT,INS_VERIFY
 COMPUTE_ALGORITHM←CLA_DEFAULT,INS_COMPUTE_ALGORITHM
 CRYPT←CLA_DEFAULT,INS_CRYPT
     
 GET_VERSION_COPYRIGHT←GET_VERSION,##.##.TxtHex'7F0000'
     
 SELECT_FILE_FID←SELECT_FILE,##.##.TxtHex'0000'
 SELECT_FILE_FID_DF←SELECT_FILE,##.##.TxtHex'0100'
 SELECT_FILE_FID_EF←SELECT_FILE,##.##.TxtHex'0200'
 SELECT_FILE_PARENT_DF←SELECT_FILE,##.##.TxtHex'0300'
 SELECT_FILE_FNAME_DF←SELECT_FILE,##.##.TxtHex'0400'
 SELECT_FILE_PATH_ABSOLUTE←SELECT_FILE,##.##.TxtHex'0800'
 SELECT_FILE_PATH_RELATIVE←SELECT_FILE,##.##.TxtHex'0900'
∇

∇ Response←SelectFileAbsolutePath Parms;hCard;Path;Split;SendBuffer;RecvBuffer;IS;FID;FTYPE;SEC;LPROTF;SYS;FNLEN;FNAME;SW1;SW2
 Split←{⍺↑¨(×⍺)\(⍺/⍳⍴⍺)⊂⍵}
 hCard Path←2↑Parms
 SendBuffer←SELECT_FILE_PATH_ABSOLUTE,(##.##.TxtInt↑⍴Path),Path,(##.##.TxtInt 0)
 :If 14>↑⍴RecvBuffer←##.Transmit hCard ##.##.SCARD_PCI_T1 SendBuffer
     Response←''
 :Else
     IS FID FTYPE SEC LPROTF SYS FNLEN FNAME SW1 SW2←2 2 1 3 2 2(14<↑⍴RecvBuffer)(0⌈¯15+↑⍴RecvBuffer)1 1 Split RecvBuffer
     :Select ##.##.HexTxt SW1,SW2
     :Case '9000'
         IS←##.##.IntHex ##.##.HexTxt IS
         FTYPE←##.##.IntTxt FTYPE
         SEC←¯1+'0123456789ABCDEF'⍳##.##.HexTxt SEC
         Response←IS FID FTYPE SEC LPROTF SYS FNAME
     :Case '6401'
         #.RCode←1
         Response←''
     :Case '6700'
         #.RCode←1
         Response←''
     :Case '6981'
         #.RCode←1
         Response←''
     :Case '6A82'
         #.RCode←1
         Response←''
     :Case '6A86'
         #.RCode←1
         Response←''
     :Case '6A87'
         #.RCode←1
         Response←''
     :Else
         #.RCode←1
         Response←''
     :EndSelect
 :EndIf
∇

:EndNamespace 
:Namespace Samples
⎕IO ⎕ML ⎕WX←1 3 1

∇ RecvBuffer←CardOSCrypt;hContext;Readers;Reader;Cards;hCard;ActiveProtocol;IS;FID;FTYPE;SEC;LPROTF;SYS;FNAME;RecvBuffer
 #.Win.Init
 Certificates←0⍴⊂''
 :If #.Win.INVALID_HANDLE_VALUE=hContext←#.Win.SCard.EstablishContext #.Win.SCARD_SCOPE_USER
 :Else
     :If 0<↑⍴Readers←#.Win.SCard.ListReaders hContext
         Reader←↑Readers
         :If #.Win.INVALID_HANDLE_VALUE=↑hCard ActiveProtocol←#.Win.SCard.Connect hContext Reader #.Win.SCARD_SHARE_SHARED(#.Win.SCARD_PROTOCOL_T0+#.Win.SCARD_PROTOCOL_T1)
         :Else
             ⎕←RecvBuffer←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'3000')               ⍝ SelectFile
                                                                                                               ⍝ Verify
             ⎕←RecvBuffer←#.Win.SCard.Transmit hCard #.Win.SCARD_PCI_T1(#.Win.SCard.CardOS.VERIFY,(#.Win.TxtHex'008A04'),'1111')
             ⎕←RecvBuffer←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'30003011')           ⍝ SelectFile
                                                                                                               ⍝ Crypt
             ⎕←RecvBuffer←#.Win.SCard.Transmit hCard #.Win.SCARD_PCI_T1(#.Win.SCard.CardOS.COMPUTE_ALGORITHM,(#.Win.TxtHex'00008281'),(#.Win.TxtInt ¯129↑#.Win.IntTxt #.Win.TxtHex'3020300C06082A864886F70D02050500041023B3CB24FB850BFAA64008D3CD1B49B3'),#.Win.TxtHex'00')
         :EndIf
     :EndIf
     #.Win.SCard.ReleaseContext hContext
 :EndIf
 #.Win.SCard.CardOS.Init
∇

∇ Certificates←CardOSReadCertificates;hContext;Readers;Reader;Cards;hCard;ActiveProtocol;IS;FID;FTYPE;SEC;LPROTF;SYS;FNAME;Certificate
 #.Win.Init
 Certificates←0⍴⊂''
 :If #.Win.INVALID_HANDLE_VALUE=hContext←#.Win.SCard.EstablishContext #.Win.SCARD_SCOPE_USER
 :Else
     :If 0<↑⍴Readers←#.Win.SCard.ListReaders hContext
         Reader←↑Readers
         :If #.Win.INVALID_HANDLE_VALUE=↑hCard ActiveProtocol←#.Win.SCard.Connect hContext Reader #.Win.SCARD_SHARE_SHARED(#.Win.SCARD_PROTOCOL_T0+#.Win.SCARD_PROTOCOL_T1)
         :Else
             IS FID FTYPE SEC LPROTF SYS FNAME←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'10001010')
             Certificate←#.Win.SCard.Transmit hCard #.Win.SCARD_PCI_T1(#.Win.SCard.CardOS.READ_BINARY,#.Win.TxtHex'000000')
             Certificates,←⊂Certificate
             IS FID FTYPE SEC LPROTF SYS FNAME←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'20002010')
             Certificate←#.Win.SCard.Transmit hCard #.Win.SCARD_PCI_T1(#.Win.SCard.CardOS.READ_BINARY,#.Win.TxtHex'000000')
             Certificates,←⊂Certificate
             IS FID FTYPE SEC LPROTF SYS FNAME←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'30003010')
             Certificate←#.Win.SCard.Transmit hCard #.Win.SCARD_PCI_T1(#.Win.SCard.CardOS.READ_BINARY,#.Win.TxtHex'000000')
             Certificates,←⊂Certificate
         :EndIf
     :EndIf
     #.Win.SCard.ReleaseContext hContext
 :EndIf
∇

∇ CardOSVersion;hContext;Readers;Reader;Cards;hCard;ActiveProtocol
 #.Win.Init
 :If #.Win.INVALID_HANDLE_VALUE=hContext←#.Win.SCard.EstablishContext #.Win.SCARD_SCOPE_USER
 :Else
     :If 0<↑⍴Readers←#.Win.SCard.ListReaders hContext
         Reader←↑Readers
         :If #.Win.INVALID_HANDLE_VALUE=↑hCard ActiveProtocol←#.Win.SCard.Connect hContext Reader #.Win.SCARD_SHARE_SHARED(#.Win.SCARD_PROTOCOL_T0+#.Win.SCARD_PROTOCOL_T1)
         :Else
             ⎕←Reader
             ⎕←⊃#.Win.SCard.CardOS.GetVersionCopyright hCard
             #.Win.SCard.Disconnect hCard #.Win.SCARD_LEAVE_CARD
         :EndIf
     :EndIf
     #.Win.SCard.ReleaseContext hContext
 :EndIf
∇

∇ ListCards;hContext;Readers;Reader;Cards;hCard;ActiveProtocol;ReaderName;State;Protocol;Atr;StateName;ProtocolName
 #.Win.Init
 :If #.Win.INVALID_HANDLE_VALUE=hContext←#.Win.SCard.EstablishContext #.Win.SCARD_SCOPE_USER
 :Else
     Readers←#.Win.SCard.ListReaders hContext
     :For Reader :In Readers
         :If #.Win.INVALID_HANDLE_VALUE≠↑hCard ActiveProtocol←#.Win.SCard.Connect hContext Reader #.Win.SCARD_SHARE_SHARED(#.Win.SCARD_PROTOCOL_T0+#.Win.SCARD_PROTOCOL_T1)
         :OrIf #.Win.INVALID_HANDLE_VALUE≠↑hCard ActiveProtocol←#.Win.SCard.Connect hContext Reader #.Win.SCARD_SHARE_DIRECT #.Win.SCARD_PROTOCOL_UNDEFINED
             :If 0∊⍴ReaderName State Protocol Atr←#.Win.SCard.Status hCard
                 ⎕←(30↑Reader),(12↑'Invalid')
             :Else
                 :Select State
                 :Case #.Win.SCARD_ABSENT
                     StateName←'Absent'
                 :Case #.Win.SCARD_PRESENT
                     StateName←'Present'
                 :Case #.Win.SCARD_SWALLOWED
                     StateName←'Swallowed'
                 :Case #.Win.SCARD_POWERED
                     StateName←'Powered'
                 :Case #.Win.SCARD_NEGOTIABLE
                     StateName←'Negotiable'
                 :Case #.Win.SCARD_SPECIFIC
                     StateName←'Specific'
                 :Else
                     StateName←'Unknown'
                 :EndSelect
                 :Select Protocol
                 :Case #.Win.SCARD_PROTOCOL_UNDEFINED
                     ProtocolName←'Undefined'
                 :Case #.Win.SCARD_PROTOCOL_T0
                     ProtocolName←'T0'
                 :Case #.Win.SCARD_PROTOCOL_T1
                     ProtocolName←'T1'
                 :Else
                     ProtocolName←'Unknown'
                 :EndSelect
                 ⎕←(30↑ReaderName),(12↑StateName),(12↑ProtocolName),(#.Win.HexTxt Atr),' ',{('....',4↓⎕AV)[⎕AV⍳⍵]}Atr
             :EndIf
             #.Win.SCard.Disconnect hCard #.Win.SCARD_LEAVE_CARD
         :Else
             ⎕←(30↑Reader),(12↑'Offline')
         :EndIf
     :EndFor
     #.Win.SCard.ReleaseContext hContext
 :EndIf
∇

∇ TEST;hContext;Readers;Reader;Cards;hCard;ActiveProtocol;ReaderName;State;Protocol;Atr;Recv
 #.Win.Init
 :If ##.INVALID_HANDLE_VALUE≠hContext←EstablishContext #.Win.SCARD_SCOPE_USER
     ⎕←⊃Readers←ListReaders hContext
     ⎕←'-----------'
     ⎕←⊃Cards←ListCards hContext
     ⎕←'-----------'
     ⎕←⊃¨ListInterfaces¨hContext,¨⊂¨Cards
     ⎕←'-----------'
     ⎕←ListReaderGroups hContext
     ⎕←'-----------'
     Reader←↑Readers
     :If ##.INVALID_HANDLE_VALUE≠↑hCard ActiveProtocol←Connect hContext Reader #.Win.SCARD_SHARE_SHARED #.Win.SCARD_PROTOCOL_T1
         ReaderName State Protocol Atr←Status hCard
         ⎕←ReaderName
         ⎕←State
         ⎕←Protocol
         ⎕←⍴Atr
         ⎕←{⍵,[1]({'0123456789ABCDEF'[1+16 16⊤⍵]}¨##.IntTxt ⍵),[0.5]##.IntTxt ⍵}Atr
         ⎕←#.Win.HexInt+/##.IntTxt ¯1↓Atr
     
         ⎕←#.Win.SCard.CardOS.GetVersionCopyright hCard
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'1000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'2000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'3000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'4000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'5000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'6000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'7000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'8000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'9000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'10001010')
         #.RCode #.RText
     
         CERT←Transmit hCard #.Win.SCARD_PCI_T1(#.Win.TxtHex'00B0000000')
         ⍴CERT
         ⎕←#.Win.HexTxt CERT
         #.RCode #.RText
     
         Disconnect hCard #.Win.SCARD_LEAVE_CARD
     :EndIf
     ReleaseContext hContext
 :EndIf
∇

∇ TEST1;hContext;Readers;Reader;Cards;hCard;ActiveProtocol;ReaderName;State;Protocol;Atr;Recv
 #.Win.Init
 :If ##.INVALID_HANDLE_VALUE≠hContext←EstablishContext #.Win.SCARD_SCOPE_USER
     Readers←ListReaders hContext
     Reader←↑Readers
     ⍝    :If ##.INVALID_HANDLE_VALUE=↑hCard ActiveProtocol←Connect hContext Reader #.Win.SCARD_SHARE_SHARED #.Win.SCARD_PROTOCOL_T1
     :If ##.INVALID_HANDLE_VALUE=↑hCard ActiveProtocol←Connect hContext Reader #.Win.SCARD_SHARE_DIRECT #.Win.SCARD_PROTOCOL_UNDEFINED
     
         #.RCode #.RText
     :Else
         ReaderName State Protocol Atr←Status hCard
         ⎕←ReaderName
         ⎕←State
         ⎕←Protocol
         ⎕←⍴Atr
         ⎕←{⍵,[1]({'0123456789ABCDEF'[1+16 16⊤⍵]}¨##.IntTxt ⍵),[0.5]##.IntTxt ⍵}Atr
         ⎕←#.Win.HexInt+/##.IntTxt ¯1↓Atr
     
         ⎕←#.Win.SCard.CardOS.GetVersionCopyright hCard
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'1000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'2000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'3000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'4000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'5000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'6000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'7000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'8000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'9000')
         #.RCode #.RText
     
         ⎕←#.Win.SCard.CardOS.SelectFileAbsolutePath hCard(#.Win.TxtHex'10001010')
         #.RCode #.RText
     
         CERT←Transmit hCard #.Win.SCARD_PCI_T1(#.Win.TxtHex'00B0000000')
         ⍴CERT
         ⎕←#.Win.HexTxt CERT
         #.RCode #.RText
     
         Disconnect hCard #.Win.SCARD_LEAVE_CARD
     :EndIf
     ReleaseContext hContext
 :EndIf
∇

:EndNamespace 
:EndNamespace 
:Namespace Security
⎕IO ⎕ML ⎕WX←1 3 1

∇ {Retrn}←AdjustTokenPrivileges Parms;VOID;SystemName;TokenHandle;DisableAllPrivileges;Attributes;Name;Luid;NewState;BufferLength;PreviousState;ReturnLength
     ⍝ Enables or disables privileges in the specified access token
     ⍝ and returns the previous state.
     ⍝
     ⍝ Parms[1]     = SystemName
     ⍝ Parms[2]     = TokenHandle
     ⍝ Parms[3]     = DisableAllPrivileges (TRUE or FALSE)
     ⍝ Parms[4 5..] = (Name Attributes)(Name Attributes)..
     ⍝
     ⍝ Retrn[1 2..] = (Name Attributes)(Name Attributes)..
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 Retrn←0⍴⊂'' 0
 :If 0≤##.GetVersion  ⍝ WinNT only
     SystemName TokenHandle DisableAllPrivileges←3↑Parms
     NewState←0
     :For Name Attributes :In 3↓Parms
         :If ¯1 ¯1≢Luid←LookupPrivilegeValue SystemName Name
             NewState,←Luid,Attributes
             NewState[1]+←1
         :EndIf
     :EndFor
     BufferLength←4×↑⍴NewState
     PreviousState←256
     ReturnLength←1024
     :If ##.ZERO≠↑VOID PreviousState ReturnLength←##.AdjustTokenPrivileges TokenHandle DisableAllPrivileges NewState BufferLength PreviousState ReturnLength
         :For Luid Attributes :In 1 1 2∘⊂¨⊂[2](↑PreviousState)3⍴(⌊ReturnLength÷4)↑1↓PreviousState
             :If ''≢Name←LookupPrivilegeName SystemName Luid
                 Retrn,←⊂Name Attributes
             :EndIf
         :EndFor
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
 :EndIf
∇

∇ {VOID}←Close hObject
     ⍝ Closes an open handle to an object such as a file handle.
     ⍝ VOID = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.TRUE=##.CloseHandle hObject
     #.RCode←##.ERROR_SUCCESS
     VOID←0
 :Else
     #.RCode←##.GetLastError
     VOID←1
 :EndIf
∇

∇ StringSid←ConvertSidToStringSid Sid;Revision;SubAuthorityCount;IdentifierAuthority;SubAuthority
 Revision SubAuthorityCount←1 ##.IntTxt 2↑Sid
 IdentifierAuthority←256⊥1 ##.IntTxt 6↑2↓Sid
 SubAuthority←4 ##.IntTxt(4×SubAuthorityCount)↑8↓Sid
 StringSid←'S',0⍕Revision,IdentifierAuthority,SubAuthority
 ((StringSid=' ')/StringSid)←'-'
∇

∇ TokenInformation←GetTokenInformation Parms;VOID;TokenHandle;TokenInformationClass;TokenInformationLength;ReturnLength;Data;SystemName
     ⍝ Retrieves a specified type of information about an access token
     ⍝
     ⍝ Parms[1]     = TokenHandle
     ⍝ Parms[2]     = TokenInformationClass
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≤##.GetVersion  ⍝ WinNT only
     TokenHandle TokenInformationClass←2↑Parms
     :If ##.ZERO≠↑VOID TokenInformation TokenInformationLength←##.GetTokenInformation TokenHandle TokenInformationClass 1 0 1
     :OrIf ##.ERROR_INSUFFICIENT_BUFFER=#.RCode←##.GetLastError
         :If ##.ZERO≠↑VOID TokenInformation ReturnLength←##.GetTokenInformation TokenHandle TokenInformationClass TokenInformationLength TokenInformationLength 1
             Data←ReturnLength↑TokenInformation
             #.RCode←##.ERROR_SUCCESS
             :Select TokenInformationClass
             :Case ##.TokenUser
                 TokenInformation←Data
             :Case ##.TokenGroups
                 TokenInformation←Data
             :Case ##.TokenPrivileges
                 SystemName←''
                 TokenInformation←0⍴⊂'' 0
                 :For Luid Attributes :In 1 1 2∘⊂¨⊂[2](↑Data)3⍴1↓Data←4 ##.IntTxt Data
                     :If ''≢Name←LookupPrivilegeName SystemName Luid
                         TokenInformation,←⊂Name Attributes
                     :EndIf
                 :EndFor
             :Case ##.TokenOwner
                 TokenInformation←Data
             :Case ##.TokenPrimaryGroup
                 TokenInformation←Data
             :Case ##.TokenDefaultDacl
                 TokenInformation←Data
             :Case ##.TokenSource
                 TokenInformation←(8↑Data)(4 ##.IntTxt 8↓Data)
             :Case ##.TokenType
                 TokenInformation←↑4 ##.IntTxt Data
             :Case ##.TokenImpersonationLevel
                 TokenInformation←Data
             :Case ##.TokenStatistics
                 TokenInformation←Data
             :Else
                 TokenInformation←Data
             :EndSelect
         :Else
             #.RCode←##.GetLastError
             TokenInformation←''
         :EndIf
     :Else
         TokenInformation←''
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
     TokenInformation←''
 :EndIf
∇

∇ {ValidFlag}←ImpersonateLoggedOnUser hToken
     ⍝ Let the calling thread impersonate the security context of a logged-on user. The user is represented by a token handle.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≤##.GetVersion  ⍝ WinNT only
     :If ValidFlag←##.ImpersonateLoggedOnUser hToken
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
     ValidFlag←##.FALSE
 :EndIf
∇

∇ hToken←LogonUser Parms;Username;Domain;Password;LogonType;LogonProvider;ValidFlag
     ⍝ Attempt to log a user on to the local computer, that is, to the computer from which LogonUser was called
     ⍝
     ⍝ Parms[1]   = Username
     ⍝ Parms[2]   = Domain
     ⍝ Parms[3]   = Password
     ⍝ Parms[4]   = LogonType     #.Win.LOGON32_LOGON_INTERACTIVE #.Win.LOGON32_LOGON_NETWORK #.Win.LOGON32_LOGON_BATCH #.Win.LOGON32_LOGON_SERVICE or #.Win.LOGON32_LOGON_UNLOCK
     ⍝ Parms[5]   = LogonProvider #.Win.LOGON32_PROVIDER_DEFAULT #.Win.LOGON32_PROVIDER_WINNT35 or #.Win.LOGON32_PROVIDER_WINNT40
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≤##.GetVersion  ⍝ WinNT only
     :Select ↑⍴Parms
     :CaseList 1 2 3
         Username Domain Password←3↑Parms
         LogonType←##.LOGON32_LOGON_INTERACTIVE
         LogonProvider←##.LOGON32_PROVIDER_DEFAULT
     :Case 4
         Username Domain Password LogonType←Parms
         LogonProvider←##.LOGON32_PROVIDER_DEFAULT
     :Case 5
         Username Domain Password LogonType LogonProvider←5↑Parms
     :Else
         #.RCode←##.ERROR_INVALID_PARAMETER
         hToken←##.INVALID_HANDLE_VALUE
         :Return
     :EndSelect
     :If ''≡Domain
         Domain←,'.'
     :EndIf
     :If ↑ValidFlag hToken←##.LogonUser Username Domain Password LogonType LogonProvider 1
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         hToken←##.INVALID_HANDLE_VALUE
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
     hToken←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ Retrn←LookupAccountName Parms;SystemName;AccountName;Sid;cbSid;DomainName;cbDomainName;Use;VOID
     ⍝ Retrieve a security identifier (SID) for the account and the name of the domain on which the account was found.
     ⍝
     ⍝ Parms    = AccountName
     ⍝ or
     ⍝ Parms[1] = SystemName  Name of remote computer. Def. account name is looked up on local system
     ⍝ Parms[2] = AccountName Account name
     ⍝
     ⍝ Retrn[1] = Sid         Security identifier
     ⍝ Retrn[2] = DomainName  Domain name
     ⍝ Retrn[3] = Use         SID-type indicator (User=1 Group=2 Domain=3 Alias=4 WellKnownGroup=5 DeletedAccount=6 Invalid=7 Unknown=8 Computer=9)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≤##.GetVersion  ⍝ WinNT only
     :If 2>≡Parms
         SystemName←''
         AccountName←,Parms
     :ElseIf 1=↑⍴Parms
         SystemName←,↑Parms
         AccountName←''
     :Else
         SystemName AccountName←2↑Parms
     :EndIf
     :If ''≡SystemName
         VOID Sid cbSid DomainName cbDomainName Use←##.LookupAccountNameI 0 AccountName 0 0 0 0 1
         :If ##.ZERO≠↑VOID Sid cbSid DomainName cbDomainName Use←##.LookupAccountNameI 0 AccountName cbSid cbSid cbDomainName cbDomainName 1
             Sid←cbSid↑Sid
             DomainName←cbDomainName↑DomainName
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
             Sid DomainName Use←'' '' 0
         :EndIf
     :Else
         VOID Sid cbSid DomainName cbDomainName Use←##.LookupAccountName SystemName AccountName 0 0 0 0 1
         :If ##.ZERO≠↑VOID Sid cbSid DomainName cbDomainName Use←##.LookupAccountName SystemName AccountName cbSid cbSid cbDomainName cbDomainName 1
             Sid←cbSid↑Sid
             DomainName←cbDomainName↑DomainName
             #.RCode←##.ERROR_SUCCESS
         :Else
             #.RCode←##.GetLastError
             Sid DomainName Use←'' '' 0
         :EndIf
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
     Sid DomainName Use←'' '' 0
 :EndIf
 Retrn←Sid DomainName Use
∇

∇ DisplayName←LookupPrivilegeDisplayName Parms;SystemName;Name;VOID;cbDisplayName;LanguageId
     ⍝ Get Displayed Privilege Name of a Privilege Name
     ⍝ Parms[1] = SystemName (If 1=≡Parms: SystemName='')
     ⍝ Parms[2] = PrivilegeName
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≤##.GetVersion  ⍝ WinNT only
     :If 2>≡Parms
         Parms←''(,Parms)
     :EndIf
     SystemName Name←2↑Parms
     DisplayName←cbDisplayName←1024
     :If ##.ZERO≠↑VOID DisplayName cbDisplayName LanguageId←##.LookupPrivilegeDisplayName SystemName Name DisplayName cbDisplayName 1
         #.RCode←##.ERROR_SUCCESS
         DisplayName←cbDisplayName↑DisplayName
     :Else
         #.RCode←##.GetLastError
         DisplayName←''
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
     DisplayName←''
 :EndIf
∇

∇ Name←LookupPrivilegeName Parms;SystemName;Luid;cbName;VOID
     ⍝ Retrieve the name corresponding to the privilege represented on a specific system by a specified locally unique identifier (LUID).
     ⍝
     ⍝ Parms[1] = SystemName (If 1=≡Parms: SystemName='')
     ⍝ Parms[2] = LUID
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≤##.GetVersion  ⍝ WinNT only
     :If 2>≡Parms
         Parms←''(,Parms)
     :EndIf
     SystemName Luid←2↑Parms
     Name←cbName←256
     :If ##.ZERO≠↑VOID Name cbName←##.LookupPrivilegeName SystemName Luid Name cbName
         #.RCode←##.ERROR_SUCCESS
         Name←cbName↑Name
     :Else
         #.RCode←##.GetLastError
         Name←''
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
     Name←''
 :EndIf
∇

∇ Luid←LookupPrivilegeValue Parms;SystemName;Name;VOID
     ⍝ Retrieve LocallyUniqueIDentifier used on a specified system to locally represent the specified privilege name.
     ⍝ Parms[1] = SystemName (If 1=≡Parms: SystemName='')
     ⍝ Parms[2] = PrivilegeName
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≤##.GetVersion  ⍝ WinNT only
     :If 2>≡Parms
         Parms←''(,Parms)
     :EndIf
     SystemName Name←2↑Parms
     :If ##.ZERO≠↑VOID Luid←##.LookupPrivilegeValue SystemName Name 1
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         Luid←¯1 ¯1
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
     Luid←¯1 ¯1
 :EndIf
∇

∇ TokenHandle←OpenProcessToken Parms;VOID;ProcessHandle;DesiredAccess
     ⍝ Opens the access token associated with a process.
     ⍝
     ⍝ Parms[1] = ThreadHandle
     ⍝ Parms[2] = DesiredAccess (TOKEN_..)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≤##.GetVersion  ⍝ WinNT only
     :If 2>↑⍴Parms
         ProcessHandle←↑Parms
         DesiredAccess←##.TOKEN_READ
     :Else
         ProcessHandle DesiredAccess←2↑Parms
     :EndIf
     :If ##.ZERO≠↑VOID TokenHandle←##.OpenProcessToken ProcessHandle DesiredAccess 1
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         TokenHandle←##.INVALID_HANDLE_VALUE
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
     TokenHandle←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ TokenHandle←OpenThreadToken Parms;VOID;ThreadHandle;DesiredAccess;OpenAsSelf
     ⍝ Opens the access token associated with a thread.
     ⍝
     ⍝ Parms[1] = ThreadHandle
     ⍝ Parms[2] = DesiredAccess (TOKEN_..)
     ⍝ Parms[3] = OpenAsSelf (If TRUE: Uses Security Context of the process for the calling thread)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≤##.GetVersion  ⍝ WinNT only
     :If 2>↑⍴Parms
         ThreadHandle←↑Parms
         DesiredAccess←##.TOKEN_READ
     :Else
         ThreadHandle DesiredAccess OpenAsSelf←3↑Parms
     :EndIf
     :If ##.ZERO≠↑VOID TokenHandle←##.OpenThreadToken ThreadHandle DesiredAccess OpenAsSelf 1
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
         TokenHandle←##.INVALID_HANDLE_VALUE
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
     TokenHandle←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ {ValidFlag}←RevertToSelf
     ⍝ Terminate the impersonation of a client application.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≤##.GetVersion  ⍝ WinNT only
     :If ValidFlag←##.RevertToSelf
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :Else
     #.RCode←##.ERROR_CALL_NOT_IMPLEMENTED
     ValidFlag←##.FALSE
 :EndIf
∇

:EndNamespace 
:Namespace Semaphore
⎕IO ⎕ML ⎕WX←1 3 1

∇ {VOID}←Close hObject
     ⍝ Closes an open handle to an object such as a file handle.
     ⍝ VOID = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.TRUE=##.CloseHandle hObject
     #.RCode←##.ERROR_SUCCESS
     VOID←0
 :Else
     #.RCode←##.GetLastError
     VOID←1
 :EndIf
∇

∇ hSemaphore←{Name}Create Parms;InitialCount;MaximumCount;InheritHandle;SECURITY_ATTRIBUTES
     ⍝ Create a named (must be different from any event, mutex, waitable timer, job, or file-mapping object name) or unnamed semaphore object
     ⍝
     ⍝ Parms[1] = InitialCount       (0≤InitialCount≤MaximumCount)
     ⍝ Parms[2] = MaximumCount       (0<MaximumCount)
     ⍝ Parms[3] = InheritHandle Flag (def. #.Win.FALSE)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 InitialCount MaximumCount InheritHandle←3↑Parms
 InitialCount⌈←0
 MaximumCount⌈←1⌈InitialCount
 SECURITY_ATTRIBUTES←##.SECURITY_ATTRIBUTES
 :Select InheritHandle
 :Case ##.FALSE
     SECURITY_ATTRIBUTES[3]←##.FALSE
 :Case ##.TRUE
     SECURITY_ATTRIBUTES[3]←##.TRUE
 :EndSelect
 :If ×⎕NC'Name'
 :AndIf 0≠↑⍴Name
     :If ##.NULL≠hSemaphore←##.CreateSemaphore SECURITY_ATTRIBUTES InitialCount MaximumCount Name
         #.RCode←##.GetLastError
     :Else
         #.RCode←##.GetLastError
         hSemaphore←##.INVALID_HANDLE_VALUE
     :EndIf
 :Else
     :If ##.NULL≠hSemaphore←##.CreateSemaphoreI SECURITY_ATTRIBUTES InitialCount MaximumCount 0
         #.RCode←##.GetLastError
     :Else
         #.RCode←##.GetLastError
         hSemaphore←##.INVALID_HANDLE_VALUE
     :EndIf
 :EndIf
∇

∇ hSemaphore←Name Open Parms;DesiredAccess;InheritHandle
     ⍝ Return a handle to an existing named semaphore object
     ⍝
     ⍝ Parms[1] = DesiredAccess    (#.Win.SEMAPHORE_ALL_ACCESS #.Win.SEMAPHORE_MODIFY_STATE #.Win.SYNCHRONIZE)
     ⍝ Parms[2] = InheritHandleFlag (def. #.Win.FALSE)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 DesiredAccess InheritHandle←2↑Parms
 :If 0=DesiredAccess
     DesiredAccess←##.SEMAPHORE_ALL_ACCESS
 :EndIf
 :If ##.NULL≠hSemaphore←##.OpenSemaphore DesiredAccess InheritHandle Name
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hSemaphore←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ PreviousCount←Release Parms;hSemaphore;ReleaseCount;VOID
     ⍝ Increase the count of the specified semaphore object by a specified amount
     ⍝
     ⍝ Parms[1] = hSemaphore
     ⍝ Parms[2] = ReleaseCount (0<ReleaseCount≤MaximumCount-CurrentCount)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hSemaphore ReleaseCount←2↑Parms
 ReleaseCount⌈←1
 :If ##.ZERO≠↑VOID PreviousCount←##.ReleaseSemaphore hSemaphore ReleaseCount 1
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     PreviousCount←¯1
 :EndIf
∇

∇ Status←Wait Parms;hHandle;Milliseconds;Full;Last
     ⍝ Return when one of the following occurs: The specified object is in the signaled state. The time-out interval elapses
     ⍝
     ⍝ Parms[1] = hHandle
     ⍝ Parms[2] = Milliseconds to wait or #.Win.INFINITE
     ⍝
     ⍝ Status   = #.Win.WAIT_OBJECT_0  (0)   The state of the specified object is signaled
     ⍝ Status   = #.Win.WAIT_ABANDONED (128) The specified object is a mutex object that was released by thread terminate
     ⍝ Status   = #.Win.WAIT_TIMEOUT   (258) The time-out interval elapsed, and the object's state is nonsignaled
     ⍝ Status   = #.Win.WAIT_FAILED    (¯1)  The function fails, see #.RCode
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hHandle Milliseconds←2↑Parms,##.INFINITE
 Full Last←0(Milliseconds←25)⊤Milliseconds
 :Trap 1000
     :Repeat
         :If ¯1=Full←¯1+Full
             Milliseconds←Last
         :EndIf
         :If #.Win.WAIT_TIMEOUT≠Status←##.WaitForSingleObject hHandle Milliseconds
             :Leave
         :EndIf
     :Until ¯1=Full
     :OrIf 0 0≡Full Last
 :Else
     Status←##.WAIT_TIMEOUT
 :EndTrap
 #.RCode←##.GetLastError
∇

:EndNamespace 
:Namespace Sys
⎕IO ⎕ML ⎕WX←1 3 1

∇ {VOID}←ExitWindows Flags;TokenHandle;PreviousState
     ⍝ Logs off, shuts down, or shuts down and restarts the system.
     ⍝
     ⍝ Valid Flag combinations: #.Win.EWX_LOGOFF+#.Win.EWX_SHUTDOWN+#.Win.EWX_REBOOT+#.Win.EWX_FORCE+#.Win.EWX_POWEROFF
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≤##.GetVersion  ⍝ WinNT only
 :AndIf (##.BitInt ##.EWX_SHUTDOWN+##.EWX_REBOOT+##.EWX_FORCE+##.EWX_POWEROFF)∨.∧##.BitInt Flags
 :AndIf ##.INVALID_HANDLE_VALUE≠TokenHandle←##.Security.OpenProcessToken ##.Proc.GetCurrentProcess(##.TOKEN_ADJUST_PRIVILEGES+##.TOKEN_QUERY)
     PreviousState←##.Security.AdjustTokenPrivileges GetComputerName TokenHandle 0(##.SE_SHUTDOWN_NAME ##.SE_PRIVILEGE_ENABLED)
     ##.Security.Close TokenHandle
 :EndIf
 :If ##.ZERO≠VOID←##.ExitWindowsEx Flags ¯1
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Value←GetColor Index
     ⍝ Gets the current RGB-color of the specified display element.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 Value←256|¯1↓##.IntTxt ##.GetSysColor Index
∇

∇ Buffer←GetComputerName;ValidFlag;Size
     ⍝ Gets the computer name of the current system.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ↑ValidFlag Buffer Size←##.GetComputerName 2⍴1+##.MAX_COMPUTERNAME_LENGTH
     #.RCode←##.ERROR_SUCCESS
     Buffer←Size↑Buffer
 :Else
     #.RCode←##.GetLastError
     Buffer←''
 :EndIf
∇

∇ A←GetDefaultLangID
     ⍝ Gets the system default LangID and SubLangID
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 A←⌽64 1024⊤##.GetSystemDefaultLangID
∇

∇ DeviceCaps←{Object}GetDeviceCaps Index;Form;hWnd;hDC;VOID
     ⍝ Retrieve device-specific information for the specified device
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×⎕NC'Object'
     :If 82=⎕DR Object
         hWnd←Object ⎕WG'Handle'
     :Else
         hWnd←Object
     :EndIf
 :Else
     'Form'⎕WC'Form'('Visible' 0)
     hWnd←'Form'⎕WG'Handle'
 :EndIf
 hDC←##.GetDC hWnd
 DeviceCaps←##.GetDeviceCaps hDC Index
 VOID←##.ReleaseDC hWnd hDC
∇

∇ LogFont←GetIconTitleFont;VOID
     ⍝ Characteristics of Icon Title Log Font/Symbol Font (Symbolunterschriften/TreeView/ListView):
     ⍝ LogFont[1]:  Height
     ⍝ LogFont[2]:  Width
     ⍝ LogFont[3]:  Escapement
     ⍝ LogFont[4]:  Orientation
     ⍝ LogFont[5]:  Weight
     ⍝ LogFont[6]:  Italic
     ⍝ LogFont[7]:  Underline
     ⍝ LogFont[8]:  StrikeOut
     ⍝ LogFont[9]:  CharSet
     ⍝ LogFont[10]: OutPrecision
     ⍝ LogFont[11]: ClipPrecision
     ⍝ LogFont[12]: Quality
     ⍝ LogFont[13]: PitchAndFamily
     ⍝ LogFont[14]: FaceName
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.ZERO≠↑VOID LogFont←##.SystemParametersInfoLogFont ##.SPI_GETICONTITLELOGFONT 60 ##.LOGFONT 0
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     LogFont←##.LOGFONT
 :EndIf
 (14⊃LogFont)←{(¯1+⍵⍳↑⎕AV)↑⍵}14⊃LogFont
∇

∇ Value←GetMetrics Index
     ⍝ Gets various system metrics and system configuration settings.
     ⍝ Index = SM_xxx
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 Value←##.GetSystemMetrics¨Index
∇

∇ Font←GetNonClientFonts;HeightFactor;DecodeLogFont;VOID;NonClientMetrics
     ⍝ Characteristics of Non Client Area Fonts
     ⍝ Font[1]: CaptionFont   Titelleisten der (in)aktiven Fenster
     ⍝ Font[2]: SmCaptionFont Palettentitel (Titelleisten verschiebbarer Menüs)
     ⍝ Font[3]: MenuFont      Menü/Markierte Elemente (Normal/Ausgewählt)
     ⍝ Font[4]: StatusFont    Quickinfo (Beschreibungsleiste/TipField)
     ⍝ Font[5]: MessageFont   Dialogfeld (Dialogfeldtext)
     ⍝
     ⍝ NONCLIENTMETRICS:
     ⍝ UINT    cbSize
     ⍝ int     iBorderWidth
     ⍝ int     iScrollWidth
     ⍝ int     iScrollHeight
     ⍝ int     iCaptionWidth
     ⍝ int     iCaptionHeight
     ⍝ LOGFONT lfCaptionFont
     ⍝ int     iSmCaptionWidth
     ⍝ int     iSmCaptionHeight
     ⍝ LOGFONT lfSmCaptionFont
     ⍝ int     iMenuWidth
     ⍝ int     iMenuHeight
     ⍝ LOGFONT lfMenuFont
     ⍝ LOGFONT lfStatusFont
     ⍝ LOGFONT lfMessageFont
     ⍝
     ⍝ LOGFONT:
     ⍝ LONG lfHeight
     ⍝ LONG lfWidth
     ⍝ LONG lfEscapement
     ⍝ LONG lfOrientation
     ⍝ LONG lfWeight
     ⍝ BYTE lfItalic
     ⍝ BYTE lfUnderline
     ⍝ BYTE lfStrikeOut
     ⍝ BYTE lfCharSet
     ⍝ BYTE lfOutPrecision
     ⍝ BYTE lfClipPrecision
     ⍝ BYTE lfQuality
     ⍝ BYTE lfPitchAndFamily
     ⍝ TCHAR lfFaceName[32]
     ⍝
     ⍝ HeightFactor←¯72÷GetDeviceCaps ##.LOGPIXELSY ⍝ Height=-MulDiv(PointSize,GetDeviceCaps(hDC,LOGPIXELSY),72)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 DecodeLogFont←{(⊂{(¯1+⍵⍳↑⎕AV)↑⍵}4 ##.TxtInt 8↑7↓⍵),⍵[1],({(2|⍵[8]),⍵[1 2]}1 ##.IntTxt 4 ##.TxtInt ⍵[6 7]),⍵[5],○⍵[4]÷1800}
 :If ##.ZERO≠↑VOID NonClientMetrics←##.SystemParametersInfoI4 ##.SPI_GETNONCLIENTMETRICS 340(85↑340)0
     Font←DecodeLogFont¨15↑¨6 23 40 55 70↓¨⊂NonClientMetrics
     #.RCode←##.ERROR_SUCCESS
 :Else
     Font←6⍴⊂'' 0 0 0 0 0 0
     #.RCode←##.GetLastError
 :EndIf
∇

∇ NonClientMetrics←GetNonClientMetrics;VOID
     ⍝ NonClientMetrics[1]:  Size of structure
     ⍝ NonClientMetrics[2]:  BorderWidth
     ⍝ NonClientMetrics[3]:  ScrollWidth
     ⍝ NonClientMetrics[4]:  ScrollHeight
     ⍝ NonClientMetrics[5]:  CaptionWidth
     ⍝ NonClientMetrics[6]:  CaptionHeight
     ⍝ NonClientMetrics[7]:  CaptionFont
     ⍝ NonClientMetrics[8]:  SmCaptionWidth
     ⍝ NonClientMetrics[9]:  SmCaptionHeight
     ⍝ NonClientMetrics[10]: SmCaptionFont
     ⍝ NonClientMetrics[11]: MenuWidth
     ⍝ NonClientMetrics[12]: MenuHeight
     ⍝ NonClientMetrics[13]: MenuFont
     ⍝ NonClientMetrics[14]: StatusFont
     ⍝ NonClientMetrics[15]: MessageFont
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.ZERO≠↑VOID NonClientMetrics←##.SystemParametersInfoNonClientMetrics ##.SPI_GETNONCLIENTMETRICS 340 ##.NONCLIENTMETRICS 0
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     NonClientMetrics←##.NONCLIENTMETRICS
 :EndIf
 NonClientMetrics[(7 14)(10 14)(13 14)(14 14)(15 14)]←{(¯1+⍵⍳↑⎕AV)↑⍵}¨NonClientMetrics[(7 14)(10 14)(13 14)(14 14)(15 14)]
∇

∇ Object←GetObject hGdiObj;ObjectType;LOGFONT;BITMAP;DIBSECTION;LOGPEN;EXTLOGPEN;LOGBRUSH
     ⍝ Retrieve information for the specified graphics object
     ⍝
     ⍝ hGdiObj = Handle to an GDI object or one of the following:
     ⍝ #.Win.ANSI_FIXED_FONT   Windows fixed-pitch (monospace) system font
     ⍝ #.Win.ANSI_VAR_FONT     Windows variable-pitch (proportional space) system font
     ⍝ #.Win.DEFAULT_GUI_FONT  Default font for user interface objects such as menus and dialog boxes. This is MS Sans Serif. Compare this with SYSTEM_FONT
     ⍝ #.Win.OEM_FIXED_FONT    Original equipment manufacturer (OEM) dependent fixed-pitch (monospace) font
     ⍝ #.Win.SYSTEM_FONT       System font. By default, the system uses the system font to draw menus, dialog box controls, and text
     ⍝ #.Win.SYSTEM_FIXED_FONT Fixed-pitch (monospace) system font. This stock object is provided only for compatibility with 16-bit Windows versions earlier than 3.0
     ⍝ #.Win.BLACK_BRUSH       Black brush
     ⍝ #.Win.DKGRAY_BRUSH      Dark gray brush
     ⍝ #.Win.GRAY_BRUSH        Gray brush
     ⍝ #.Win.LTGRAY_BRUSH      Light gray brush
     ⍝ #.Win.NULL_BRUSH        Hollow brush
     ⍝ #.Win.WHITE_BRUSH       White brush
     ⍝ #.Win.DEFAULT_PALETTE   Default palette. This palette consists of the static colors in the system palette
     ⍝ #.Win.BLACK_PEN         Black pen
     ⍝ #.Win.WHITE_PEN         White pen
     ⍝
     ⍝ Object  = One of the following structures: LOGFONT BITMAP DIBSECTION WORD EXTLOGPEN LOGPEN LOGBRUSH
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 LOGFONT←4 4 4 4 4 1 1 1 1 1 1 1 1 ¯32
 BITMAP←4 4 4 4 2 2
 DIBSECTION←4 4 4 4 2 2 4 4 4 2 2 4 4 4 4 4 4 4 4 4 4 4
 LOGPEN←4 4 4 4
 EXTLOGPEN←4 4 4 4 4 4 4
 LOGBRUSH←4 4 4
 :If hGdiObj∊##.ANSI_FIXED_FONT ##.ANSI_VAR_FONT ##.DEFAULT_GUI_FONT ##.OEM_FIXED_FONT ##.SYSTEM_FONT ##.SYSTEM_FIXED_FONT ##.BLACK_BRUSH ##.DKGRAY_BRUSH ##.GRAY_BRUSH ##.LTGRAY_BRUSH ##.NULL_BRUSH ##.WHITE_BRUSH ##.DEFAULT_PALETTE ##.BLACK_PEN ##.WHITE_PEN
     hGdiObj←##.GetStockObject hGdiObj
 :EndIf
 :If ×↑⍴Object←↑↑/##.GetObject hGdiObj 1024 1024
 :AndIf 0≠ObjectType←##.GetObjectType hGdiObj
     :Select ObjectType
     :Case ##.OBJ_FONT
         Object←LOGFONT ##.SplitTxtStruct Object
     :Case ##.OBJ_BITMAP
         :Select ↑⍴Object
         :Case +/|BITMAP
             Object←BITMAP ##.SplitTxtStruct Object
         :Case +/|DIBSECTION
             Object←DIBSECTION ##.SplitTxtStruct Object
         :EndSelect
     :Case ##.OBJ_PAL
         Object←2 ##.IntTxt 2↑Object
     :Case ##.OBJ_PEN
         :Select ↑⍴Object
         :Case +/|LOGPEN
             Object←LOGPEN ##.SplitTxtStruct Object
         :Case +/|EXTLOGPEN
             Object←EXTLOGPEN ##.SplitTxtStruct Object
         :EndSelect
     :Case ##.OBJ_BRUSH
         Object←LOGBRUSH ##.SplitTxtStruct Object
     :EndSelect
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     Object←⍬
 :EndIf
∇

∇ ObjectType←GetObjectType hGdiObj
     ⍝ Retrieve the type of the specified object by handle
     ⍝
     ⍝ ObjectType = 0 or one of the following:
     ⍝
     ⍝ #.Win.OBJ_BITMAP      Bitmap
     ⍝ #.Win.OBJ_BRUSH       Brush
     ⍝ #.Win.OBJ_COLORSPACE  Color space
     ⍝ #.Win.OBJ_DC          Device context
     ⍝ #.Win.OBJ_ENHMETADC   Enhanced metafile DC
     ⍝ #.Win.OBJ_ENHMETAFILE Enhanced metafile
     ⍝ #.Win.OBJ_EXTPEN      Extended pen
     ⍝ #.Win.OBJ_FONT        Font
     ⍝ #.Win.OBJ_MEMDC       Memory DC
     ⍝ #.Win.OBJ_METAFILE    Metafile
     ⍝ #.Win.OBJ_METADC      Metafile DC
     ⍝ #.Win.OBJ_PAL         Palette
     ⍝ #.Win.OBJ_PEN         Pen
     ⍝ #.Win.OBJ_REGION      Region
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠ObjectType←##.GetObjectType hGdiObj
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ hGdiObj←GetStockObject Object
     ⍝ Retrieve a handle to one of the stock pens, brushes, fonts, or palettes
     ⍝
     ⍝ Object = One of the following:
     ⍝ #.Win.ANSI_FIXED_FONT   Windows fixed-pitch (monospace) system font
     ⍝ #.Win.ANSI_VAR_FONT     Windows variable-pitch (proportional space) system font
     ⍝ #.Win.DEFAULT_GUI_FONT  Default font for user interface objects such as menus and dialog boxes. This is MS Sans Serif. Compare this with SYSTEM_FONT
     ⍝ #.Win.OEM_FIXED_FONT    Original equipment manufacturer (OEM) dependent fixed-pitch (monospace) font
     ⍝ #.Win.SYSTEM_FONT       System font. By default, the system uses the system font to draw menus, dialog box controls, and text
     ⍝ #.Win.SYSTEM_FIXED_FONT Fixed-pitch (monospace) system font. This stock object is provided only for compatibility with 16-bit Windows versions earlier than 3.0
     ⍝ #.Win.BLACK_BRUSH       Black brush
     ⍝ #.Win.DKGRAY_BRUSH      Dark gray brush
     ⍝ #.Win.GRAY_BRUSH        Gray brush
     ⍝ #.Win.LTGRAY_BRUSH      Light gray brush
     ⍝ #.Win.NULL_BRUSH        Hollow brush
     ⍝ #.Win.WHITE_BRUSH       White brush
     ⍝ #.Win.DEFAULT_PALETTE   Default palette. This palette consists of the static colors in the system palette
     ⍝ #.Win.BLACK_PEN         Black pen
     ⍝ #.Win.WHITE_PEN         White pen
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠hGdiObj←##.GetStockObject Object
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hGdiObj←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ A←GetSystemDirectory
     ⍝ Gets the WINDOWS\SYSTEM directory of the system.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 A←⊃↑/##.GetSystemDirectory ##.MAX_PATH ##.MAX_PATH
∇

∇ Buffer←GetUserName;VOID;Size
     ⍝ Gets the user name of the current thread.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.ZERO≠↑VOID Buffer Size←##.GetUserName ##.MAX_PATH ##.MAX_PATH
     #.RCode←##.ERROR_SUCCESS
     Buffer←Size↑Buffer
 :Else
     #.RCode←##.GetLastError
     Buffer←''
 :EndIf
∇

∇ Version←GetVersion;VOID
     ⍝ Gets the OS version.
     ⍝ Version[1] = MajorVersion (eg 4)
     ⍝ Version[2] = MinorVersion (eg 0)
     ⍝ Version[3] = BuildNumber  (eg 1381)
     ⍝ Version[4] = PlatformId   (eg 0=VER_PLATFORM_WIN32s 1=VER_PLATFORM_WIN32_WINDOWS 2=VER_PLATFORM_WIN32_NT)
     ⍝ Version[5] = CSDVersion   (eg 'Service Pack 3')
     ⍝
     ⍝ Obsolete:
     ⍝ Version←⌽2 32768 256 256⊤##.GetVersion
     ⍝ Version[1] = Major version number (eg 4)
     ⍝ Version[2] = Minor version number (eg 0)
     ⍝ Version[3] = Build number (eg 1381)
     ⍝ Version[4] = 0=WinNT 1=Win16/Win95/Win98
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.ZERO≠↑VOID Version←##.GetVersionEx⊂##.OSVERSIONINFO
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
 Version←Version[2 3 4 5],⊂(↑⎕AV){(¯1+⍵⍳⍺)↑⍵}6⊃Version
∇

∇ A←GetWindowsDirectory
     ⍝ Gets the WINDOWS directory of the system.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 A←⊃↑/##.GetWindowsDirectory ##.MAX_PATH ##.MAX_PATH
∇

∇ Size←{Object}TextSize Text;Form;hWnd;hDC;VOID
     ⍝ Compute the height and width of the specified string of text
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ×⎕NC'Object'
     :If 82=⎕DR Object
         hWnd←Object ⎕WG'Handle'
     :Else
         hWnd←Object
     :EndIf
 :Else
     'Form'⎕WC'Form'('Visible' 0)
     hWnd←'Form'⎕WG'Handle'
 :EndIf
 hDC←##.GetDC hWnd
 VOID Size←##.GetTextExtentPoint32 hDC Text(↑⍴Text←,Text)0
 VOID←##.ReleaseDC hWnd hDC
 Size←⌽Size
∇

:EndNamespace 
:Namespace Time
⎕IO ⎕ML ⎕WX←1 3 1

∇ LocalSystemTime←FileToLocalSystem FileTime;LocalFileTime;Bool
     ⍝ Convert file time in ms since 01.01.1601 to local system time in ⎕TS format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ↑Bool LocalFileTime←##.FileTimeToLocalFileTime(⌽4294967296 4294967296⊤10000×FileTime)1
 :AndIf ↑Bool LocalSystemTime←##.FileTimeToSystemTime LocalFileTime 1
     #.RCode←##.ERROR_SUCCESS
     LocalSystemTime←1 1 0 1 1 1 1 1/LocalSystemTime
 :Else
     #.RCode←##.GetLastError
     LocalSystemTime←0 0 0 0 0 0 0
 :EndIf
∇

∇ SystemTime←FileToSystem FileTime;Bool
     ⍝ Convert file time in ms since 01.01.1601 to system time in ⎕TS format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ↑Bool SystemTime←##.FileTimeToSystemTime(⌽4294967296 4294967296⊤10000×FileTime)1
     #.RCode←##.ERROR_SUCCESS
     SystemTime←1 1 0 1 1 1 1 1/SystemTime
 :Else
     #.RCode←##.GetLastError
     SystemTime←0 0 0 0 0 0 0
 :EndIf
∇

∇ UnixTime←FileToUnix FileTime
     ⍝ Convert ms since 01.01.1601 to seconds since 01.01.1970
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 :If 0≠FileTime
     UnixTime←(0≠FileTime)×⌊¯11644473600+0.001×FileTime
 :Else
     UnixTime←0
 :EndIf
∇

∇ SystemTime←GetSystem
     ⍝ Retrieve current system date and time. The system time is expressed in UTC and returned in ⎕TS format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 SystemTime←1 1 0 1 1 1 1 1/##.GetSystemTime 1
∇

∇ TickCount←GetTickCount
     ⍝ Retrieve number of ms elapsed since system was started
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 TickCount←##.GetTickCount
∇

∇ FileTime←LocalSystemToFile LocalSystemTime;LocalFileTime;Bool
     ⍝ Convert local system time in ⎕TS format to file time in ms since 01.01.1601
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ↑Bool LocalFileTime←##.SystemTimeToFileTime(1 1 0 1 1 1 1 1\7↑LocalSystemTime)1
 :AndIf ↑Bool FileTime←##.LocalFileTimeToFileTime LocalFileTime 1
     #.RCode←##.ERROR_SUCCESS
     FileTime←⌊0.0001×4294967296⊥⌽FileTime
 :Else
     #.RCode←##.GetLastError
     FileTime←0
 :EndIf
∇

∇ SystemTime←LocalSystemToSystem LocalSystemTime;LocalFileTime;FileTime;Bool
     ⍝ Convert local file time in ⎕TS format to file time based on UTC in ⎕TS format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ↑Bool LocalFileTime←##.SystemTimeToFileTime(1 1 0 1 1 1 1 1\7↑LocalSystemTime)1
 :AndIf ↑Bool FileTime←##.LocalFileTimeToFileTime LocalFileTime 1
 :AndIf ↑Bool SystemTime←##.FileTimeToSystemTime FileTime 1
     #.RCode←##.ERROR_SUCCESS
     SystemTime←1 1 0 1 1 1 1 1/SystemTime
 :Else
     #.RCode←##.GetLastError
     SystemTime←0 0 0 0 0 0 0
 :EndIf
∇

∇ FileTime←SystemToFile SystemTime;Bool
     ⍝ Convert system time in ⎕TS format to file time in ms since 01.01.1601
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ↑Bool FileTime←##.SystemTimeToFileTime(1 1 0 1 1 1 1 1\7↑SystemTime)1
     #.RCode←##.ERROR_SUCCESS
     FileTime←⌊0.0001×4294967296⊥⌽FileTime
 :Else
     #.RCode←##.GetLastError
     FileTime←0
 :EndIf
∇

∇ LocalSystemTime←SystemToLocalSystem SystemTime;FileTime;LocalFileTime;Bool
     ⍝ Convert file time based on UTC in ⎕TS format to local file time in ⎕TS format
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ↑Bool FileTime←##.SystemTimeToFileTime(1 1 0 1 1 1 1 1\7↑SystemTime)1
 :AndIf ↑Bool LocalFileTime←##.FileTimeToLocalFileTime FileTime 1
 :AndIf ↑Bool LocalSystemTime←##.FileTimeToSystemTime LocalFileTime 1
     #.RCode←##.ERROR_SUCCESS
     LocalSystemTime←1 1 0 1 1 1 1 1/LocalSystemTime
 :Else
     #.RCode←##.GetLastError
     LocalSystemTime←0 0 0 0 0 0 0
 :EndIf
∇

∇ FileTime←UnixToFile UnixTime
     ⍝ Convert seconds since 01.01.1970 to ms since 01.01.1601
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 :If 0≠UnixTime
     FileTime←1000×11644473600+⌊4294967296|UnixTime
 :Else
     FileTime←0
 :EndIf
∇

:EndNamespace 
:Namespace Uuid
⎕IO ⎕ML ⎕WX←1 3 1

∇ Uuid←Create;VOID
     ⍝ Create a new UUID
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 VOID Uuid←##.UuidCreate 1
∇

∇ StringUuid←CreateString;VOID;Uuid
     ⍝ Create a new UUID and convert UUID to a string
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 VOID Uuid←##.UuidCreate 1
 StringUuid←'0123456789ABCDEF{-'[1+∊16 17 17 17 17,¨∊¨⍉¨16 16∘⊤¨Uuid],'}'
∇

:EndNamespace 
:Namespace WNet
⎕IO ⎕ML ⎕WX←1 3 1

∇ {VOID}←{Persistent}AddConnection Parms;Username;Password;LocalName;RemoteName;Provider;lpLocalName;lpRemoteName;lpProvider;Flags
     ⍝ Connect to a network resource.
     ⍝ The function can redirect a local device to the network resource.
     ⍝ If Persistent is set the connection will be restored when the user logs on.
     ⍝
     ⍝ Parms[1]   = LocalName
     ⍝ Parms[2]   = RemoteName (opt)
     ⍝ Parms[3]   = Provider   (opt)
     ⍝ Parms[4]   = Username   (opt)
     ⍝ Parms[5]   = Password   (opt)
     ⍝ Persistent = 0 or 1
     ⍝ VOID       = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 1≥≡Parms
     Parms←,⊂,Parms
 :EndIf
 LocalName RemoteName Provider Username Password←5↑Parms,5⍴⊂''
 :If ×↑⍴LocalName
     lpLocalName←##.Mem.Alloc LocalName,↑⎕AV
     :If ×⎕NC'Persistent'
         Flags←##.CONNECT_UPDATE_PROFILE×0≠↑Persistent
     :Else
         Flags←##.CONNECT_UPDATE_PROFILE
     :EndIf
 :Else
     lpLocalName←##.NULL
     Flags←0
 :EndIf
 lpRemoteName←##.Mem.Alloc RemoteName,↑⎕AV
 :If ×↑⍴Provider
     lpProvider←##.Mem.Alloc Provider,↑⎕AV
 :Else
     lpProvider←##.NULL
 :EndIf
 VOID←##.WNetAddConnection3 ##.NULL(0 ##.RESOURCETYPE_DISK 0 0 lpLocalName lpRemoteName ##.NULL lpProvider)Password Username Flags
 :If 0≠lpLocalName
     ##.Mem.Free lpLocalName
 :EndIf
 :If 0≠lpRemoteName
     ##.Mem.Free lpRemoteName
 :EndIf
 :If 0≠lpProvider
     ##.Mem.Free lpProvider
 :EndIf
 #.RCode←VOID
 VOID←#.RCode≠##.ERROR_SUCCESS
∇

∇ {VOID}←{Persistent}CancelConnection Parms;Name;Flags;Force
     ⍝ Cancel a connection to a network resource.
     ⍝ If Force is set caneling will even be executed with open files.
     ⍝ If Persistent is set the connection will no longer be restored when the user logs on.
     ⍝
     ⍝ Parms[1]   = LocalName(Persistent-default=1) or RemoteName(Persistent-default=0)
     ⍝ Parms[2]   = Force
     ⍝ Persistent = 0 or 1
     ⍝ VOID       = 1=Fail 0=ok
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 1≥≡Parms
     Parms←,⊂,Parms
 :EndIf
 Name Force←2↑Parms,(⍴Parms)↓'' 0
 Force←1=↑Force
 :If ×⎕NC'Persistent'
     Flags←##.CONNECT_UPDATE_PROFILE×0≠↑Persistent
 :ElseIf (,2)≡⍴Name
 :AndIf ∧/Name∊¨⎕A':'
     Flags←##.CONNECT_UPDATE_PROFILE
 :Else
     Flags←0
 :EndIf
 VOID←##.ERROR_SUCCESS≠#.RCode←##.WNetCancelConnection2 Name Flags Force
∇

∇ {RemoteName}←{Persistent}GetUniversalName LocalName;Length;InfoLevel;lpBuffer;Buffer;BufferSize;VOID
     ⍝ Get the UNC name out of a LocalName
     ⍝ WinNT only: Even the UNC name of a local file name will be evaluated.
     ⍝ If Persistent is set the connection will be restored when the user logs on.
     ⍝
     ⍝ Persistent = 0 or 1
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
     
 ##.Init
 :If ×⎕NC'Persistent'
 :AndIf ##.ERROR_SUCCESS≠↑#.RCode←##.WNetSetConnection LocalName ##.NETPROPERTY_PERSISTENT(##.TRUE×0≠↑Persistent)
     RemoteName←''
 :ElseIf (,2)≡⍴LocalName
 :AndIf ∧/LocalName∊¨⎕A':'
     :If ##.ERROR_SUCCESS≠↑#.RCode RemoteName Length←##.WNetGetConnection LocalName ##.MAX_PATH ##.MAX_PATH
         RemoteName←''
     :EndIf
 :ElseIf 0≤##.GetVersion ⍝ WinNT only
 :AndIf ##.NULL≠lpBuffer←##.Mem.Alloc BufferSize←1024
     LocalName←↑↑/2↑##.GetFullPathName LocalName 1024 1024 0
     :If ##.ERROR_SUCCESS≠↑VOID BufferSize←##.WNetGetUniversalName LocalName ##.UNIVERSAL_NAME_INFO_LEVEL lpBuffer BufferSize
         RemoteName←0 ##.Mem.Free lpBuffer
         #.RCode←VOID
     :Else
         RemoteName←{(¯1+⍵⍳↑⎕AV)↑⍵}((4 ##.IntTxt 4↑Buffer)-lpBuffer)↓Buffer←BufferSize ##.Mem.Free lpBuffer
         #.RCode←VOID
     :EndIf
 :Else
     RemoteName←''
 :EndIf
∇

:EndNamespace 
:Namespace Window
⎕IO ⎕ML ⎕WX←1 3 1

∇ {Object}CreateMsgBox Parms;CodeHex;CodeWord;Parm;Caption;Text;Style;Button;DefBtn;DefBtnFlag;ServiceFlag;OwnerFlag;Icon;Event;BaseObject;hWindow;hOwner;hThread;hModule;hMemProc;MsgDCM1;Code;oBoxText;oCapText;oIcoText;oHlpInfo;oMBCBack;oMBParms;oMsgBoxI;oMsgPost;oCode;odwStyle;ohThread;pBoxText;pCapText;pIcoText;pHlpInfo;pMBCBack;pMBParms;pMsgBoxI;pMsgPost;pdwStyle;pThread;ThreadId
     ⍝ Provides a dialog box for displaying messages, errors, warnings and other information.
     ⍝ The dialog box has a title, an optional icon, one or more lines of text, and up to four buttons.
     ⍝ If Object is a child of a Form or SubForm, the MsgBox becomes the modal input of the form.
     ⍝ If Object is a child of Root or a Namespace, the MsgBox in non modal.
     ⍝
     ⍝ In conrast to Dyalog's MsgBox, this MsgBox is drawn immediately upon creation and it always fires events,
     ⍝ even when not in ⎕DQ state. In any case you MUST NOT erase the Object out of your program. The MsgBox
     ⍝ and its representing Object will be deleted by clicking on a button other than the Help button.
     ⍝ The MsgBox cannot be recreated by executing this function again with the same Object name as long as
     ⍝ the user has not terminated it by clicking on a button.
     ⍝
     ⍝ Properties Description
     ⍝ ---------- --------------------------------------------------------------------------------------------------------
     ⍝ Caption    Character vector
     ⍝            Defines the title of the MsgBox.
     ⍝
     ⍝ Text       Simple scalar/vector/matrix or vector of vectors
     ⍝            Defines the text content of the MsgBox.
     ⍝
     ⍝ Style      'Msg' 'Info' 'Query' 'Warn' or 'Error'
     ⍝            Determines the type of icon which is displayed in the MsgBox.
     ⍝
     ⍝ Btns       'OK' ('OK' 'Cancel') ('Abort' 'Retry' 'Ignore') ('Yes' 'No' 'Cancel') ('Yes' 'No') or ('Retry' 'Cancel')
     ⍝            Determines the set of buttons to be displayed in the MsgBox.
     ⍝
     ⍝ HelpButton Boolean property specifying whether or not a Help button appears in the MsgBox.
     ⍝            This property is disabled when Dyalog runs as a service.
     ⍝
     ⍝ Default    value 1, 2, 3 or 4 corresponding to the four buttons that can be defined.
     ⍝            Determines which of the push buttons in the MsgBox is the default button.
     ⍝
     ⍝ Justify    'Left' (default) or 'Right'
     ⍝            Determines the manner in which text is justified within the MsgBox.
     ⍝
     ⍝ Event      ('MsgBtn1' 'onBtn') ('MsgBtn2' 'onBtn') ('MsgBtn3' 'onBtn') and/or ('Help' 'onBtn')
     ⍝            Defines how the MsgBox responds to user actions.
     ⍝
     ⍝ OnTop      Boolean property causing the MsgBox to be displayed on top of all other applications windows.
     ⍝
     ⍝
     ⍝ Events     Description
     ⍝ ---------- --------------------------------------------------------------------------------------------------------
     ⍝ MsgBtn1    Object Event←2↑Message
     ⍝            If enabled, this event is reported when the user clicks the MsgBox first (leftmost) button.
     ⍝            This event pops down the MsgBox automatically, erases the Object, and terminates a singe Object ⎕DQ.
     ⍝
     ⍝ MsgBtn2    Object Event←2↑Message
     ⍝            If enabled, this event is reported when the user clicks the MsgBox second (from the left) button.
     ⍝            This event pops down the MsgBox automatically, erases the Object, and terminates a singe Object ⎕DQ.
     ⍝
     ⍝ MsgBtn3    Object Event←2↑Message
     ⍝            If enabled, this event is reported when the user clicks the MsgBox third (from the left) button.
     ⍝            This event pops down the MsgBox automatically, erases the Object, and terminates a singe Object ⎕DQ.
     ⍝
     ⍝ Help       Object Event yCoord xCoord←4↑Message
     ⍝            If enabled, this event is reported each time the user clicks the MsgBox Help button.
     ⍝            The mouse coordinates are always zero and are only reported for compatibility reasons.
     ⍝            You need to set ('HelpButton' 1) to enable Help events.
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2001
     ⍝ mailto:Hager@Dortmund.net
 :If ×⎕NC'Object'
     ⍝ Entry for MessageBox Thread Creation
     #.Win.Init
     CodeHex←{1<≡⍵:∊∇¨⍵ ⋄ ⌽#.Win.TxtHex ⍵}
     CodeWord←{0<≡⍵:∊∇¨⍵ ⋄ 4 #.Win.TxtInt ⍵}
     ⍝ Parameter Defaults
     Caption←''
     Text←''
     :If ServiceFlag←⎕AN≡'SYSTEM'
         Style←#.Win.MB_SERVICE_NOTIFICATION
     :Else
         Style←0
     :EndIf
     DefBtn←#.Win.MB_OK
     DefBtnFlag←1
     Icon←''
     Event←(⊂'DyalogCustomMessage1'((⎕CS''),'.CreateMsgBox'))
     ⍝ Parameter Interpretation
     :For Parm :In Parms
         :Select #.Uppercase↑Parm
         :Case 'CAPTION'                           ⍝ ('Caption' 'Caption')
             Caption←∊1↓Parm
         :Case 'TEXT'                              ⍝ ('Text' 'Text')
             :If 2<≡Text←1↓Parm
                 Text←↑Text
             :EndIf
             Text←¯2↓∊Text,¨⊂⊂''
         :Case 'STYLE'
             :Select #.Uppercase∊1↓Parm
             :Case 'MSG'                           ⍝ ('Style' 'Msg')
             :CaseList 'HAND' 'ERROR' 'STOP'
                 Style+←#.Win.MB_ICONHAND          ⍝ ('Style' 'Error')
                 DefBtn←#.Win.MB_OKCANCEL
             :CaseList 'QUESTION' 'QUERY'
                 Style+←#.Win.MB_ICONQUESTION      ⍝ ('Style' 'Query')
                 DefBtn←#.Win.MB_YESNO
             :CaseList 'EXCLAMATION' 'WARN'
                 Style+←#.Win.MB_ICONEXCLAMATION   ⍝ ('Style' 'Warn')
                 DefBtn←#.Win.MB_OKCANCEL
             :CaseList 'ASTERISK' 'INFORMATION' 'INFO'
                 Style+←#.Win.MB_ICONASTERISK      ⍝ ('Style' 'Info')
             :Else
                 Style+←#.Win.MB_USERICON
                 Icon←∊1↓Parm
             :EndSelect
         :Case 'BTNS'
             DefBtnFlag←0
             :Select #.Uppercase∊1↓Parm
             :Case 'OK'                            ⍝ ('Btns' 'OK')
                 Style+←#.Win.MB_OK
             :Case 'OKCANCEL'                      ⍝ ('Btns' ('OK' 'Cancel'))
                 Style+←#.Win.MB_OKCANCEL
             :Case 'ABORTRETRYIGNORE'              ⍝ ('Btns' ('Abort' 'Retry' 'Ignore'))
                 Style+←#.Win.MB_ABORTRETRYIGNORE
             :Case 'YESNOCANCEL'                   ⍝ ('Btns' ('Yes' 'No' 'Cancel'))
                 Style+←#.Win.MB_YESNOCANCEL
             :Case 'YESNO'                         ⍝ ('Btns' ('Yes' 'No'))
                 Style+←#.Win.MB_YESNO
             :Case 'RETRYCANCEL'                   ⍝ ('Btns' ('Retry' 'Cancel'))
                 Style+←#.Win.MB_RETRYCANCEL
             :EndSelect
         :Case 'HELPBUTTON'
             :If ServiceFlag
             :Else
                 :Select ↑1↓Parm
                 :Case 1                           ⍝ ('HelpButton' 1)
                     Style+←#.Win.MB_HELP
                 :EndSelect
             :EndIf
         :Case 'DEFAULT'
             :Select ↑1↓Parm
             :Case 1                               ⍝ ('Default' 1)
                 Style+←#.Win.MB_DEFBUTTON1
             :Case 2                               ⍝ ('Default' 2)
                 Style+←#.Win.MB_DEFBUTTON2
             :Case 3                               ⍝ ('Default' 3)
                 Style+←#.Win.MB_DEFBUTTON3
             :Case 4                               ⍝ ('Default' 4)
                 Style+←#.Win.MB_DEFBUTTON4
             :EndSelect
         :Case 'JUSTIFY'
             :Select #.Uppercase∊1↓Parm
             :Case 'RIGHT'                         ⍝ ('Justify' 'Right')
                 Style+←#.Win.MB_RIGHT
             :EndSelect
         :Case 'EVENT'                             ⍝ ('Event'('MsgBtn1' 'onBtn')('MsgBtn2' 'onBtn')('MsgBtn3' 'onBtn')('Help' 'onBtn'))
             :If 3>≡Parm←1↓Parm
                 Parm←⊂Parm
             :EndIf
             Event←Event,Parm
         :Case 'ONTOP'
             :If ServiceFlag
                 :Select ↑1↓Parm
                 :Case 0                           ⍝ ('OnTop' 0)
                     Style+←#.Win.MB_DEFAULT_DESKTOP_ONLY
                 :EndSelect
             :Else
                 :Select ↑1↓Parm
                 :Case 0                           ⍝ ('OnTop' 0)
                     Style+←#.Win.MB_TASKMODAL
                 :Case 1                           ⍝ ('OnTop' 1)
                     Style+←#.Win.MB_SYSTEMMODAL
                 :EndSelect
             :EndIf
         :EndSelect
     :EndFor
     :If DefBtnFlag
         Style+←DefBtn
     :EndIf
     ⍝ Create Hidden Shadow Window Object and Rerieve Handles
     BaseObject←⎕CS↑⎕NSI
     :If 0=⎕NC Object
         Object ⎕WC'Form'('Visible' 0)((⊂'Event'),Event)
         ⎕CS Object
         hWindow←⎕WG'Handle'
         ⎕CS'##'
         :If (⊂'Handle')∊⎕WG'PropList'
             hOwner←⎕WG'Handle'
         :Else
             hOwner←0
         :EndIf
         ⎕CS BaseObject
         MsgDCM1←#.Win.Message.RegisterWindow'DyalogCustomMessage1'
     ⍝ Machine Code Generation
         Code←''                          ⍝  ;==================================================================
         pHlpInfo←↑⍴Code                  ⍝  HelpInfo           STRUCT
         Code,←CodeWord 28                ⍝  cbSize             UINT           SIZEOF HELPINFO
         Code,←CodeWord 0                 ⍝  iContextType       SINT
         Code,←CodeWord 0                 ⍝  iCtrlId            SINT
         Code,←CodeWord 0                 ⍝  hItemHandle        HANDLE
         Code,←CodeWord 0                 ⍝  dwContextId        DWORD
         Code,←CodeWord 0 0               ⍝  MousePos           POINT
                                               ⍝  HelpInfo           ENDS
         pBoxText←↑⍴Code                  ⍝  ;==================================================================
         Code,←Text,↑⎕AV                  ⍝  BoxText            CHAR           'BoxText',0
         pCapText←↑⍴Code                  ⍝  ;==================================================================
         Code,←Caption,↑⎕AV               ⍝  CaptionText        CHAR           'CaptionText',0
         pIcoText←↑⍴Code                  ⍝  ;==================================================================
         Code,←Icon,↑⎕AV                  ⍝  IconText           CHAR           'IconText',0
                                               ⍝  ;==================================================================
         pMBParms←↑⍴Code                  ⍝  MsgBoxParams       STRUCT
         Code,←CodeWord 40                ⍝  cbSize             UINT           SIZEOF MSGBOXPARAMS
         Code,←CodeWord hOwner            ⍝  hwndOwner          HWND           hOwner
         Code,←CodeWord 0                 ⍝  hInstance          HINSTANCE      NULL
         oBoxText←↑⍴Code
         Code,←CodeWord 0                 ⍝  lpszText           LPCTSTR        OFFSET BoxText
         oCapText←↑⍴Code
         Code,←CodeWord 0                 ⍝  lpszCaption        LPCTSTR        OFFSET CaptionText
         pdwStyle←↑⍴Code
         Code,←CodeWord Style             ⍝  dwStyle            DWORD          Style
         oIcoText←↑⍴Code
         Code,←CodeWord 0                 ⍝  lpszIcon           LPCTSTR        OFFSET IconText
         oHlpInfo←↑⍴Code
         Code,←CodeWord 0                 ⍝  dwContextHelpId    LPDWORD        OFFSET HelpInfo
         oMBCBack←↑⍴Code
         Code,←CodeWord 0                 ⍝  lpfnMsgBoxCallback MSGBOXCALLBACK OFFSET MsgBoxCallback
         Code,←CodeWord 0                 ⍝  dwLanguageId       DWORD          LANG_NEUTRAL
                                               ⍝  MsgBoxParams       ENDS
                                               ⍝  ;==================================================================
         pMBCBack←↑⍴Code                  ⍝  MsgBoxCallback PROC,lpHelpInfo:LPHELPINFO
         Code,←CodeHex'6A' '00'           ⍝      PUSH   0             ;wParam=ButtonID
         Code,←CodeHex'EB' '48'           ⍝      JMP    L1
                                               ⍝  ;==================================================================
         pThread←↑⍴Code                   ⍝  Thread PROC,lpParameter:LPVOID
         Code,←CodeHex'68' '00000039'     ⍝      PUSH   OFFSET MsgBoxParams
         oMBParms←¯4+↑⍴Code
         Code,←CodeHex'E8' '00000000'     ⍝      CALL   MessageBoxIndirectA
         oMsgBoxI←¯4+↑⍴Code               ⍝  ;------------------------------------------------------------------
         Code,←CodeHex'8A' '1D' '0000004D'⍝      MOV    BL,BYTE PTR MsgBoxParams.dwStyle
         odwStyle←¯4+↑⍴Code
         Code,←CodeHex'80' 'E3' '0F'      ⍝      AND    BL,MB_TYPEMASK
         Code,←CodeHex'80' 'FB' '02'      ⍝      CMP    BL,MB_ABORTRETRYIGNORE
         Code,←CodeHex'75' '04'           ⍝      JNE    @1
         Code,←CodeHex'2C' '02'           ⍝      SUB    AL,2
         Code,←CodeHex'EB' '2B'           ⍝      JMP    @3
         Code,←CodeHex'80' 'FB' '04'      ⍝  @1: CMP    BL,MB_YESNO
         Code,←CodeHex'74' '05'           ⍝      JE     @10
         Code,←CodeHex'80' 'FB' '03'      ⍝      CMP    BL,MB_YESNOCANCEL
         Code,←CodeHex'75' '14'           ⍝      JNE    @2
         Code,←CodeHex'3C' '06'           ⍝  @10:CMP    AL,IDYES
         Code,←CodeHex'75' '04'           ⍝      JNE    @11
         Code,←CodeHex'B0' '01'           ⍝      MOV    AL,1
         Code,←CodeHex'EB' '19'           ⍝      JMP    @3
         Code,←CodeHex'3C' '07'           ⍝  @11:CMP    AL,IDNO
         Code,←CodeHex'75' '04'           ⍝      JNE    @12
         Code,←CodeHex'B0' '02'           ⍝      MOV    AL,2
         Code,←CodeHex'EB' '11'           ⍝      JMP    @3
         Code,←CodeHex'B0' '03'           ⍝  @12:MOV    AL,3
         Code,←CodeHex'EB' '0D'           ⍝      JMP    @3
         Code,←CodeHex'80' 'FB' '05'      ⍝  @2: CMP    BL,MB_RETRYCANCEL
         Code,←CodeHex'75' '08'           ⍝      JNE    @3
         Code,←CodeHex'3C' '04'           ⍝      CMP    AL,IDRETRY
         Code,←CodeHex'75' '04'           ⍝      JNE    @3
         Code,←CodeHex'B0' '01'           ⍝      MOV    AL,1
         Code,←CodeHex'EB' '00'           ⍝      JMP    @3
                                               ⍝  ;------------------------------------------------------------------
         Code,←CodeHex'50'                ⍝  @3: PUSH   EAX                    ;wParam=ButtonID
         Code,←CodeHex'68' '00000000'     ⍝  L1::PUSH   hThread                ;lParam=hThread
         ohThread←¯4+↑⍴Code
         Code,←CodeHex'68'                ⍝      PUSH   MsgDCM1
         Code,←CodeWord MsgDCM1           ⍝
         Code,←CodeHex'68'                ⍝      PUSH   hWindow
         Code,←CodeWord hWindow           ⍝
         Code,←CodeHex'E8' '00000000'     ⍝      CALL   PostMessageA
         oMsgPost←¯4+↑⍴Code               ⍝  ;==================================================================
         Code,←CodeHex'B8' '00000000'     ⍝      MOV    EAX,OFFSET Code
         oCode←¯4+↑⍴Code
         Code,←CodeHex'C2' '0004'         ⍝      RET    4
                                               ⍝  Thread ENDP
                                               ⍝  MsgBoxCallback ENDP
                                               ⍝  ;==================================================================
     ⍝ Machine Code Linking and Adress Resolution
         :If #.Win.INVALID_HANDLE_VALUE≠hModule←#.Win.Library.GetHandle'USER32'
         :AndIf #.Win.NULL≠pMsgBoxI←#.Win.Library.GetProcAddress hModule'MessageBoxIndirectA'
         :AndIf #.Win.NULL≠pMsgPost←#.Win.Library.GetProcAddress hModule'PostMessageA'
         :AndIf #.Win.NULL≠hMemProc←#.Win.Mem.Alloc↑⍴Code
             Code[oBoxText+⍳4]←CodeWord hMemProc+pBoxText
             Code[oCapText+⍳4]←CodeWord hMemProc+pCapText
             Code[oIcoText+⍳4]←CodeWord hMemProc+pIcoText
             Code[oHlpInfo+⍳4]←CodeWord hMemProc+pHlpInfo
             Code[oMBCBack+⍳4]←CodeWord hMemProc+pMBCBack
             Code[oMBParms+⍳4]←CodeWord hMemProc+pMBParms
             Code[oMsgBoxI+⍳4]←CodeWord pMsgBoxI-hMemProc+4+oMsgBoxI
             Code[oMsgPost+⍳4]←CodeWord pMsgPost-hMemProc+4+oMsgPost
             Code[oCode+⍳4]←CodeWord hMemProc
             Code[odwStyle+⍳4]←CodeWord hMemProc+pdwStyle
             Code #.Win.Mem.Write hMemProc
     ⍝ Start Thread Execution
             hThread ThreadId←#.Win.Proc.CreateThread hMemProc+pThread
             hThread #.Win.Mem.Write hMemProc+ohThread
         :EndIf
     :EndIf
 :Else
     ⍝ Entry for DyalogCustomMessage1 Event Handling
     Object Event hThread Button←4↑Parms
     :Select Button
     :Case 0
         ⎕NQ Object'Help' 0 0
     :Case 1
         ⎕NQ Object'MsgBtn1'
         ⎕NQ Object'Close'
     :Case 2
         ⎕NQ Object'MsgBtn2'
         ⎕NQ Object'Close'
     :Case 3
         ⎕NQ Object'MsgBtn3'
         ⎕NQ Object'Close'
     :EndSelect
     :If #.Win.WAIT_OBJECT_0=#.Win.Proc.WaitForSingleObject hThread 0
     :AndIf #.Win.STATUS_PENDING<hMemProc←#.Win.Proc.GetExitCodeThread hThread
     :AndIf 0=#.Win.Proc.Close hThread
         #.Win.Mem.Free hMemProc
     :EndIf
 :EndIf
∇

∇ hWnds←EnumChilds hWndParent;hWnd
     ⍝ Enumerate the child windows that belong to the specified parent window by retrieving the handles to the child windows
     ⍝
     ⍝ hWndParent = Handle to parent window
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWnds←⍬
 :If ##.NULL≠hWnd←##.GetWindow hWndParent ##.GW_CHILD
     :Repeat
         hWnds←hWnds,hWnd
     :Until ##.NULL=hWnd←##.GetWindow hWnd ##.GW_HWNDNEXT
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Retrn←EnumProps hWnd;CodeHex;CodeWord;HdCount;StCount;MaxHandle;MaxString;PropEnumProc;sPropEnumProc;rHdlCntA;rHandles;rHdlCntB;rStrCntA;rStrings;rStrCntB;oHdCount;oStCount;oHandles;oStrings;pPropEnumProc;Strings;Handles
     ⍝ Enumerate all entries in the property list of a window
     ⍝
     ⍝  hWnd      = handle to window
     ⍝
     ⍝  Retrn¨[1] = String
     ⍝  Retrn¨[2] = Handle
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 CodeHex←{1<≡⍵:∊∇¨⍵ ⋄ ⌽##.TxtHex ⍵}
 CodeWord←{0<≡⍵:∊∇¨⍵ ⋄ 4 ##.TxtInt ⍵}
     ⍝ Parameters
 HdCount←0
 StCount←0
 MaxHandle←128
 MaxString←2048
     ⍝ Machine Code Generation
 PropEnumProc←''                     ⍝ ;=====================================================
 PropEnumProc,←CodeHex'55'           ⍝ 00000000  55            PUSH   EBP
 PropEnumProc,←CodeHex'8B' 'EC'      ⍝ 00000001  8B EC         MOV    EBP,ESP
 PropEnumProc,←CodeHex'51'           ⍝ 00000003  51            PUSH   ECX
 PropEnumProc,←CodeHex'56'           ⍝ 00000004  56            PUSH   ESI
 PropEnumProc,←CodeHex'57'           ⍝ 00000005  57            PUSH   EDI
 PropEnumProc,←CodeHex'2B' 'C0'      ⍝ 00000006  2B C0         SUB    EAX,EAX
 PropEnumProc,←CodeHex'8B' '0D'      ⍝ 00000008  8B 0D         MOV    ECX,HdCount
 rHdlCntA←↑⍴PropEnumProc             ⍝
 PropEnumProc,←CodeWord 0            ⍝ 0000000A  00000000 R
 PropEnumProc,←CodeHex'81' 'F9'      ⍝ 0000000E  81 F9         CMP    ECX,MaxHandle
 PropEnumProc,←CodeWord MaxHandle    ⍝ 00000010  MaxHandle
 PropEnumProc,←CodeHex'73' '38'      ⍝ 00000014  73 38         JAE    @0
 PropEnumProc,←CodeHex'8B' '45' '10' ⍝ 00000016  8B 45 10      MOV    EAX,hData
 PropEnumProc,←CodeHex'89' '04' '8D' ⍝ 00000019  89 04 8D      MOV    Handles[ECX*4],EAX
 rHandles←↑⍴PropEnumProc             ⍝
 PropEnumProc,←CodeWord 0            ⍝ 0000001C  00000000 R
 PropEnumProc,←CodeHex'41'           ⍝ 00000020  41            INC    ECX
 PropEnumProc,←CodeHex'89' '0D'      ⍝ 00000021  89 0D         MOV    HdCount,ECX
 rHdlCntB←↑⍴PropEnumProc             ⍝
 PropEnumProc,←CodeWord 0            ⍝ 00000023  00000000 R ;================================
 PropEnumProc,←CodeHex'8B' '75' '0C' ⍝ 00000027  8B 75 0C      MOV    ESI,lpszString
 PropEnumProc,←CodeHex'8B' '0D'      ⍝ 0000002A  8B 0D         MOV    ECX,StCount
 rStrCntA←↑⍴PropEnumProc             ⍝
 PropEnumProc,←CodeWord 0            ⍝ 0000002C  00000000 R
 PropEnumProc,←CodeHex'8D' 'B9'      ⍝ 00000030  8D B9         LEA    EDI,Strings[ECX]
 rStrings←↑⍴PropEnumProc             ⍝
 PropEnumProc,←CodeWord 0            ⍝ 00000032  00000000 R
 PropEnumProc,←CodeHex'2B' 'C0'      ⍝ 00000036  2B C0      @1:SUB    EAX,EAX
 PropEnumProc,←CodeHex'81' 'F9'      ⍝ 00000038  81 F9         CMP    ECX,MaxString
 PropEnumProc,←CodeWord MaxString    ⍝ 0000003A  MaxString
 PropEnumProc,←CodeHex'73' '0E'      ⍝ 0000003E  73 0E         JAE    @0
 PropEnumProc,←CodeHex'AC'           ⍝ 00000040  AC            LODSB
 PropEnumProc,←CodeHex'AA'           ⍝ 00000041  AA            STOSB
 PropEnumProc,←CodeHex'41'           ⍝ 00000042  41            INC    ECX
 PropEnumProc,←CodeHex'84' 'C0'      ⍝ 00000043  84 C0         TEST   AL,AL
 PropEnumProc,←CodeHex'75' 'EF'      ⍝ 00000045  75 EF         JNE    @1
 PropEnumProc,←CodeHex'89' '0D'      ⍝ 00000047  89 0D         MOV    StCount,ECX
 rStrCntB←↑⍴PropEnumProc             ⍝
 PropEnumProc,←CodeWord 0            ⍝ 00000049  00000000 R ;================================
 PropEnumProc,←CodeHex'40'           ⍝ 0000004D  40            INC    EAX
 PropEnumProc,←CodeHex'5F'           ⍝ 0000004E  5F         @0:POP    EDI
 PropEnumProc,←CodeHex'5E'           ⍝ 0000004F  5E            POP    ESI
 PropEnumProc,←CodeHex'59'           ⍝ 00000050  59            POP    ECX
 PropEnumProc,←CodeHex'C9'           ⍝ 00000051  C9            LEAVE
 PropEnumProc,←CodeHex'C2' '000C'    ⍝ 00000052  C2 000C       RET    0000Ch
 PropEnumProc,←CodeHex'00' '00' '00' ⍝ 00000055  00 00 00      ALIGN  4
 oHdCount←↑⍴PropEnumProc             ⍝ ;=====================================================
 PropEnumProc,←CodeWord HdCount      ⍝ 00000058 00000000    HdCount   DWORD 0
 oStCount←↑⍴PropEnumProc             ⍝
 PropEnumProc,←CodeWord StCount      ⍝ 0000005C 00000000    StCount   DWORD 0
 oHandles←↑⍴PropEnumProc             ⍝
 PropEnumProc,←(4×MaxHandle)⍴↑⎕AV    ⍝ 00000060 MaxHandle[0]Handles   DWORD MaxHandle DUP (0)
 oStrings←↑⍴PropEnumProc             ⍝
 PropEnumProc,←MaxString⍴↑⎕AV        ⍝ 00000260 MaxString[0]Strings   BYTE  MaxString DUP (0)
 sPropEnumProc←↑⍴PropEnumProc        ⍝ ;=====================================================
     ⍝ Machine Code Linking and Adress Resolution
 :If ##.NULL≠pPropEnumProc←##.Mem.Alloc sPropEnumProc
     PropEnumProc[rHdlCntA+⍳4]←CodeWord pPropEnumProc+oHdCount
     PropEnumProc[rHandles+⍳4]←CodeWord pPropEnumProc+oHandles
     PropEnumProc[rHdlCntB+⍳4]←CodeWord pPropEnumProc+oHdCount
     PropEnumProc[rStrCntA+⍳4]←CodeWord pPropEnumProc+oStCount
     PropEnumProc[rStrings+⍳4]←CodeWord pPropEnumProc+oStrings
     PropEnumProc[rStrCntB+⍳4]←CodeWord pPropEnumProc+oStCount
     PropEnumProc ##.Mem.Write pPropEnumProc
     ⍝ Execute EnumProps
 :AndIf ##.TRUE=##.EnumProps hWnd pPropEnumProc
     ⍝ Read allocation and free memory
     PropEnumProc←sPropEnumProc ##.Mem.Read pPropEnumProc
     ##.Mem.Free pPropEnumProc
     ⍝ Interpret result
     StCount←4 ##.IntTxt PropEnumProc[oStCount+⍳4]
     Strings←{(⍵≠↑⎕AV)⊂⍵}StCount↑oStrings↓PropEnumProc
     HdCount←4 ##.IntTxt PropEnumProc[oHdCount+⍳4]
     Handles←4 ##.IntTxt(4×HdCount)↑oHandles↓PropEnumProc
 :AndIf (⍴Strings)≡⍴Handles
     Retrn←⊂[1]⊃Strings Handles
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     Retrn←0⍴⊂'' 0
 :EndIf
∇

∇ hWnd←Find Parms;ClassName;WindowName
     ⍝ Retrieve a handle to the top-level window whose class name and window name match the specified strings, does not search child windows
     ⍝
     ⍝ Parms[1] = ClassName
     ⍝ Parms[1] = WindowName (opt.)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 2>≡Parms
     ClassName←,Parms
     WindowName←''
 :Else
     ClassName WindowName←2↑Parms,⊂''
 :EndIf
 :Select ×∘↑∘⍴¨ClassName WindowName
 :Case 1 1
     hWnd←##.FindWindow ClassName WindowName
 :Case 0 1
     hWnd←##.FindWindowIT 0 WindowName
 :Case 1 0
     hWnd←##.FindWindowTI ClassName 0
 :Case 0 0
     hWnd←##.FindWindowII 0 0
 :EndSelect
 :If 0≠hWnd
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
     hWnd←##.INVALID_HANDLE_VALUE
 :EndIf
∇

∇ hWnd←Get Parms;hWnd;Cmd
     ⍝ Retrieve a handle to a window that has the specified relationship (Z order or owner) to the specified window.
     ⍝
     ⍝ Parms[1] = hWnd Handle retrieved window
     ⍝ Parms[2] = Cmd  Relationship (#.Win.GW_HWNDFIRST #.Win.GW_HWNDLAST #.Win.GW_HWNDNEXT #.Win.GW_HWNDPREV #.Win.GW_OWNER #.Win.GW_CHILD or #.Win.GW_ENABLEDPOPUP)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWnd Cmd←2↑Parms
 :If ##.NULL≠hWnd←##.GetWindow hWnd Cmd
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ ClassName←GetClassName hWnd
     ⍝ Retrieve the name of the class to which the specified window belongs
     ⍝
     ⍝ hWnd = Handle to window
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ⍬≡⍴hWnd
     :If ×↑⍴ClassName←↑↑/##.GetClassName hWnd 256 256
         #.RCode←##.GetLastError
     :Else
         #.RCode←##.ERROR_SUCCESS
     :EndIf
 :ElseIf 0∊⍴hWnd
     ClassName←0⍴⊂''
     #.RCode←##.ERROR_SUCCESS
 :Else
     :If 0∊↑∘⍴¨ClassName←↑¨↑/¨##.GetClassName¨hWnd,¨⊂256 256
         #.RCode←##.GetLastError
     :Else
         #.RCode←##.ERROR_SUCCESS
     :EndIf
 :EndIf
∇

∇ hWnd←GetDesktop
     ⍝ Return a handle to the desktop window, the desktop window covers the entire screen
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWnd←##.GetDesktopWindow
∇

∇ hWnd←GetForeground
     ⍝ Return a handle to the foreground window, the window with which the user is currently working
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWnd←##.GetForegroundWindow
∇

∇ ItemBCol←GetItemBCol oObject;ColorCode;ObjectName;sItemBCol
     ⍝ Gets ItemColors in a ListView- or TreeView-Object
     ⍝ DO NOT USE TOGETHER WITH "SetItemFCol" or "SetItemFBCol"
     ⍝
     ⍝ ItemBCol = (R G B)(R G B)... all ∊ 0..255
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ColorCode←{((⍴⍵)⍴1 1 1 0)⊂256|#.Win.IntTxt ⍵}
 :Hold '#.Win.Window.ItemCol'
     :If 0∊⍴oObject
         ObjectName←↑⎕NSI
     :ElseIf ×↑⍴oObject
     :AndIf '#.'≢2↑oObject
         ObjectName←(↑⎕NSI),'.',oObject
     :Else
         ObjectName←⍕oObject
     :EndIf
     :If 9=⎕NC ObjectName
         :With ObjectName
             :Select ⎕WG'Type'
             :CaseList 'ListView' 'TreeView'
                 :If 2∧.=⎕NC⊃'hOldWinProc' 'hNewWinProc' 'pItemBCol'
                 :AndIf 0<sItemBCol←(#.Win.Mem.Size hNewWinProc)-pItemBCol
                     ItemBCol←ColorCode sItemBCol #.Win.Mem.Read hNewWinProc+pItemBCol
                 :Else
                     ItemBCol←0⍴⊂0 0 0
                 :EndIf
             :Else
                 ItemBCol←0⍴⊂0 0 0
             :EndSelect
         :EndWith
     :Else
         ItemBCol←0⍴⊂0 0 0
     :EndIf
 :EndHold
∇

∇ ItemFBCol←GetItemFBCol oObject;ColorCode;ObjectName;sItemFBCol
     ⍝ Gets ItemColors in a ListView- or TreeView-Object
     ⍝ DO NOT USE TOGETHER WITH "SetItemFCol" or "SetItemBCol"
     ⍝
     ⍝ ItemFBCol = (RF GF BF RB GB BB)(RF GF BF RB GB BB)... all ∊ 0..255
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ColorCode←{((⍴⍵)⍴1 1 1 1 1 1 0)⊂⍵}∘{((⍴⍵)⍴1 1 1 0 1 1 1 1)/256|#.Win.IntTxt ⍵}
 :Hold '#.Win.Window.ItemCol'
     :If 0∊⍴oObject
         ObjectName←↑⎕NSI
     :ElseIf ×↑⍴oObject
     :AndIf '#.'≢2↑oObject
         ObjectName←(↑⎕NSI),'.',oObject
     :Else
         ObjectName←⍕oObject
     :EndIf
     :If 9=⎕NC ObjectName
         :With ObjectName
             :Select ⎕WG'Type'
             :CaseList 'ListView' 'TreeView'
                 :If 2∧.=⎕NC⊃'hOldWinProc' 'hNewWinProc' 'pItemFBCol'
                 :AndIf 0<sItemFBCol←(#.Win.Mem.Size hNewWinProc)-pItemFBCol
                     ItemFBCol←ColorCode sItemFBCol #.Win.Mem.Read hNewWinProc+pItemFBCol
                 :Else
                     ItemFBCol←0⍴⊂0 0 0 0 0 0
                 :EndIf
             :Else
                 ItemFBCol←0⍴⊂0 0 0 0 0 0
             :EndSelect
         :EndWith
     :Else
         ItemFBCol←0⍴⊂0 0 0 0 0 0
     :EndIf
 :EndHold
∇

∇ ItemFCol←GetItemFCol oObject;ColorCode;ObjectName;sItemFCol
     ⍝ Gets ItemColors in a ListView- or TreeView-Object
     ⍝ DO NOT USE TOGETHER WITH "SetItemBCol" or "SetItemFBCol"
     ⍝
     ⍝ ItemFCol = (R G B)(R G B)... all ∊ 0..255
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 ColorCode←{((⍴⍵)⍴1 1 1 0)⊂256|#.Win.IntTxt ⍵}
 :Hold '#.Win.Window.ItemCol'
     :If 0∊⍴oObject
         ObjectName←↑⎕NSI
     :ElseIf ×↑⍴oObject
     :AndIf '#.'≢2↑oObject
         ObjectName←(↑⎕NSI),'.',oObject
     :Else
         ObjectName←⍕oObject
     :EndIf
     :If 9=⎕NC ObjectName
         :With ObjectName
             :Select ⎕WG'Type'
             :CaseList 'ListView' 'TreeView'
                 :If 2∧.=⎕NC⊃'hOldWinProc' 'hNewWinProc' 'pItemFCol'
                 :AndIf 0<sItemFCol←(#.Win.Mem.Size hNewWinProc)-pItemFCol
                     ItemFCol←ColorCode sItemFCol #.Win.Mem.Read hNewWinProc+pItemFCol
                 :Else
                     ItemFCol←0⍴⊂0 0 0
                 :EndIf
             :Else
                 ItemFCol←0⍴⊂0 0 0
             :EndSelect
         :EndWith
     :Else
         ItemFCol←0⍴⊂0 0 0
     :EndIf
 :EndHold
∇

∇ Long←GetLong Parms;hWnd;Index
     ⍝ Retrieve information about the specified window
     ⍝
     ⍝  hWnd  handle to window
     ⍝  Index offset of value to retrieve (#.Win.GWL_WNDPROC #.Win.GWL_HINSTANCE #.Win.GWL_HWNDPARENT #.Win.GWL_STYLE #.Win.GWL_EXSTYLE #.Win.GWL_USERDATA #.Win.GWL_ID)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWnd Index←2↑Parms
 :If ##.ZERO≠Long←##.GetWindowLong hWnd Index
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ Long←GetLongW Parms;hWnd;Index
     ⍝ Retrieve information about the specified window in Unicode mode
     ⍝
     ⍝  hWnd  handle to window
     ⍝  Index offset of value to retrieve (#.Win.GWL_WNDPROC #.Win.GWL_HINSTANCE #.Win.GWL_HWNDPARENT #.Win.GWL_STYLE #.Win.GWL_EXSTYLE #.Win.GWL_USERDATA #.Win.GWL_ID)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWnd Index←2↑Parms
 :If ##.ZERO≠Long←##.GetWindowLongW hWnd Index
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ ModuleFileName←GetModuleFileName hWnd
     ⍝ Retrieve full path and file name of the module associated with the specified window handle(s)
     ⍝
     ⍝ hWnd = Handle to window
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ⍬≡⍴hWnd
     :If ×↑⍴ModuleFileName←↑↑/##.GetWindowModuleFileName hWnd ##.MAX_PATH ##.MAX_PATH
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :ElseIf 0∊⍴hWnd
     ModuleFileName←0⍴⊂''
     #.RCode←##.ERROR_SUCCESS
 :Else
     :If 0∊↑∘⍴¨ModuleFileName←↑¨↑/¨##.GetWindowModuleFileName¨hWnd,¨⊂##.MAX_PATH ##.MAX_PATH
         #.RCode←##.GetLastError
     :Else
         #.RCode←##.ERROR_SUCCESS
     :EndIf
 :EndIf
∇

∇ hWndParent←GetParent hWnd
     ⍝ Retrieve a handle to the specified child window's parent window
     ⍝
     ⍝ hWnd = Handle to child window
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.NULL≠hWndParent←##.GetParent hWnd
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ String←GetText hWnd
     ⍝ Copy the text of the specified window's title bar (if it has one) into a buffer.
     ⍝ If the specified window is a control, the text of the control is copied
     ⍝
     ⍝ hWnd = Handle to window
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ⍬≡⍴hWnd
     :If ×↑⍴String←↑↑/##.GetWindowText hWnd 16384 16384
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :ElseIf 0∊⍴hWnd
     String←0⍴⊂''
     #.RCode←##.ERROR_SUCCESS
 :Else
     :If 0∊↑∘⍴¨String←↑¨↑/¨##.GetWindowText¨hWnd,¨⊂16384 16384
         #.RCode←##.GetLastError
     :Else
         #.RCode←##.ERROR_SUCCESS
     :EndIf
 :EndIf
∇

∇ String←GetTextW hWnd;Length
     ⍝ Copy the text of the specified window's title bar (if it has one) into a buffer in Unicode mode
     ⍝ If the specified window is a control, the text of the control is copied
     ⍝
     ⍝ hWnd = Handle to window
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ⍬≡⍴hWnd
     Length String←##.GetWindowTextW hWnd 32768 16384
     String←(2×Length)↑String
     :If ×Length
         #.RCode←##.ERROR_SUCCESS
     :Else
         #.RCode←##.GetLastError
     :EndIf
 :ElseIf 0∊⍴hWnd
     String←0⍴⊂''
     #.RCode←##.ERROR_SUCCESS
 :Else
     Length String←⊂[1]⊃##.GetWindowTextW¨hWnd,¨⊂32768 16384
     String←(2×Length)↑¨String
     :If 0∊Length
         #.RCode←##.GetLastError
     :Else
         #.RCode←##.ERROR_SUCCESS
     :EndIf
 :EndIf
∇

∇ Retrn←GetThreadProcessId hWnd;ThreadId;ProcessId
     ⍝ Retrieve the identifier of the thread and the process that created the specified window
     ⍝
     ⍝ hWnd     = Handle to window
     ⍝ Retrn[1] = ThreadId
     ⍝ Retrn[2] = ProcessId
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If 0≠↑ThreadId ProcessId←##.GetWindowThreadProcessId hWnd 0
     #.RCode←##.ERROR_SUCCESS
     Retrn←ThreadId ProcessId
 :Else
     #.RCode←##.GetLastError
     Retrn←0 0
 :EndIf
∇

∇ ValidFlag←IsUnicode hWnd
     ⍝ Determine whether the specified window is a native Unicode window
     ⍝
     ⍝  hWnd  handle to window
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 ValidFlag←##.IsWindowUnicode hWnd
∇

∇ {VOID}←SetForeground hWnd
     ⍝ Put the thread that created the specified window into the foreground and activate the window
     ⍝
     ⍝ hWnd = Handle to window to bring to foreground
     ⍝ VOID = 1=ok 0=Fail
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If VOID←##.SetForegroundWindow hWnd
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ oObject SetItemBCol ItemBCol;CodeHex;CodeOffset;CodeColor;ColorCode;GetParentObjectName;TrimLeftRight;ObjectName;ObjectType;ChangedFlag;hWindow;hWindowParent;sItemBCol;Code;ohWinProcOld;ohWindow;oTableSize;opItemBCol;EventList;Index;ActionCode;CallbackFunction
     ⍝ Sets ItemColors in a ListView- or TreeView-Object
     ⍝ DO NOT USE TOGETHER WITH "SetItemFCol" or "SetItemFBCol"
     ⍝ COL_BGDEF←255 255 254 ⍝ Default background color
     ⍝
     ⍝ ItemBCol = (R G B)(R G B)... all ∊ 0..255
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 #.Win.Init
 CodeHex←{1<≡⍵:∊∇¨⍵ ⋄ ⌽#.Win.TxtHex ⍵}
 CodeOffset←{4 #.Win.TxtInt ⍵}
 CodeColor←{∊1 #.Win.TxtInt¨1 1 1 0∘\¨⍵}
 ColorCode←{((⍴⍵)⍴1 1 1 0)⊂256|#.Win.IntTxt ⍵}
 GetParentObjectName←{(-(⌽⍵)⍳'.')↓⍵}
 TrimLeftRight←{({(∨\⍵)∧⌽∨\⌽⍵}' '≠⍵)/⍵}
 :Hold '#.Win.Window.ItemCol'
     :If 0∊⍴oObject
         ObjectName←↑⎕NSI
     :ElseIf ×↑⍴oObject
     :AndIf '#.'≢2↑oObject
         ObjectName←(↑⎕NSI),'.',oObject
     :Else
         ObjectName←⍕oObject
     :EndIf
     :If 9=⎕NC ObjectName
         :With ObjectName
             :Select ObjectType←⎕WG'Type'
             :CaseList 'ListView' 'TreeView'
                 :If ChangedFlag←0≠hWindowParent←#.Win.Window.GetParent hWindow←⎕WG'Handle'
                     :If 2∧.=⎕NC⊃'hOldWinProc' 'hNewWinProc' 'pItemBCol'
                     :AndIf 0<sItemBCol←(#.Win.Mem.Size hNewWinProc)-pItemBCol
                     :AndIf ChangedFlag←ItemBCol≢ColorCode sItemBCol #.Win.Mem.Read hNewWinProc+pItemBCol
                     :AndIf #.Win.ZERO≠hOldWinProc #.Win.Window.SetLong hWindowParent #.Win.GWL_WNDPROC
                         #.Win.Mem.Free hNewWinProc
                         ⎕EX⊃'hOldWinProc' 'hNewWinProc' 'pItemBCol'
                     :EndIf
                 :AndIf ChangedFlag
                 :AndIf ×↑⍴ItemBCol
                 :AndIf 2=≡ItemBCol
                 :AndIf 3∧.=↑∘⍴¨ItemBCol
                     :Select ObjectType
                     :Case 'ListView'                           ⍝ LVWindowProc PROC,hwnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
                         Code←''                                ⍝ ;==================================================================
                         Code,←CodeHex'55'                      ⍝     PUSH   EBP
                         Code,←CodeHex'8B' 'EC'                 ⍝     MOV    EBP,ESP
                         Code,←CodeHex'FF' '75' '14'            ⍝     PUSH   lParam
                         Code,←CodeHex'FF' '75' '10'            ⍝     PUSH   wParam
                         Code,←CodeHex'FF' '75' '0C'            ⍝     PUSH   uMsg
                         Code,←CodeHex'FF' '75' '08'            ⍝     PUSH   hwnd
                         Code,←CodeHex'E8' '00000000'           ⍝     CALL   hWinProcOld
                         ohWinProcOld←¯4+↑⍴Code                 ⍝ ;==================================================================
                         Code,←CodeHex'83' '7D' '0C' '4E'       ⍝     CMP    uMsg,WM_NOTIFY
                         Code,←CodeHex'74' '04'                 ⍝     JE     @1
                         Code,←CodeHex'C9'                      ⍝ @0: LEAVE
                         Code,←CodeHex'C2' '0010'               ⍝     RET    00010h
                                                                     ⍝ ;------------------------------------------------------------------
                         Code,←CodeHex'8B' '5D' '14'            ⍝ @1: MOV    EBX,lParam
                         Code,←CodeHex'81' '3B' '00000000'      ⍝     CMP    [EBX][NMLISTVIEW.hdr.hwndFrom],hWindow
                         ohWindow←¯4+↑⍴Code
                         Code,←CodeHex'75' 'F1'                 ⍝     JNE    @0
                         Code,←CodeHex'83' '7B' '08' 'F4'       ⍝     CMP    [EBX][NMLISTVIEW.hdr.code],NM_CUSTOMDRAW
                         Code,←CodeHex'75' 'EB'                 ⍝     JNE    @0
                                                                     ⍝ ;==================================================================
                         Code,←CodeHex'81' '7B' '0C' '00010001' ⍝     CMP    [EBX][NMLVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_ITEMPREPAINT
                         Code,←CodeHex'75' '24'                 ⍝     JNE    @2
                         Code,←CodeHex'8B' '53' '24'            ⍝     MOV    EDX,[EBX][NMLVCUSTOMDRAW.nmcd.dwItemSpec]
                         Code,←CodeHex'81' 'FA' '00000000'      ⍝     CMP    EDX,TableSize
                         oTableSize←¯4+↑⍴Code
                         Code,←CodeHex'73' 'D7'                 ⍝     JAE    @0
                         Code,←CodeHex'8B' '14' '95' '00000000' ⍝     MOV    EDX,ItemBCol[4*EDX]
                         opItemBCol←¯4+↑⍴Code
                         Code,←CodeHex'81' 'FA' '00FEFFFF'      ⍝     CMP    EDX,000FEFFFFh          ;0x00bbggrr: blue=254 green=255 red=255
                         Code,←CodeHex'74' 'C8'                 ⍝     JE     @0                      ;Use default color
                         Code,←CodeHex'89' '53' '34'            ⍝     MOV    [EBX][NMLVCUSTOMDRAW.clrTextBk],EDX
                         Code,←CodeHex'B8' '00000002'           ⍝     MOV    EAX,CDRF_NEWFONT
                         Code,←CodeHex'EB' 'BE'                 ⍝     JMP    @0
                                                                     ⍝ ;------------------------------------------------------------------
                         Code,←CodeHex'83' '7B' '0C' '01'       ⍝ @2: CMP    [EBX][NMLVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_PREPAINT
                         Code,←CodeHex'75' 'B8'                 ⍝     JNE    @0
                         Code,←CodeHex'B8' '00000020'           ⍝     MOV    EAX,CDRF_NOTIFYITEMDRAW
                         Code,←CodeHex'EB' 'B1'                 ⍝     JMP    @0
                                                                     ⍝ ;==================================================================
                         Code,←CodeHex'90' '90' '90'            ⍝     ALIGN  4
                         pItemBCol←↑⍴Code                       ⍝ LVWindowProc ENDP
                         Code,←CodeColor ItemBCol               ⍝ ItemBCol   COLORREF (LENGTHOF ItemBCol) DUP (0)
                     :Case 'TreeView'                           ⍝ TVWindowProc PROC,hwnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
                         Code←''                                ⍝ ;==================================================================
                         Code,←CodeHex'55'                      ⍝     PUSH   EBP
                         Code,←CodeHex'8B' 'EC'                 ⍝     MOV    EBP,ESP
                         Code,←CodeHex'FF' '75' '14'            ⍝     PUSH   lParam
                         Code,←CodeHex'FF' '75' '10'            ⍝     PUSH   wParam
                         Code,←CodeHex'FF' '75' '0C'            ⍝     PUSH   uMsg
                         Code,←CodeHex'FF' '75' '08'            ⍝     PUSH   hwnd
                         Code,←CodeHex'E8' '00000000'           ⍝     CALL   hWinProcOld
                         ohWinProcOld←¯4+↑⍴Code                 ⍝ ;==================================================================
                         Code,←CodeHex'83' '7D' '0C' '4E'       ⍝     CMP    uMsg,WM_NOTIFY
                         Code,←CodeHex'74' '04'                 ⍝     JE     @1
                         Code,←CodeHex'C9'                      ⍝ @0: LEAVE
                         Code,←CodeHex'C2' '0010'               ⍝     RET    00010h
                                                                     ⍝ ;------------------------------------------------------------------
                         Code,←CodeHex'8B' '5D' '14'            ⍝ @1: MOV    EBX,lParam
                         Code,←CodeHex'81' '3B' '00000000'      ⍝     CMP    [EBX][NMTREEVIEWA.hdr.hwndFrom],hWindow
                         ohWindow←¯4+↑⍴Code
                         Code,←CodeHex'75' 'F1'                 ⍝     JNE    @0
                         Code,←CodeHex'83' '7B' '08' 'F4'       ⍝     CMP    [EBX][NMTREEVIEWA.hdr.code],NM_CUSTOMDRAW
                         Code,←CodeHex'75' 'EB'                 ⍝     JNE    @0
                                                                     ⍝ ;==================================================================
                         Code,←CodeHex'81' '7B' '0C' '00010001' ⍝     CMP    [EBX][NMTVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_ITEMPREPAINT
                         Code,←CodeHex'75' '2D'                 ⍝     JNE    @2
                         Code,←CodeHex'F7' '43' '28' '00000001' ⍝     TEST   [EBX][NMTVCUSTOMDRAW.nmcd.uItemState],CDIS_SELECTED
                         Code,←CodeHex'75' 'D9'                 ⍝     JNE    @0                      ;Is item in selected state
                         Code,←CodeHex'8B' '53' '2C'            ⍝     MOV    EDX,[EBX][NMTVCUSTOMDRAW.nmcd.lItemlParam]
                         Code,←CodeHex'81' 'FA' '00000000'      ⍝     CMP    EDX,TableSize
                         oTableSize←¯4+↑⍴Code
                         Code,←CodeHex'73' 'CE'                 ⍝     JAE    @0
                         Code,←CodeHex'8B' '14' '95' '00000000' ⍝     MOV    EDX,ItemBCol[4*EDX]
                         opItemBCol←¯4+↑⍴Code
                         Code,←CodeHex'81' 'FA' '00FEFFFF'      ⍝     CMP    EDX,000FEFFFFh          ;0x00bbggrr: blue=254 green=255 red=255
                         Code,←CodeHex'74' 'BF'                 ⍝     JE     @0                      ;Use default color
                         Code,←CodeHex'89' '53' '34'            ⍝     MOV    [EBX][NMTVCUSTOMDRAW.clrTextBk],EDX
                         Code,←CodeHex'B8' '00000002'           ⍝     MOV    EAX,CDRF_NEWFONT
                         Code,←CodeHex'EB' 'B5'                 ⍝     JMP    @0
                                                                     ⍝ ;------------------------------------------------------------------
                         Code,←CodeHex'83' '7B' '0C' '01'       ⍝ @2: CMP    [EBX][NMTVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_PREPAINT
                         Code,←CodeHex'75' 'AF'                 ⍝     JNE    @0
                         Code,←CodeHex'B8' '00000020'           ⍝     MOV    EAX,CDRF_NOTIFYITEMDRAW
                         Code,←CodeHex'EB' 'A8'                 ⍝     JMP    @0
                                                                     ⍝ ;==================================================================
                         Code,←CodeHex'90' '90'                 ⍝     ALIGN  4
                         pItemBCol←↑⍴Code                       ⍝ TVWindowProc ENDP
                         Code,←CodeColor ItemBCol               ⍝ ItemBCol   COLORREF (LENGTHOF ItemBCol) DUP (0)
                     :EndSelect
                     :If #.Win.ZERO≠hOldWinProc←#.Win.Window.GetLong hWindowParent #.Win.GWL_WNDPROC
                     :AndIf #.Win.NULL≠hNewWinProc←#.Win.Mem.Alloc↑⍴Code
                         Code[ohWinProcOld+⍳4]←CodeOffset hOldWinProc-hNewWinProc+4+ohWinProcOld
                         Code[ohWindow+⍳4]←CodeOffset hWindow
                         Code[oTableSize+⍳4]←CodeOffset↑⍴ItemBCol
                         Code[opItemBCol+⍳4]←CodeOffset hNewWinProc+pItemBCol
                         Code #.Win.Mem.Write hNewWinProc
                     :AndIf #.Win.ZERO≠hNewWinProc #.Win.Window.SetLong hWindowParent #.Win.GWL_WNDPROC
                         Code←'''',ObjectName,'''',(↑⎕XSI),' ⍬'
                         :While 'Form'≢ObjectName ⎕WG'Type'
                         :Until 0∊⍴ObjectName←GetParentObjectName ObjectName
                         :If 'Form'≡ObjectName ⎕WG'Type'
                             :With ObjectName
                                 :If (↑⍴EventList)<Index←⌊/(↑¨EventList←⎕WG'Event')⍳33 'Close' 'onClose'
                                     ⎕WS'Event' 'Close'(⎕FX'_onClose'Code'⎕EX↑⎕XSI')
                                 :ElseIf 82=⎕DR ActionCode←(Index 2⊃EventList)~'&'
                                 :AndIf ×↑⍴CallbackFunction←⎕NR ActionCode
                                 :AndIf ~(⊂Code)∊TrimLeftRight¨CallbackFunction
                                     :With GetParentObjectName ActionCode
                                         ⎕FX(1↑CallbackFunction),(⊂Code),1↓CallbackFunction
                                     :EndWith
                                 :EndIf
                                 :If (↑⍴EventList)<Index←⌊/(↑¨EventList←⎕WG'Event')⍳270 'Detach' 'onDetach'
                                     ⎕WS'Event' 'Detach'(⎕FX'_onDetach'Code'⎕EX↑⎕XSI')
                                 :ElseIf 82=⎕DR ActionCode←(Index 2⊃EventList)~'&'
                                 :AndIf ×↑⍴CallbackFunction←⎕NR ActionCode
                                 :AndIf ~(⊂Code)∊TrimLeftRight¨CallbackFunction
                                     :With GetParentObjectName ActionCode
                                         ⎕FX(1↑CallbackFunction),(⊂Code),1↓CallbackFunction
                                     :EndWith
                                 :EndIf
                             :EndWith
                         :EndIf
                     :EndIf
                 :EndIf
             :EndSelect
         :EndWith
     :EndIf
 :EndHold
∇

∇ oObject SetItemFBCol ItemFBCol;CodeHex;CodeOffset;CodeColor;ColorCode;GetParentObjectName;TrimLeftRight;ObjectName;ObjectType;ChangedFlag;hWindow;hWindowParent;sItemFBCol;Code;ohWinProcOld;ohWindow;oTableSize;opItemFBCol;EventList;Index;ActionCode;CallbackFunction
     ⍝ Sets ItemColors in a ListView- or TreeView-Object
     ⍝ DO NOT USE TOGETHER WITH "SetItemFCol" or "SetItemBCol"
     ⍝ COL_FGDEF←0 0 1       ⍝ Default foreground color
     ⍝ COL_BGDEF←255 255 254 ⍝ Default background color
     ⍝
     ⍝ ItemFBCol = (RF GF BF RB GB BB)(RF GF BF RB GB BB)... all ∊ 0..255
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 #.Win.Init
 CodeHex←{1<≡⍵:∊∇¨⍵ ⋄ ⌽#.Win.TxtHex ⍵}
 CodeOffset←{4 #.Win.TxtInt ⍵}
 CodeColor←{∊1 #.Win.TxtInt¨1 1 1 0 1 1 1 0∘\¨⍵}
 ColorCode←{((⍴⍵)⍴1 1 1 1 1 1 0)⊂⍵}∘{((⍴⍵)⍴1 1 1 0 1 1 1 1)/256|#.Win.IntTxt ⍵}
 GetParentObjectName←{(-(⌽⍵)⍳'.')↓⍵}
 TrimLeftRight←{({(∨\⍵)∧⌽∨\⌽⍵}' '≠⍵)/⍵}
 :Hold '#.Win.Window.ItemCol'
     :If 0∊⍴oObject
         ObjectName←↑⎕NSI
     :ElseIf ×↑⍴oObject
     :AndIf '#.'≢2↑oObject
         ObjectName←(↑⎕NSI),'.',oObject
     :Else
         ObjectName←⍕oObject
     :EndIf
     :If 9=⎕NC ObjectName
         :With ObjectName
             :Select ObjectType←⎕WG'Type'
             :CaseList 'ListView' 'TreeView'
                 :If ChangedFlag←0≠hWindowParent←#.Win.Window.GetParent hWindow←⎕WG'Handle'
                     :If 2∧.=⎕NC⊃'hOldWinProc' 'hNewWinProc' 'pItemFBCol'
                     :AndIf 0<sItemFBCol←(#.Win.Mem.Size hNewWinProc)-pItemFBCol
                     :AndIf ChangedFlag←ItemFBCol≢ColorCode sItemFBCol #.Win.Mem.Read hNewWinProc+pItemFBCol
                     :AndIf #.Win.ZERO≠hOldWinProc #.Win.Window.SetLong hWindowParent #.Win.GWL_WNDPROC
                         #.Win.Mem.Free hNewWinProc
                         ⎕EX⊃'hOldWinProc' 'hNewWinProc' 'pItemFBCol'
                     :EndIf
                 :AndIf ChangedFlag
                 :AndIf ×↑⍴ItemFBCol
                 :AndIf 2=≡ItemFBCol
                 :AndIf 6∧.=↑∘⍴¨ItemFBCol
                     :Select ObjectType
                     :Case 'ListView'                           ⍝ LVWindowProc PROC,hwnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
                         Code←''                                ⍝ ;==================================================================
                         Code,←CodeHex'55'                      ⍝    PUSH  EBP
                         Code,←CodeHex'8B' 'EC'                 ⍝    MOV   EBP,ESP
                         Code,←CodeHex'FF' '75' '14'            ⍝    PUSH  lParam                  ;second message parameter
                         Code,←CodeHex'FF' '75' '10'            ⍝    PUSH  wParam                  ;first message parameter
                         Code,←CodeHex'FF' '75' '0C'            ⍝    PUSH  uMsg                    ;message identifier
                         Code,←CodeHex'FF' '75' '08'            ⍝    PUSH  hwnd                    ;handle to window
                         Code,←CodeHex'E8' '00000000'           ⍝    CALL  hWinProcOld
                         ohWinProcOld←¯4+↑⍴Code                 ⍝ ;==================================================================
                         Code,←CodeHex'83' '7D' '0C' '4E'       ⍝    CMP   uMsg,WM_NOTIFY          ;message identifier
                         Code,←CodeHex'74' '04'                 ⍝    JE    @1
                         Code,←CodeHex'C9'                      ⍝ @0:LEAVE
                         Code,←CodeHex'C2' '0010'               ⍝    RET   00010h
                                                                     ⍝ ;------------------------------------------------------------------
                         Code,←CodeHex'8B' '5D' '14'            ⍝ @1:MOV    EBX,lParam              ;LPNMLISTVIEW
                         Code,←CodeHex'81' '3B' '00000000'      ⍝    CMP    [EBX][NMLISTVIEW.hdr.hwndFrom],hChildWindow
                         ohWindow←¯4+↑⍴Code
                         Code,←CodeHex'75' 'F1'                 ⍝    JNE    @0
                         Code,←CodeHex'83' '7B' '08' 'F4'       ⍝    CMP    [EBX][NMLISTVIEW.hdr.code],NM_CUSTOMDRAW
                         Code,←CodeHex'75' 'EB'                 ⍝    JNE    @0
                                                                     ⍝ ;==================================================================
                         Code,←CodeHex'81' '7B' '0C' '00010001' ⍝    CMP    [EBX][NMLVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_ITEMPREPAINT
                         Code,←CodeHex'75' '32'                 ⍝    JNE    @4
                         Code,←CodeHex'8B' '53' '24'            ⍝    MOV    EDX,[EBX][NMLVCUSTOMDRAW.nmcd.dwItemSpec]
                         Code,←CodeHex'81' 'FA' '00000000'      ⍝    CMP    EDX,TableSize
                         oTableSize←¯4+↑⍴Code
                         Code,←CodeHex'73' 'D7'                 ⍝    JAE    @0
                         Code,←CodeHex'8D' '14' 'D5' '00000080' ⍝    LEA    EDX,ItemFBCol[8*EDX]
                         opItemFBCol←¯4+↑⍴Code
                         Code,←CodeHex'8B' '02'                 ⍝    MOV    EAX,[EDX][0]            ;clrText
                         Code,←CodeHex'3D' '00010000'           ⍝    CMP    EAX,000010000h          ;0x00bbggrr: blue=1 green=0 red=0
                         Code,←CodeHex'74' '03'                 ⍝    JE     @2                      ;Use default color
                         Code,←CodeHex'89' '43' '30'            ⍝    MOV    [EBX][NMLVCUSTOMDRAW.clrText],EAX
                         Code,←CodeHex'8B' '42' '04'            ⍝ @2:MOV    EAX,[EDX][4]            ;clrTextBk
                         Code,←CodeHex'3D' '00FEFFFF'           ⍝    CMP    EAX,000FEFFFFh          ;0x00bbggrr: blue=254 green=255 red=255
                         Code,←CodeHex'74' '03'                 ⍝    JE     @3                      ;Use default color
                         Code,←CodeHex'89' '43' '34'            ⍝    MOV    [EBX][NMLVCUSTOMDRAW.clrTextBk],EAX
                         Code,←CodeHex'B8' '00000002'           ⍝ @3:MOV    EAX,CDRF_NEWFONT
                         Code,←CodeHex'EB' 'B0'                 ⍝    JMP    @0
                                                                     ⍝ ;==================================================================
                         Code,←CodeHex'83' '7B' '0C' '01'       ⍝ @4:CMP    [EBX][NMLVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_PREPAINT
                         Code,←CodeHex'75' 'AA'                 ⍝    JNE    @0
                                                                     ⍝ ;------------------------------------------------------------------
                         Code,←CodeHex'B8' '00000020'           ⍝    MOV    EAX,CDRF_NOTIFYITEMDRAW
                         Code,←CodeHex'EB' 'A3'                 ⍝    JMP    @0
                                                                     ⍝ ;==================================================================
                         Code,←CodeHex'90'                      ⍝    ALIGN 4
                         pItemFBCol←↑⍴Code                      ⍝ LVWindowProc ENDP
                         Code,←CodeColor ItemFBCol              ⍝ ItemFBCol COLORREF (2*LENGTHOF ItemFBCol) DUP (0)
                     :Case 'TreeView'                           ⍝ TVWindowProc PROC,hwnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
                         Code←''                                ⍝ ;==================================================================
                         Code,←CodeHex'55'                      ⍝    PUSH  EBP
                         Code,←CodeHex'8B' 'EC'                 ⍝    MOV   EBP,ESP
                         Code,←CodeHex'FF' '75' '14'            ⍝    PUSH  lParam                  ;second message parameter
                         Code,←CodeHex'FF' '75' '10'            ⍝    PUSH  wParam                  ;first message parameter
                         Code,←CodeHex'FF' '75' '0C'            ⍝    PUSH  uMsg                    ;message identifier
                         Code,←CodeHex'FF' '75' '08'            ⍝    PUSH  hwnd                    ;handle to window
                         Code,←CodeHex'E8' '00000000'           ⍝    CALL  hWinProcOld
                         ohWinProcOld←¯4+↑⍴Code                 ⍝ ;==================================================================
                         Code,←CodeHex'83' '7D' '0C' '4E'       ⍝    CMP   uMsg,WM_NOTIFY          ;message identifier
                         Code,←CodeHex'74' '04'                 ⍝    JE    @1
                         Code,←CodeHex'C9'                      ⍝ @0:LEAVE
                         Code,←CodeHex'C2' '0010'               ⍝    RET   00010h
                                                                     ⍝ ;------------------------------------------------------------------------------
                         Code,←CodeHex'8B' '5D' '14'            ⍝ @1:MOV    EBX,lParam              ;LPNMTREEVIEW
                         Code,←CodeHex'81' '3B' '00000000'      ⍝    CMP    [EBX][NMTREEVIEWA.hdr.hwndFrom],hChildWindow
                         ohWindow←¯4+↑⍴Code
                         Code,←CodeHex'75' 'F1'                 ⍝    JNE    @0
                         Code,←CodeHex'83' '7B' '08' 'F4'       ⍝    CMP    [EBX][NMTREEVIEWA.hdr.code],NM_CUSTOMDRAW
                         Code,←CodeHex'75' 'EB'                 ⍝    JNE    @0
                                                                     ⍝ ;=============================================================================
                         Code,←CodeHex'81' '7B' '0C' '00010001' ⍝    CMP    [EBX][NMTVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_ITEMPREPAINT
                         Code,←CodeHex'75' '3B'                 ⍝    JNE    @4
                         Code,←CodeHex'F7' '43' '28' '00000001' ⍝    TEST   [EBX][NMTVCUSTOMDRAW.nmcd.uItemState],CDIS_SELECTED
                         Code,←CodeHex'75' 'D9'                 ⍝    JNE    @0                      ;Item is in selected state
                         Code,←CodeHex'8B' '53' '2C'            ⍝    MOV    EDX,[EBX][NMTVCUSTOMDRAW.nmcd.lItemlParam]
                         Code,←CodeHex'81' 'FA' '00000000'      ⍝    CMP    EDX,TableSize
                         oTableSize←¯4+↑⍴Code
                         Code,←CodeHex'73' 'CE'                 ⍝    JAE    @0
                                                                     ⍝ ;-----------------------------------------------------------------------------
                         Code,←CodeHex'8D' '14' 'D5' '00000080' ⍝    LEA    EDX,ItemFBCol[8*EDX]
                         opItemFBCol←¯4+↑⍴Code
                         Code,←CodeHex'8B' '02'                 ⍝    MOV    EAX,[EDX][0]            ;clrText
                         Code,←CodeHex'3D' '00010000'           ⍝    CMP    EAX,000010000h          ;0x00bbggrr: blue=1 green=0 red=0
                         Code,←CodeHex'74' '03'                 ⍝    JE     @2                      ;Use default color
                         Code,←CodeHex'89' '43' '30'            ⍝    MOV    [EBX][NMTVCUSTOMDRAW.clrText],EAX
                         Code,←CodeHex'8B' '42' '04'            ⍝ @2:MOV    EAX,[EDX][4]            ;clrTextBk
                         Code,←CodeHex'3D' '00FEFFFF'           ⍝    CMP    EAX,000FEFFFFh          ;0x00bbggrr: blue=254 green=255 red=255
                         Code,←CodeHex'74' '03'                 ⍝    JE     @3                      ;Use default color
                         Code,←CodeHex'89' '43' '34'            ⍝    MOV    [EBX][NMTVCUSTOMDRAW.clrTextBk],EAX
                         Code,←CodeHex'B8' '00000002'           ⍝ @3:MOV    EAX,CDRF_NEWFONT
                         Code,←CodeHex'EB' 'A7'                 ⍝    JMP    @0
                                                                     ⍝ ;=============================================================================
                         Code,←CodeHex'83' '7B' '0C' '01'       ⍝ @4:CMP    [EBX][NMTVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_PREPAINT
                         Code,←CodeHex'75' 'A1'                 ⍝    JNE    @0
                                                                     ⍝ ;-----------------------------------------------------------------------------
                         Code,←CodeHex'B8' '00000020'           ⍝    MOV    EAX,CDRF_NOTIFYITEMDRAW
                         Code,←CodeHex'EB' '9A'                 ⍝    JMP    @0
                                                                     ⍝    ALIGN 4
                         pItemFBCol←↑⍴Code                      ⍝ TVWindowProc ENDP
                         Code,←CodeColor ItemFBCol              ⍝ ItemFBCol COLORREF (2*LENGTHOF ItemFBCol) DUP (0)
                     :EndSelect
                     :If #.Win.ZERO≠hOldWinProc←#.Win.Window.GetLong hWindowParent #.Win.GWL_WNDPROC
                     :AndIf #.Win.NULL≠hNewWinProc←#.Win.Mem.Alloc↑⍴Code
                         Code[ohWinProcOld+⍳4]←CodeOffset hOldWinProc-hNewWinProc+4+ohWinProcOld
                         Code[ohWindow+⍳4]←CodeOffset hWindow
                         Code[oTableSize+⍳4]←CodeOffset↑⍴ItemFBCol
                         Code[opItemFBCol+⍳4]←CodeOffset hNewWinProc+pItemFBCol
                         Code #.Win.Mem.Write hNewWinProc
                     :AndIf #.Win.ZERO≠hNewWinProc #.Win.Window.SetLong hWindowParent #.Win.GWL_WNDPROC
                         Code←'''',ObjectName,'''',(↑⎕XSI),' ⍬'
                         :While 'Form'≢ObjectName ⎕WG'Type'
                         :Until 0∊⍴ObjectName←GetParentObjectName ObjectName
                         :If 'Form'≡ObjectName ⎕WG'Type'
                             :With ObjectName
                                 :If (↑⍴EventList)<Index←⌊/(↑¨EventList←⎕WG'Event')⍳33 'Close' 'onClose'
                                     ⎕WS'Event' 'Close'(⎕FX'_onClose'Code'⎕EX↑⎕XSI')
                                 :ElseIf 82=⎕DR ActionCode←(Index 2⊃EventList)~'&'
                                 :AndIf ×↑⍴CallbackFunction←⎕NR ActionCode
                                 :AndIf ~(⊂Code)∊TrimLeftRight¨CallbackFunction
                                     :With GetParentObjectName ActionCode
                                         ⎕FX(1↑CallbackFunction),(⊂Code),1↓CallbackFunction
                                     :EndWith
                                 :EndIf
                                 :If (↑⍴EventList)<Index←⌊/(↑¨EventList←⎕WG'Event')⍳270 'Detach' 'onDetach'
                                     ⎕WS'Event' 'Detach'(⎕FX'_onDetach'Code'⎕EX↑⎕XSI')
                                 :ElseIf 82=⎕DR ActionCode←(Index 2⊃EventList)~'&'
                                 :AndIf ×↑⍴CallbackFunction←⎕NR ActionCode
                                 :AndIf ~(⊂Code)∊TrimLeftRight¨CallbackFunction
                                     :With GetParentObjectName ActionCode
                                         ⎕FX(1↑CallbackFunction),(⊂Code),1↓CallbackFunction
                                     :EndWith
                                 :EndIf
                             :EndWith
                         :EndIf
                     :EndIf
                 :EndIf
             :EndSelect
         :EndWith
     :EndIf
 :EndHold
∇

∇ oObject SetItemFCol ItemFCol;CodeHex;CodeOffset;CodeColor;ColorCode;GetParentObjectName;TrimLeftRight;ObjectName;ObjectType;ChangedFlag;hWindow;hWindowParent;sItemFCol;Code;ohWinProcOld;ohWindow;oTableSize;opItemFCol;EventList;Index;ActionCode;CallbackFunction
     ⍝ Sets ItemColors in a ListView- or TreeView-Object
     ⍝ DO NOT USE TOGETHER WITH "SetItemBCol" or "SetItemFBCol"
     ⍝ COL_FGDEF←0 0 1       ⍝ Default foreground color
     ⍝
     ⍝ ItemFCol = (R G B)(R G B)... all ∊ 0..255
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2000
     ⍝ mailto:Hager@Dortmund.net
 #.Win.Init
 CodeHex←{1<≡⍵:∊∇¨⍵ ⋄ ⌽#.Win.TxtHex ⍵}
 CodeOffset←{4 #.Win.TxtInt ⍵}
 CodeColor←{∊1 #.Win.TxtInt¨1 1 1 0∘\¨⍵}
 ColorCode←{((⍴⍵)⍴1 1 1 0)⊂256|#.Win.IntTxt ⍵}
 GetParentObjectName←{(-(⌽⍵)⍳'.')↓⍵}
 TrimLeftRight←{({(∨\⍵)∧⌽∨\⌽⍵}' '≠⍵)/⍵}
 :Hold '#.Win.Window.ItemCol'
     :If 0∊⍴oObject
         ObjectName←↑⎕NSI
     :ElseIf ×↑⍴oObject
     :AndIf '#.'≢2↑oObject
         ObjectName←(↑⎕NSI),'.',oObject
     :Else
         ObjectName←⍕oObject
     :EndIf
     :If 9=⎕NC ObjectName
         :With ObjectName
             :Select ObjectType←⎕WG'Type'
             :CaseList 'ListView' 'TreeView'
                 :If ChangedFlag←0≠hWindowParent←#.Win.Window.GetParent hWindow←⎕WG'Handle'
                     :If 2∧.=⎕NC⊃'hOldWinProc' 'hNewWinProc' 'pItemFCol'
                     :AndIf 0<sItemFCol←(#.Win.Mem.Size hNewWinProc)-pItemFCol
                     :AndIf ChangedFlag←ItemFCol≢ColorCode sItemFCol #.Win.Mem.Read hNewWinProc+pItemFCol
                     :AndIf #.Win.ZERO≠hOldWinProc #.Win.Window.SetLong hWindowParent #.Win.GWL_WNDPROC
                         #.Win.Mem.Free hNewWinProc
                         ⎕EX⊃'hOldWinProc' 'hNewWinProc' 'pItemFCol'
                     :EndIf
                 :AndIf ChangedFlag
                 :AndIf ×↑⍴ItemFCol
                 :AndIf 2=≡ItemFCol
                 :AndIf 3∧.=↑∘⍴¨ItemFCol
                     :Select ObjectType
                     :Case 'ListView'                           ⍝ LVWindowProc PROC,hwnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
                         Code←''                                ⍝ ;==================================================================
                         Code,←CodeHex'55'                      ⍝     PUSH   EBP
                         Code,←CodeHex'8B' 'EC'                 ⍝     MOV    EBP,ESP
                         Code,←CodeHex'FF' '75' '14'            ⍝     PUSH   lParam
                         Code,←CodeHex'FF' '75' '10'            ⍝     PUSH   wParam
                         Code,←CodeHex'FF' '75' '0C'            ⍝     PUSH   uMsg
                         Code,←CodeHex'FF' '75' '08'            ⍝     PUSH   hwnd
                         Code,←CodeHex'E8' '00000000'           ⍝     CALL   hWinProcOld
                         ohWinProcOld←¯4+↑⍴Code                 ⍝ ;==================================================================
                         Code,←CodeHex'83' '7D' '0C' '4E'       ⍝     CMP    uMsg,WM_NOTIFY
                         Code,←CodeHex'74' '04'                 ⍝     JE     @1
                         Code,←CodeHex'C9'                      ⍝ @0: LEAVE
                         Code,←CodeHex'C2' '0010'               ⍝     RET    00010h
                                                                     ⍝ ;------------------------------------------------------------------
                         Code,←CodeHex'8B' '5D' '14'            ⍝ @1: MOV    EBX,lParam
                         Code,←CodeHex'81' '3B' '00000000'      ⍝     CMP    [EBX][NMLISTVIEW.hdr.hwndFrom],hWindow
                         ohWindow←¯4+↑⍴Code
                         Code,←CodeHex'75' 'F1'                 ⍝     JNE    @0
                         Code,←CodeHex'83' '7B' '08' 'F4'       ⍝     CMP    [EBX][NMLISTVIEW.hdr.code],NM_CUSTOMDRAW
                         Code,←CodeHex'75' 'EB'                 ⍝     JNE    @0
                                                                     ⍝ ;==================================================================
                         Code,←CodeHex'81' '7B' '0C' '00010001' ⍝     CMP    [EBX][NMLVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_ITEMPREPAINT
                         Code,←CodeHex'75' '24'                 ⍝     JNE    @2
                         Code,←CodeHex'8B' '53' '24'            ⍝     MOV    EDX,[EBX][NMLVCUSTOMDRAW.nmcd.dwItemSpec]
                         Code,←CodeHex'81' 'FA' '00000000'      ⍝     CMP    EDX,TableSize
                         oTableSize←¯4+↑⍴Code
                         Code,←CodeHex'73' 'D7'                 ⍝     JAE    @0
                         Code,←CodeHex'8B' '14' '95' '00000000' ⍝     MOV    EDX,ItemFCol[4*EDX]
                         opItemFCol←¯4+↑⍴Code
                         Code,←CodeHex'81' 'FA' '00010000'      ⍝     CMP    EDX,000010000h          ;0x00bbggrr: blue=1 green=0 red=0
                         Code,←CodeHex'74' 'C0'                 ⍝     JE     @0                      ;Use default color
                         Code,←CodeHex'89' '53' '30'            ⍝     MOV    [EBX][NMLVCUSTOMDRAW.clrText],EDX
                         Code,←CodeHex'B8' '00000002'           ⍝     MOV    EAX,CDRF_NEWFONT
                         Code,←CodeHex'EB' 'BE'                 ⍝     JMP    @0
                                                                     ⍝ ;------------------------------------------------------------------
                         Code,←CodeHex'83' '7B' '0C' '01'       ⍝ @2: CMP    [EBX][NMLVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_PREPAINT
                         Code,←CodeHex'75' 'B8'                 ⍝     JNE    @0
                         Code,←CodeHex'B8' '00000020'           ⍝     MOV    EAX,CDRF_NOTIFYITEMDRAW
                         Code,←CodeHex'EB' 'B1'                 ⍝     JMP    @0
                                                                     ⍝ ;==================================================================
                         Code,←CodeHex'90' '90' '90'            ⍝     ALIGN  4
                         pItemFCol←↑⍴Code                       ⍝ LVWindowProc ENDP
                         Code,←CodeColor ItemFCol               ⍝ ItemFCol   COLORREF (LENGTHOF ItemFCol) DUP (0)
                     :Case 'TreeView'                           ⍝ TVWindowProc PROC,hwnd:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM
                         Code←''                                ⍝ ;==================================================================
                         Code,←CodeHex'55'                      ⍝     PUSH   EBP
                         Code,←CodeHex'8B' 'EC'                 ⍝     MOV    EBP,ESP
                         Code,←CodeHex'FF' '75' '14'            ⍝     PUSH   lParam
                         Code,←CodeHex'FF' '75' '10'            ⍝     PUSH   wParam
                         Code,←CodeHex'FF' '75' '0C'            ⍝     PUSH   uMsg
                         Code,←CodeHex'FF' '75' '08'            ⍝     PUSH   hwnd
                         Code,←CodeHex'E8' '00000000'           ⍝     CALL   hWinProcOld
                         ohWinProcOld←¯4+↑⍴Code                 ⍝ ;==================================================================
                         Code,←CodeHex'83' '7D' '0C' '4E'       ⍝     CMP    uMsg,WM_NOTIFY
                         Code,←CodeHex'74' '04'                 ⍝     JE     @1
                         Code,←CodeHex'C9'                      ⍝ @0: LEAVE
                         Code,←CodeHex'C2' '0010'               ⍝     RET    00010h
                                                                     ⍝ ;------------------------------------------------------------------
                         Code,←CodeHex'8B' '5D' '14'            ⍝ @1: MOV    EBX,lParam
                         Code,←CodeHex'81' '3B' '00000000'      ⍝     CMP    [EBX][NMTREEVIEWA.hdr.hwndFrom],hWindow
                         ohWindow←¯4+↑⍴Code
                         Code,←CodeHex'75' 'F1'                 ⍝     JNE    @0
                         Code,←CodeHex'83' '7B' '08' 'F4'       ⍝     CMP    [EBX][NMTREEVIEWA.hdr.code],NM_CUSTOMDRAW
                         Code,←CodeHex'75' 'EB'                 ⍝     JNE    @0
                                                                     ⍝ ;==================================================================
                         Code,←CodeHex'81' '7B' '0C' '00010001' ⍝     CMP    [EBX][NMTVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_ITEMPREPAINT
                         Code,←CodeHex'75' '2D'                 ⍝     JNE    @2
                         Code,←CodeHex'F7' '43' '28' '00000001' ⍝     TEST   [EBX][NMTVCUSTOMDRAW.nmcd.uItemState],CDIS_SELECTED
                         Code,←CodeHex'75' 'D9'                 ⍝     JNE    @0                      ;Item is in selected state
                         Code,←CodeHex'8B' '53' '2C'            ⍝     MOV    EDX,[EBX][NMTVCUSTOMDRAW.nmcd.lItemlParam]
                         Code,←CodeHex'81' 'FA' '00000000'      ⍝     CMP    EDX,TableSize
                         oTableSize←¯4+↑⍴Code
                         Code,←CodeHex'73' 'CE'                 ⍝     JAE    @0
                         Code,←CodeHex'8B' '14' '95' '00000000' ⍝     MOV    EDX,ItemFCol[4*EDX]
                         opItemFCol←¯4+↑⍴Code
                         Code,←CodeHex'81' 'FA' '00010000'      ⍝     CMP    EDX,000010000h          ;0x00bbggrr: blue=1 green=0 red=0
                         Code,←CodeHex'74' 'BF'                 ⍝     JE     @0                      ;Use default color
                         Code,←CodeHex'89' '53' '30'            ⍝     MOV    [EBX][NMTVCUSTOMDRAW.clrText],EDX
                         Code,←CodeHex'B8' '00000002'           ⍝     MOV    EAX,CDRF_NEWFONT
                         Code,←CodeHex'EB' 'B5'                 ⍝     JMP    @0
                                                                     ⍝ ;------------------------------------------------------------------
                         Code,←CodeHex'83' '7B' '0C' '01'       ⍝ @2: CMP    [EBX][NMTVCUSTOMDRAW.nmcd.dwDrawStage],CDDS_PREPAINT
                         Code,←CodeHex'75' 'AF'                 ⍝     JNE    @0
                         Code,←CodeHex'B8' '00000020'           ⍝     MOV    EAX,CDRF_NOTIFYITEMDRAW
                         Code,←CodeHex'EB' 'A8'                 ⍝     JMP    @0
                                                                     ⍝ ;==================================================================
                         Code,←CodeHex'90' '90'                 ⍝     ALIGN  4
                         pItemFCol←↑⍴Code                       ⍝ TVWindowProc ENDP
                         Code,←CodeColor ItemFCol               ⍝ ItemFCol   COLORREF (LENGTHOF ItemFCol) DUP (0)
                     :EndSelect
                     :If #.Win.ZERO≠hOldWinProc←#.Win.Window.GetLong hWindowParent #.Win.GWL_WNDPROC
                     :AndIf #.Win.NULL≠hNewWinProc←#.Win.Mem.Alloc↑⍴Code
                         Code[ohWinProcOld+⍳4]←CodeOffset hOldWinProc-hNewWinProc+4+ohWinProcOld
                         Code[ohWindow+⍳4]←CodeOffset hWindow
                         Code[oTableSize+⍳4]←CodeOffset↑⍴ItemFCol
                         Code[opItemFCol+⍳4]←CodeOffset hNewWinProc+pItemFCol
                         Code #.Win.Mem.Write hNewWinProc
                     :AndIf #.Win.ZERO≠hNewWinProc #.Win.Window.SetLong hWindowParent #.Win.GWL_WNDPROC
                         Code←'''',ObjectName,'''',(↑⎕XSI),' ⍬'
                         :While 'Form'≢ObjectName ⎕WG'Type'
                         :Until 0∊⍴ObjectName←GetParentObjectName ObjectName
                         :If 'Form'≡ObjectName ⎕WG'Type'
                             :With ObjectName
                                 :If (↑⍴EventList)<Index←⌊/(↑¨EventList←⎕WG'Event')⍳33 'Close' 'onClose'
                                     ⎕WS'Event' 'Close'(⎕FX'_onClose'Code'⎕EX↑⎕XSI')
                                 :ElseIf 82=⎕DR ActionCode←(Index 2⊃EventList)~'&'
                                 :AndIf ×↑⍴CallbackFunction←⎕NR ActionCode
                                 :AndIf ~(⊂Code)∊TrimLeftRight¨CallbackFunction
                                     :With GetParentObjectName ActionCode
                                         ⎕FX(1↑CallbackFunction),(⊂Code),1↓CallbackFunction
                                     :EndWith
                                 :EndIf
                                 :If (↑⍴EventList)<Index←⌊/(↑¨EventList←⎕WG'Event')⍳270 'Detach' 'onDetach'
                                     ⎕WS'Event' 'Detach'(⎕FX'_onDetach'Code'⎕EX↑⎕XSI')
                                 :ElseIf 82=⎕DR ActionCode←(Index 2⊃EventList)~'&'
                                 :AndIf ×↑⍴CallbackFunction←⎕NR ActionCode
                                 :AndIf ~(⊂Code)∊TrimLeftRight¨CallbackFunction
                                     :With GetParentObjectName ActionCode
                                         ⎕FX(1↑CallbackFunction),(⊂Code),1↓CallbackFunction
                                     :EndWith
                                 :EndIf
                             :EndWith
                         :EndIf
                     :EndIf
                 :EndIf
             :EndSelect
         :EndWith
     :EndIf
 :EndHold
∇

∇ {Long}←NewLong SetLong Parms;hWnd;Index;NewLong
     ⍝ Change an attribute of the specified window
     ⍝
     ⍝  hWnd    handle to window
     ⍝  Index   offset of value to retrieve (#.Win.GWL_WNDPROC #.Win.GWL_HINSTANCE #.Win.GWL_STYLE #.Win.GWL_EXSTYLE #.Win.GWL_USERDATA #.Win.GWL_ID #.Win.DWL_USER #.Win.DWL_DLGPROC #.Win.DWL_MSGRESULT)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWnd Index←2↑Parms
 :If ##.ZERO≠Long←##.SetWindowLong hWnd Index NewLong
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {Long}←NewLong SetLongW Parms;hWnd;Index;NewLong
     ⍝ Change an attribute of the specified window in Unicode mode
     ⍝
     ⍝  hWnd    handle to window
     ⍝  Index   offset of value to retrieve (#.Win.GWL_WNDPROC #.Win.GWL_HINSTANCE #.Win.GWL_STYLE #.Win.GWL_EXSTYLE #.Win.GWL_USERDATA #.Win.GWL_ID #.Win.DWL_USER #.Win.DWL_DLGPROC #.Win.DWL_MSGRESULT)
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 hWnd Index←2↑Parms
 :If ##.ZERO≠Long←##.SetWindowLongW hWnd Index NewLong
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {hWndOldParent}←hWndNewParent SetParent hWnd
     ⍝ Change the parent window of the specified child window
     ⍝
     ⍝ hWnd = Handle to child window
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 :If ##.NULL≠hWndOldParent←##.SetParent hWnd hWndNewParent
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {VOID}←String SetText hWnd
     ⍝ Change the text of the specified window's title bar
     ⍝ If the specified window is a control of this application, the text of the control is changed.
     ⍝
     ⍝ hWnd   = Handle to window
     ⍝ String = New title or control text
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 1998
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 String←##.IntTxt String,↑⎕AV
 :If VOID←##.SetWindowText hWnd String
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

∇ {VOID}←String SetTextW hWnd
     ⍝ Change the text of the specified window's title bar in Unicode mode
     ⍝ If the specified window is a control of this application, the text of the control is changed.
     ⍝
     ⍝ hWnd   = Handle to window
     ⍝ String = New title or control text
     ⍝
     ⍝ (c) Peter-Michael Hager, Dortmund (Germany) 2002
     ⍝ mailto:Hager@Dortmund.net
 ##.Init
 String←##.IntTxt String,2⍴↑⎕AV
 :If VOID←##.SetWindowTextW hWnd String
     #.RCode←##.ERROR_SUCCESS
 :Else
     #.RCode←##.GetLastError
 :EndIf
∇

:Namespace Samples
⎕IO ⎕ML ⎕WX←1 3 1

∇ BCol;Black;Red;Blue;Green;Cyan;Magenta;Yellow;White;Items;Depth;BCol;Form
 #.Win.Init
 Black←0 0 0
 Red←255 0 0
 Green←0 255 0
 Blue←0 0 255
 Cyan←0 255 255
 Magenta←255 0 255
 Yellow←255 255 0
 White←255 255 255
     
 Items←'White' 'Red' 'Blue' 'Green' 'Cyan' 'Magenta' 'Yellow'
 Depth←0 1 1 0 1 2 0
 BCol←White Red Blue Green Cyan Magenta Yellow
     
 'Form'⎕WC'Form'('Caption' 'Item Background Colors')('OnTop' 1)('Coord' 'Pixel')('Size'(200 560))
 'Form.Tree'⎕WC'SubForm'('Posn'(0 0))('Size'(200 160))   ⍝ SetItemBCol NOT TWICE ON THE SAME PARENT
 'Form.List'⎕WC'SubForm'('Posn'(0 160))('Size'(200 400)) ⍝ *******  SO WE MUST USE SUBFORMS ********
     
 'Form.Tree.TreeView'⎕WC'TreeView'('Items'Items)('Depth'Depth)('Posn'(0 0))('Size'(200 160))
 'Form.Tree.TreeView'#.Win.Window.SetItemBCol BCol
 'Form.List.ListView'⎕WC'ListView'('Items'Items)('ReportInfo'(8 2⍴⊂'XXX'))('View' 'Report')('Posn'(0 0))('Size'(200 400))
 'Form.List.ListView'#.Win.Window.SetItemBCol BCol
 ⎕DL 1
 BCol←⌽BCol
 Items←⌽Items
 'Form.List.ListView'#.Win.Window.SetItemBCol BCol
 'Form.List.ListView'⎕WS('Items'Items)
 'Form.Tree.TreeView'#.Win.Window.SetItemBCol BCol
 'Form.Tree.TreeView'⎕WS('Items'Items)('Depth'Depth)
     ⍝BCol←#.Win.Window.GetItemBCol'Form.List.ListView'
     ⍝BCol←#.Win.Window.GetItemBCol'Form.Tree.TreeView'
 ⎕DQ'Form'
 #.Win.Exit
∇

∇ FBCol;Black;Red;Blue;Green;Cyan;Magenta;Yellow;White;Items;Depth;FBCol;Form
 #.Win.Init
 Black←0 0 0
 Red←255 0 0
 Green←0 255 0
 Blue←0 0 255
 Cyan←0 255 255
 Magenta←255 0 255
 Yellow←255 255 0
 White←255 255 255
     
 Items←'Black' 'Red' 'Blue' 'Green' 'Cyan' 'Magenta' 'Yellow' 'White'
 Depth←0 1 1 0 1 2 2 0
 FBCol←(Black,White)(White,Red)(White,Blue)(Black,Green)(Black,Cyan)(White,Magenta)(Black,Yellow)(White,Black)
     
 'Form'⎕WC'Form'('Caption' 'Item Fore- an Background Colors')('OnTop' 1)('Coord' 'Pixel')('Size'(200 560))
 'Form.Tree'⎕WC'SubForm'('Posn'(0 0))('Size'(200 160))   ⍝ SetItemFBCol NOT TWICE ON THE SAME PARENT
 'Form.List'⎕WC'SubForm'('Posn'(0 160))('Size'(200 400)) ⍝ *******  SO WE MUST USE SUBFORMS ********
     
 'Form.Tree.TreeView'⎕WC'TreeView'('Items'Items)('Depth'Depth)('Posn'(0 0))('Size'(200 160))
 'Form.Tree.TreeView'#.Win.Window.SetItemFBCol FBCol
 'Form.List.ListView'⎕WC'ListView'('Items'Items)('ReportInfo'(8 2⍴⊂'XXX'))('View' 'Report')('Posn'(0 0))('Size'(200 400))
 'Form.List.ListView'#.Win.Window.SetItemFBCol FBCol
 ⎕DL 1
 FBCol←⌽FBCol
 Items←⌽Items
 'Form.List.ListView'#.Win.Window.SetItemFBCol FBCol
 'Form.List.ListView'⎕WS('Items'Items)
 'Form.Tree.TreeView'#.Win.Window.SetItemFBCol FBCol
 'Form.Tree.TreeView'⎕WS('Items'Items)('Depth'Depth)
     ⍝FBCol←#.Win.Window.GetItemFBCol'Form.List.ListView'
     ⍝FBCol←#.Win.Window.GetItemFBCol'Form.Tree.TreeView'
 ⎕DQ'Form'
 #.Win.Exit
∇

∇ FCol;Black;Red;Blue;Green;Cyan;Magenta;Yellow;White;Items;Depth;FCol
 #.Win.Init
 Black←0 0 0
 Red←127 0 0
 Green←0 127 0
 Blue←0 0 127
 Cyan←0 127 127
 Magenta←127 0 127
 Yellow←127 127 0
 White←127 127 127
     
 Items←'Black' 'Red' 'Blue' 'Green' 'Cyan' 'Magenta' 'Yellow'
 Depth←0 1 1 0 1 2 0
 FCol←Black Red Blue Green Cyan Magenta Yellow
     
 'Form'⎕WC'Form'('Caption' 'Item Foreground Colors')('OnTop' 1)('Coord' 'Pixel')('Size'(200 560))
 'Form.Tree'⎕WC'SubForm'('Posn'(0 0))('Size'(200 160))   ⍝ SetItemBCol NOT TWICE ON THE SAME PARENT
 'Form.List'⎕WC'SubForm'('Posn'(0 160))('Size'(200 400)) ⍝ *******  SO WE MUST USE SUBFORMS ********
     
 'Form.Tree.TreeView'⎕WC'TreeView'('Items'Items)('Depth'Depth)('Posn'(0 0))('Size'(200 160))
 'Form.Tree.TreeView'#.Win.Window.SetItemFCol FCol
 'Form.List.ListView'⎕WC'ListView'('Items'Items)('ReportInfo'(8 2⍴⊂'XXX'))('View' 'Report')('Posn'(0 0))('Size'(200 400))
 'Form.List.ListView'#.Win.Window.SetItemFCol FCol
 ⎕DL 1
 FCol←⌽FCol
 Items←⌽Items
 'Form.List.ListView'#.Win.Window.SetItemFCol FCol
 'Form.List.ListView'⎕WS('Items'Items)
 'Form.Tree.TreeView'#.Win.Window.SetItemFCol FCol
 'Form.Tree.TreeView'⎕WS('Items'Items)('Depth'Depth)
     ⍝FCol←#.Win.Window.GetItemFCol'Form.List.ListView'
     ⍝FCol←#.Win.Window.GetItemFCol'Form.Tree.TreeView'
 ⎕DQ'Form'
 #.Win.Exit
∇

∇ GetAll hWnd;hWndParent;ThreadId;ProcessId
 :Repeat
     'ModuleName   ',#.Win.Window.GetModuleFileName hWnd
     'Class        ',#.Win.Window.GetClassName hWnd
     'Unicode      ',⍕#.Win.Window.IsUnicode hWnd
     'Text         ',#.Win.Window.GetText hWnd
     ThreadId ProcessId←#.Win.Window.GetThreadProcessId hWnd
     'ProcessId    ',⍕ProcessId
     'ThreadId     ',⍕ThreadId
     'hWindow      ',⍕hWnd
     'hWndParent   ',⍕#.Win.Window.GetParent hWnd
     'hWndChilds   ',⍕#.Win.Window.EnumChilds hWnd
     'hWindow      0x',#.Win.HexInt hWnd
     'hWndParent   0x',#.Win.HexInt hWndParent←#.Win.Window.GetLong hWnd #.Win.GWL_HWNDPARENT
     'hInstance    0x',#.Win.HexInt #.Win.Window.GetLong hWnd #.Win.GWL_HINSTANCE
     'WndProc      0x',#.Win.HexInt #.Win.Window.GetLong hWnd #.Win.GWL_WNDPROC
     'Style        0x',#.Win.HexInt #.Win.Window.GetLong hWnd #.Win.GWL_STYLE
     'ExStyle      0x',#.Win.HexInt #.Win.Window.GetLong hWnd #.Win.GWL_EXSTYLE
     'UserData     0x',#.Win.HexInt #.Win.Window.GetLong hWnd #.Win.GWL_USERDATA
     'ID           0x',#.Win.HexInt #.Win.Window.GetLong hWnd #.Win.GWL_ID
     'Properties:  '
     ⊃{(13↑1⊃⍵),⍕2⊃⍵}¨#.Win.Window.EnumProps hWnd
     ''
 :Until 0=hWnd←hWndParent
∇

:EndNamespace 
:EndNamespace 
:EndNamespace 
